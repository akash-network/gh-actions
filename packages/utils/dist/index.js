'use strict';

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/long/index.js
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache) UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache) INT_CACHE[value] = obj;
    return obj;
  }
}
function fromNumber(value, unsigned) {
  if (isNaN(value)) return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0) return UZERO;
    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  }
  if (value < 0) return fromNumber(-value, unsigned).neg();
  return fromBits(
    value % TWO_PWR_32_DBL | 0,
    value / TWO_PWR_32_DBL | 0,
    unsigned
  );
}
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
function fromString(str2, unsigned, radix) {
  if (str2.length === 0) throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str2 === "NaN" || str2 === "Infinity" || str2 === "+Infinity" || str2 === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  var p3;
  if ((p3 = str2.indexOf("-")) > 0) throw Error("interior hyphen");
  else if (p3 === 0) {
    return fromString(str2.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result2 = ZERO;
  for (var i = 0; i < str2.length; i += 8) {
    var size = Math.min(8, str2.length - i), value = parseInt(str2.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result2 = result2.mul(power).add(fromNumber(value));
    } else {
      result2 = result2.mul(radixToPower);
      result2 = result2.add(fromNumber(value));
    }
  }
  result2.unsigned = unsigned;
  return result2;
}
function fromValue(val, unsigned) {
  if (typeof val === "number") return fromNumber(val, unsigned);
  if (typeof val === "string") return fromString(val, unsigned);
  return fromBits(
    val.low,
    val.high,
    typeof unsigned === "boolean" ? unsigned : val.unsigned
  );
}
var wasm, INT_CACHE, UINT_CACHE, pow_dbl, TWO_PWR_16_DBL, TWO_PWR_24_DBL, TWO_PWR_32_DBL, TWO_PWR_64_DBL, TWO_PWR_63_DBL, TWO_PWR_24, ZERO, UZERO, ONE, UONE, NEG_ONE, MAX_VALUE, MAX_UNSIGNED_VALUE, MIN_VALUE, LongPrototype;
var init_long = __esm({
  "../../node_modules/long/index.js"() {
    wasm = null;
    try {
      wasm = new WebAssembly.Instance(
        new WebAssembly.Module(
          new Uint8Array([
            // \0asm
            0,
            97,
            115,
            109,
            // version 1
            1,
            0,
            0,
            0,
            // section "type"
            1,
            13,
            2,
            // 0, () => i32
            96,
            0,
            1,
            127,
            // 1, (i32, i32, i32, i32) => i32
            96,
            4,
            127,
            127,
            127,
            127,
            1,
            127,
            // section "function"
            3,
            7,
            6,
            // 0, type 0
            0,
            // 1, type 1
            1,
            // 2, type 1
            1,
            // 3, type 1
            1,
            // 4, type 1
            1,
            // 5, type 1
            1,
            // section "global"
            6,
            6,
            1,
            // 0, "high", mutable i32
            127,
            1,
            65,
            0,
            11,
            // section "export"
            7,
            50,
            6,
            // 0, "mul"
            3,
            109,
            117,
            108,
            0,
            1,
            // 1, "div_s"
            5,
            100,
            105,
            118,
            95,
            115,
            0,
            2,
            // 2, "div_u"
            5,
            100,
            105,
            118,
            95,
            117,
            0,
            3,
            // 3, "rem_s"
            5,
            114,
            101,
            109,
            95,
            115,
            0,
            4,
            // 4, "rem_u"
            5,
            114,
            101,
            109,
            95,
            117,
            0,
            5,
            // 5, "get_high"
            8,
            103,
            101,
            116,
            95,
            104,
            105,
            103,
            104,
            0,
            0,
            // section "code"
            10,
            191,
            1,
            6,
            // 0, "get_high"
            4,
            0,
            35,
            0,
            11,
            // 1, "mul"
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            126,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            // 2, "div_s"
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            127,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            // 3, "div_u"
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            128,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            // 4, "rem_s"
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            129,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            // 5, "rem_u"
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            130,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11
          ])
        ),
        {}
      ).exports;
    } catch {
    }
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", { value: true });
    Long.isLong = isLong;
    INT_CACHE = {};
    UINT_CACHE = {};
    Long.fromInt = fromInt;
    Long.fromNumber = fromNumber;
    Long.fromBits = fromBits;
    pow_dbl = Math.pow;
    Long.fromString = fromString;
    Long.fromValue = fromValue;
    TWO_PWR_16_DBL = 1 << 16;
    TWO_PWR_24_DBL = 1 << 24;
    TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    ZERO = fromInt(0);
    Long.ZERO = ZERO;
    UZERO = fromInt(0, true);
    Long.UZERO = UZERO;
    ONE = fromInt(1);
    Long.ONE = ONE;
    UONE = fromInt(1, true);
    Long.UONE = UONE;
    NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MAX_VALUE = MAX_VALUE;
    MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long.MIN_VALUE = MIN_VALUE;
    LongPrototype = Long.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw RangeError("radix");
      if (this.isZero()) return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result2 = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) return digits + result2;
        else {
          while (digits.length < 6) digits = "0" + digits;
          result2 = "" + digits + result2;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isSafeInteger = function isSafeInteger() {
      var top11Bits = this.high >> 21;
      if (!top11Bits) return true;
      if (this.unsigned) return false;
      return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other)) other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other)) other = fromValue(other);
      if (this.eq(other)) return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) return -1;
      if (!thisNeg && otherNeg) return 1;
      if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend)) addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero()) return this;
      if (!isLong(multiplier)) multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
      if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
        else return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor)) divisor = fromValue(divisor);
      if (divisor.isZero()) throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (this.isZero()) return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE)) return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative()) return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned) divisor = divisor.toUnsigned();
        if (divisor.gt(this)) return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero()) approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor)) divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.countLeadingZeros = function countLeadingZeros() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };
    LongPrototype.clz = LongPrototype.countLeadingZeros;
    LongPrototype.countTrailingZeros = function countTrailingZeros() {
      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };
    LongPrototype.ctz = LongPrototype.countTrailingZeros;
    LongPrototype.and = function and(other) {
      if (!isLong(other)) other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other)) other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other)) other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      else if (numBits < 32)
        return fromBits(
          this.low << numBits,
          this.high << numBits | this.low >>> 32 - numBits,
          this.unsigned
        );
      else return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      else if (numBits < 32)
        return fromBits(
          this.low >>> numBits | this.high << 32 - numBits,
          this.high >> numBits,
          this.unsigned
        );
      else
        return fromBits(
          this.high >> numBits - 32,
          this.high >= 0 ? 0 : -1,
          this.unsigned
        );
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      if (numBits < 32)
        return fromBits(
          this.low >>> numBits | this.high << 32 - numBits,
          this.high >>> numBits,
          this.unsigned
        );
      if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
      return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.rotateLeft = function rotateLeft(numBits) {
      var b;
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(
          this.low << numBits | this.high >>> b,
          this.high << numBits | this.low >>> b,
          this.unsigned
        );
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(
        this.high << numBits | this.low >>> b,
        this.low << numBits | this.high >>> b,
        this.unsigned
      );
    };
    LongPrototype.rotl = LongPrototype.rotateLeft;
    LongPrototype.rotateRight = function rotateRight(numBits) {
      var b;
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(
          this.high << b | this.low >>> numBits,
          this.low << b | this.high >>> numBits,
          this.unsigned
        );
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(
        this.low << b | this.high >>> numBits,
        this.high << b | this.low >>> numBits,
        this.unsigned
      );
    };
    LongPrototype.rotr = LongPrototype.rotateRight;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned) return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned) return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
    if (typeof BigInt === "function") {
      Long.fromBigInt = function fromBigInt(value, unsigned) {
        var lowBits = Number(BigInt.asIntN(32, value));
        var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
        return fromBits(lowBits, highBits, unsigned);
      };
      Long.fromValue = function fromValueWithBigInt(value, unsigned) {
        if (typeof value === "bigint") return Long.fromBigInt(value, unsigned);
        return fromValue(value, unsigned);
      };
      LongPrototype.toBigInt = function toBigInt() {
        var lowBigInt = BigInt(this.low >>> 0);
        var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
        return highBigInt << BigInt(32) | lowBigInt;
      };
    }
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL2) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL2 | 0);
      lowBits = lowBits % TWO_PWR_32_DBL2;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate2(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits = newBits(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate2(bits.lo, bits.hi);
  }
  const result2 = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result2 : result2;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned2(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL2 * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned2(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate2(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result2 = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result2;
  }
  b = this.buf[this.pos++];
  result2 |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result2;
  }
  b = this.buf[this.pos++];
  result2 |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result2;
  }
  b = this.buf[this.pos++];
  result2 |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result2;
  }
  b = this.buf[this.pos++];
  result2 |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result2 >>> 0;
}
var TWO_PWR_32_DBL2, decimalFrom1e7WithLeadingZeros;
var init_varint = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js"() {
    TWO_PWR_32_DBL2 = 4294967296;
    decimalFrom1e7WithLeadingZeros = (digit1e7) => {
      const partial = String(digit1e7);
      return "0000000".slice(partial.length) + partial;
    };
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (!!globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808");
    const MAX = BigInt("9223372036854775807");
    const UMIN = BigInt("0");
    const UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`invalid int64: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`invalid uint64: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
function assertInt64String(value) {
  if (!/^-?[0-9]+$/.test(value)) {
    throw new Error("invalid int64: " + value);
  }
}
function assertUInt64String(value) {
  if (!/^[0-9]+$/.test(value)) {
    throw new Error("invalid uint64: " + value);
  }
}
var protoInt64;
var init_proto_int64 = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js"() {
    init_varint();
    protoInt64 = /* @__PURE__ */ makeInt64Support();
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js
function getTextEncoding() {
  if (globalThis[symbol] == void 0) {
    const te = new globalThis.TextEncoder();
    const td = new globalThis.TextDecoder();
    globalThis[symbol] = {
      encodeUtf8(text) {
        return te.encode(text);
      },
      decodeUtf8(bytes) {
        return td.decode(bytes);
      },
      checkUtf8(text) {
        try {
          encodeURIComponent(text);
          return true;
        } catch (_) {
          return false;
        }
      }
    };
  }
  return globalThis[symbol];
}
var symbol;
var init_text_encoding = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js"() {
    symbol = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js
function assertInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid int32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid uint32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg == "string") {
    const o = arg;
    arg = Number(arg);
    if (Number.isNaN(arg) && o !== "NaN") {
      throw new Error("invalid float32: " + o);
    }
  } else if (typeof arg != "number") {
    throw new Error("invalid float32: " + typeof arg);
  }
  if (Number.isFinite(arg) && (arg > FLOAT32_MAX || arg < FLOAT32_MIN))
    throw new Error("invalid float32: " + arg);
}
var WireType, FLOAT32_MAX, FLOAT32_MIN, UINT32_MAX, INT32_MAX, INT32_MIN, BinaryWriter, BinaryReader;
var init_binary_encoding = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js"() {
    init_varint();
    init_proto_int64();
    init_text_encoding();
    (function(WireType2) {
      WireType2[WireType2["Varint"] = 0] = "Varint";
      WireType2[WireType2["Bit64"] = 1] = "Bit64";
      WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
      WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
      WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
      WireType2[WireType2["Bit32"] = 5] = "Bit32";
    })(WireType || (WireType = {}));
    FLOAT32_MAX = 34028234663852886e22;
    FLOAT32_MIN = -34028234663852886e22;
    UINT32_MAX = 4294967295;
    INT32_MAX = 2147483647;
    INT32_MIN = -2147483648;
    BinaryWriter = class {
      constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {
        this.encodeUtf8 = encodeUtf8;
        this.stack = [];
        this.chunks = [];
        this.buf = [];
      }
      /**
       * Return all bytes written and reset this writer.
       */
      finish() {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
          len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
          bytes.set(this.chunks[i], offset);
          offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
      }
      /**
       * Start a new fork for length-delimited data like a message
       * or a packed repeated field.
       *
       * Must be joined later with `join()`.
       */
      fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
      }
      /**
       * Join the last fork. Write its length and bytes, then
       * return to the previous state.
       */
      join() {
        let chunk = this.finish();
        let prev = this.stack.pop();
        if (!prev)
          throw new Error("invalid state, fork stack empty");
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Writes a tag (field number and wire type).
       *
       * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
       *
       * Generated code should compute the tag ahead of time and call `uint32()`.
       */
      tag(fieldNo, type2) {
        return this.uint32((fieldNo << 3 | type2) >>> 0);
      }
      /**
       * Write a chunk of raw bytes.
       */
      raw(chunk) {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
      }
      /**
       * Write a `uint32` value, an unsigned 32 bit varint.
       */
      uint32(value) {
        assertUInt32(value);
        while (value > 127) {
          this.buf.push(value & 127 | 128);
          value = value >>> 7;
        }
        this.buf.push(value);
        return this;
      }
      /**
       * Write a `int32` value, a signed 32 bit varint.
       */
      int32(value) {
        assertInt32(value);
        varint32write(value, this.buf);
        return this;
      }
      /**
       * Write a `bool` value, a variant.
       */
      bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
      }
      /**
       * Write a `bytes` value, length-delimited arbitrary data.
       */
      bytes(value) {
        this.uint32(value.byteLength);
        return this.raw(value);
      }
      /**
       * Write a `string` value, length-delimited data converted to UTF-8 text.
       */
      string(value) {
        let chunk = this.encodeUtf8(value);
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Write a `float` value, 32-bit floating point number.
       */
      float(value) {
        assertFloat32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `double` value, a 64-bit floating point number.
       */
      double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
       */
      fixed32(value) {
        assertUInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
       */
      sfixed32(value) {
        assertInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
       */
      sint32(value) {
        assertInt32(value);
        value = (value << 1 ^ value >> 31) >>> 0;
        varint32write(value, this.buf);
        return this;
      }
      /**
       * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
       */
      sfixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
       */
      fixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `int64` value, a signed 64-bit varint.
       */
      int64(value) {
        let tc = protoInt64.enc(value);
        varint64write(tc.lo, tc.hi, this.buf);
        return this;
      }
      /**
       * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64(value) {
        const tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
        varint64write(lo, hi, this.buf);
        return this;
      }
      /**
       * Write a `uint64` value, an unsigned 64-bit varint.
       */
      uint64(value) {
        const tc = protoInt64.uEnc(value);
        varint64write(tc.lo, tc.hi, this.buf);
        return this;
      }
    };
    BinaryReader = class {
      constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {
        this.decodeUtf8 = decodeUtf8;
        this.varint64 = varint64read;
        this.uint32 = varint32read;
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      /**
       * Reads a tag - field number and wire type.
       */
      tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
          throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
      }
      /**
       * Skip one element and return the skipped data.
       *
       * When skipping StartGroup, provide the tags field number to check for
       * matching field number in the EndGroup tag.
       */
      skip(wireType, fieldNo) {
        let start = this.pos;
        switch (wireType) {
          case WireType.Varint:
            while (this.buf[this.pos++] & 128) {
            }
            break;
          // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
          case WireType.Bit64:
            this.pos += 4;
          case WireType.Bit32:
            this.pos += 4;
            break;
          case WireType.LengthDelimited:
            let len = this.uint32();
            this.pos += len;
            break;
          case WireType.StartGroup:
            for (; ; ) {
              const [fn, wt] = this.tag();
              if (wt === WireType.EndGroup) {
                if (fieldNo !== void 0 && fn !== fieldNo) {
                  throw new Error("invalid end group tag");
                }
                break;
              }
              this.skip(wt, fn);
            }
            break;
          default:
            throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
      }
      /**
       * Throws error if position in byte array is out of range.
       */
      assertBounds() {
        if (this.pos > this.len)
          throw new RangeError("premature EOF");
      }
      /**
       * Read a `int32` field, a signed 32 bit varint.
       */
      int32() {
        return this.uint32() | 0;
      }
      /**
       * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
       */
      sint32() {
        let zze = this.uint32();
        return zze >>> 1 ^ -(zze & 1);
      }
      /**
       * Read a `int64` field, a signed 64-bit varint.
       */
      int64() {
        return protoInt64.dec(...this.varint64());
      }
      /**
       * Read a `uint64` field, an unsigned 64-bit varint.
       */
      uint64() {
        return protoInt64.uDec(...this.varint64());
      }
      /**
       * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64() {
        let [lo, hi] = this.varint64();
        let s = -(lo & 1);
        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
        hi = hi >>> 1 ^ s;
        return protoInt64.dec(lo, hi);
      }
      /**
       * Read a `bool` field, a variant.
       */
      bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
      }
      /**
       * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
       */
      fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
       */
      sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
       */
      fixed64() {
        return protoInt64.uDec(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
       */
      sfixed64() {
        return protoInt64.dec(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `float` field, 32-bit floating point number.
       */
      float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `double` field, a 64-bit floating point number.
       */
      double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
      }
      /**
       * Read a `bytes` field, length-delimited arbitrary data.
       */
      bytes() {
        let len = this.uint32(), start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
      }
      /**
       * Read a `string` field, length-delimited data converted to UTF-8 text.
       */
      string() {
        return this.decodeUtf8(this.bytes());
      }
    };
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/wire/base64-encoding.js
var init_base64_encoding = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/wire/base64-encoding.js"() {
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/descriptors.js
var ScalarType;
var init_descriptors = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/descriptors.js"() {
    (function(ScalarType2) {
      ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
      ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
      ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
      ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
      ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
      ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
      ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
      ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
      ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
      ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
      ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
      ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
      ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
      ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
      ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
    })(ScalarType || (ScalarType = {}));
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/wire/text-format.js
var init_text_format = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/wire/text-format.js"() {
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/is-message.js
function isMessage(arg, schema4) {
  const isMessage2 = arg !== null && typeof arg == "object" && "$typeName" in arg && typeof arg.$typeName == "string";
  if (!isMessage2) {
    return false;
  }
  if (schema4 === void 0) {
    return true;
  }
  return schema4.typeName === arg.$typeName;
}
var init_is_message = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/is-message.js"() {
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/reflect/error.js
var FieldError;
var init_error = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/reflect/error.js"() {
    FieldError = class extends Error {
      constructor(fieldOrOneof, message, name2 = "FieldValueInvalidError") {
        super(message);
        this.name = name2;
        this.field = () => fieldOrOneof;
      }
    };
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/reflect/scalar.js
function scalarZeroValue(type2, longAsString) {
  switch (type2) {
    case ScalarType.STRING:
      return "";
    case ScalarType.BOOL:
      return false;
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.INT64:
    case ScalarType.UINT64:
    case ScalarType.SFIXED64:
    case ScalarType.FIXED64:
    case ScalarType.SINT64:
      return longAsString ? "0" : protoInt64.zero;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function isScalarZeroValue(type2, value) {
  switch (type2) {
    case ScalarType.BOOL:
      return value === false;
    case ScalarType.STRING:
      return value === "";
    case ScalarType.BYTES:
      return value instanceof Uint8Array && !value.byteLength;
    default:
      return value == 0;
  }
}
var init_scalar = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/reflect/scalar.js"() {
    init_proto_int64();
    init_descriptors();
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/reflect/unsafe.js
function unsafeOneofCase(target, oneof) {
  const c = target[oneof.localName].case;
  if (c === void 0) {
    return c;
  }
  return oneof.fields.find((f) => f.localName === c);
}
function unsafeIsSet(target, field) {
  const name2 = field.localName;
  if (field.oneof) {
    return target[field.oneof.localName].case === name2;
  }
  if (field.presence != IMPLICIT) {
    return target[name2] !== void 0 && Object.prototype.hasOwnProperty.call(target, name2);
  }
  switch (field.fieldKind) {
    case "list":
      return target[name2].length > 0;
    case "map":
      return Object.keys(target[name2]).length > 0;
    case "scalar":
      return !isScalarZeroValue(field.scalar, target[name2]);
    case "enum":
      return target[name2] !== field.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function unsafeGet(target, field) {
  if (field.oneof) {
    const oneof = target[field.oneof.localName];
    if (oneof.case === field.localName) {
      return oneof.value;
    }
    return void 0;
  }
  return target[field.localName];
}
function unsafeSet(target, field, value) {
  if (field.oneof) {
    target[field.oneof.localName] = {
      case: field.localName,
      value
    };
  } else {
    target[field.localName] = value;
  }
}
function unsafeClear(target, field) {
  const name2 = field.localName;
  if (field.oneof) {
    const oneofLocalName = field.oneof.localName;
    if (target[oneofLocalName].case === name2) {
      target[oneofLocalName] = { case: void 0 };
    }
  } else if (field.presence != IMPLICIT) {
    delete target[name2];
  } else {
    switch (field.fieldKind) {
      case "map":
        target[name2] = {};
        break;
      case "list":
        target[name2] = [];
        break;
      case "enum":
        target[name2] = field.enum.values[0].number;
        break;
      case "scalar":
        target[name2] = scalarZeroValue(field.scalar, field.longAsString);
        break;
    }
  }
}
var IMPLICIT, unsafeLocal;
var init_unsafe = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/reflect/unsafe.js"() {
    init_scalar();
    IMPLICIT = 2;
    unsafeLocal = /* @__PURE__ */ Symbol.for("reflect unsafe local");
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/reflect/guard.js
function isObject(arg) {
  return arg !== null && typeof arg == "object" && !Array.isArray(arg);
}
function isReflectList(arg, field) {
  var _a2, _b, _c, _d;
  if (isObject(arg) && unsafeLocal in arg && "add" in arg && "field" in arg && typeof arg.field == "function") {
    if (field !== void 0) {
      const a = field;
      const b = arg.field();
      return a.listKind == b.listKind && a.scalar === b.scalar && ((_a2 = a.message) === null || _a2 === void 0 ? void 0 : _a2.typeName) === ((_b = b.message) === null || _b === void 0 ? void 0 : _b.typeName) && ((_c = a.enum) === null || _c === void 0 ? void 0 : _c.typeName) === ((_d = b.enum) === null || _d === void 0 ? void 0 : _d.typeName);
    }
    return true;
  }
  return false;
}
function isReflectMap(arg, field) {
  var _a2, _b, _c, _d;
  if (isObject(arg) && unsafeLocal in arg && "has" in arg && "field" in arg && typeof arg.field == "function") {
    if (field !== void 0) {
      const a = field, b = arg.field();
      return a.mapKey === b.mapKey && a.mapKind == b.mapKind && a.scalar === b.scalar && ((_a2 = a.message) === null || _a2 === void 0 ? void 0 : _a2.typeName) === ((_b = b.message) === null || _b === void 0 ? void 0 : _b.typeName) && ((_c = a.enum) === null || _c === void 0 ? void 0 : _c.typeName) === ((_d = b.enum) === null || _d === void 0 ? void 0 : _d.typeName);
    }
    return true;
  }
  return false;
}
function isReflectMessage(arg, messageDesc) {
  return isObject(arg) && unsafeLocal in arg && "desc" in arg && isObject(arg.desc) && arg.desc.kind === "message" && (messageDesc === void 0 || arg.desc.typeName == messageDesc.typeName);
}
var init_guard = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/reflect/guard.js"() {
    init_unsafe();
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/reflect/reflect-check.js
function checkField(field, value) {
  const check = field.fieldKind == "list" ? isReflectList(value, field) : field.fieldKind == "map" ? isReflectMap(value, field) : checkSingular(field, value);
  if (check === true) {
    return void 0;
  }
  let reason;
  switch (field.fieldKind) {
    case "list":
      reason = `expected ${formatReflectList(field)}, got ${formatVal(value)}`;
      break;
    case "map":
      reason = `expected ${formatReflectMap(field)}, got ${formatVal(value)}`;
      break;
    default: {
      reason = reasonSingular(field, value, check);
    }
  }
  return new FieldError(field, reason);
}
function checkListItem(field, index, value) {
  const check = checkSingular(field, value);
  if (check !== true) {
    return new FieldError(field, `list item #${index + 1}: ${reasonSingular(field, value, check)}`);
  }
  return void 0;
}
function checkMapEntry(field, key, value) {
  const checkKey = checkScalarValue(key, field.mapKey);
  if (checkKey !== true) {
    return new FieldError(field, `invalid map key: ${reasonSingular({ scalar: field.mapKey }, key, checkKey)}`);
  }
  const checkVal = checkSingular(field, value);
  if (checkVal !== true) {
    return new FieldError(field, `map entry ${formatVal(key)}: ${reasonSingular(field, value, checkVal)}`);
  }
  return void 0;
}
function checkSingular(field, value) {
  if (field.scalar !== void 0) {
    return checkScalarValue(value, field.scalar);
  }
  if (field.enum !== void 0) {
    if (field.enum.open) {
      return Number.isInteger(value);
    }
    return field.enum.values.some((v) => v.number === value);
  }
  return isReflectMessage(value, field.message);
}
function checkScalarValue(value, scalar) {
  switch (scalar) {
    case ScalarType.DOUBLE:
      return typeof value == "number";
    case ScalarType.FLOAT:
      if (typeof value != "number") {
        return false;
      }
      if (Number.isNaN(value) || !Number.isFinite(value)) {
        return true;
      }
      if (value > FLOAT32_MAX || value < FLOAT32_MIN) {
        return `${value.toFixed()} out of range`;
      }
      return true;
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      if (typeof value !== "number" || !Number.isInteger(value)) {
        return false;
      }
      if (value > INT32_MAX || value < INT32_MIN) {
        return `${value.toFixed()} out of range`;
      }
      return true;
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      if (typeof value !== "number" || !Number.isInteger(value)) {
        return false;
      }
      if (value > UINT32_MAX || value < 0) {
        return `${value.toFixed()} out of range`;
      }
      return true;
    case ScalarType.BOOL:
      return typeof value == "boolean";
    case ScalarType.STRING:
      if (typeof value != "string") {
        return false;
      }
      return getTextEncoding().checkUtf8(value) || "invalid UTF8";
    case ScalarType.BYTES:
      return value instanceof Uint8Array;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (typeof value == "bigint" || typeof value == "number" || typeof value == "string" && value.length > 0) {
        try {
          protoInt64.parse(value);
          return true;
        } catch (_) {
          return `${value} out of range`;
        }
      }
      return false;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (typeof value == "bigint" || typeof value == "number" || typeof value == "string" && value.length > 0) {
        try {
          protoInt64.uParse(value);
          return true;
        } catch (_) {
          return `${value} out of range`;
        }
      }
      return false;
  }
}
function reasonSingular(field, val, details) {
  details = typeof details == "string" ? `: ${details}` : `, got ${formatVal(val)}`;
  if (field.scalar !== void 0) {
    return `expected ${scalarTypeDescription(field.scalar)}` + details;
  }
  if (field.enum !== void 0) {
    return `expected ${field.enum.toString()}` + details;
  }
  return `expected ${formatReflectMessage(field.message)}` + details;
}
function formatVal(val) {
  switch (typeof val) {
    case "object":
      if (val === null) {
        return "null";
      }
      if (val instanceof Uint8Array) {
        return `Uint8Array(${val.length})`;
      }
      if (Array.isArray(val)) {
        return `Array(${val.length})`;
      }
      if (isReflectList(val)) {
        return formatReflectList(val.field());
      }
      if (isReflectMap(val)) {
        return formatReflectMap(val.field());
      }
      if (isReflectMessage(val)) {
        return formatReflectMessage(val.desc);
      }
      if (isMessage(val)) {
        return `message ${val.$typeName}`;
      }
      return "object";
    case "string":
      return val.length > 30 ? "string" : `"${val.split('"').join('\\"')}"`;
    case "boolean":
      return String(val);
    case "number":
      return String(val);
    case "bigint":
      return String(val) + "n";
    default:
      return typeof val;
  }
}
function formatReflectMessage(desc) {
  return `ReflectMessage (${desc.typeName})`;
}
function formatReflectList(field) {
  switch (field.listKind) {
    case "message":
      return `ReflectList (${field.message.toString()})`;
    case "enum":
      return `ReflectList (${field.enum.toString()})`;
    case "scalar":
      return `ReflectList (${ScalarType[field.scalar]})`;
  }
}
function formatReflectMap(field) {
  switch (field.mapKind) {
    case "message":
      return `ReflectMap (${ScalarType[field.mapKey]}, ${field.message.toString()})`;
    case "enum":
      return `ReflectMap (${ScalarType[field.mapKey]}, ${field.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${ScalarType[field.mapKey]}, ${ScalarType[field.scalar]})`;
  }
}
function scalarTypeDescription(scalar) {
  switch (scalar) {
    case ScalarType.STRING:
      return "string";
    case ScalarType.BOOL:
      return "boolean";
    case ScalarType.INT64:
    case ScalarType.SINT64:
    case ScalarType.SFIXED64:
      return "bigint (int64)";
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return "bigint (uint64)";
    case ScalarType.BYTES:
      return "Uint8Array";
    case ScalarType.DOUBLE:
      return "number (float64)";
    case ScalarType.FLOAT:
      return "number (float32)";
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      return "number (uint32)";
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      return "number (int32)";
  }
}
var init_reflect_check = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/reflect/reflect-check.js"() {
    init_descriptors();
    init_is_message();
    init_error();
    init_guard();
    init_binary_encoding();
    init_text_encoding();
    init_proto_int64();
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/wkt/wrappers.js
function isWrapper(arg) {
  return isWrapperTypeName(arg.$typeName);
}
function isWrapperDesc(messageDesc) {
  const f = messageDesc.fields[0];
  return isWrapperTypeName(messageDesc.typeName) && f !== void 0 && f.fieldKind == "scalar" && f.name == "value" && f.number == 1;
}
function isWrapperTypeName(name2) {
  return name2.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(name2.substring(16));
}
var init_wrappers = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/wkt/wrappers.js"() {
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/create.js
function create(schema4, init) {
  if (isMessage(init, schema4)) {
    return init;
  }
  const message = createZeroMessage(schema4);
  if (init !== void 0) {
    initMessage(schema4, message, init);
  }
  return message;
}
function initMessage(messageDesc, message, init) {
  for (const member of messageDesc.members) {
    let value = init[member.localName];
    if (value == null) {
      continue;
    }
    let field;
    if (member.kind == "oneof") {
      const oneofField = unsafeOneofCase(init, member);
      if (!oneofField) {
        continue;
      }
      field = oneofField;
      value = unsafeGet(init, oneofField);
    } else {
      field = member;
    }
    switch (field.fieldKind) {
      case "message":
        value = toMessage(field, value);
        break;
      case "scalar":
        value = initScalar(field, value);
        break;
      case "list":
        value = initList(field, value);
        break;
      case "map":
        value = initMap(field, value);
        break;
    }
    unsafeSet(message, field, value);
  }
  return message;
}
function initScalar(field, value) {
  if (field.scalar == ScalarType.BYTES) {
    return toU8Arr(value);
  }
  return value;
}
function initMap(field, value) {
  if (isObject(value)) {
    if (field.scalar == ScalarType.BYTES) {
      return convertObjectValues(value, toU8Arr);
    }
    if (field.mapKind == "message") {
      return convertObjectValues(value, (val) => toMessage(field, val));
    }
  }
  return value;
}
function initList(field, value) {
  if (Array.isArray(value)) {
    if (field.scalar == ScalarType.BYTES) {
      return value.map(toU8Arr);
    }
    if (field.listKind == "message") {
      return value.map((item) => toMessage(field, item));
    }
  }
  return value;
}
function toMessage(field, value) {
  if (field.fieldKind == "message" && !field.oneof && isWrapperDesc(field.message)) {
    return initScalar(field.message.fields[0], value);
  }
  if (isObject(value)) {
    if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName !== "google.protobuf.Value") {
      return value;
    }
    if (!isMessage(value, field.message)) {
      return create(field.message, value);
    }
  }
  return value;
}
function toU8Arr(value) {
  return Array.isArray(value) ? new Uint8Array(value) : value;
}
function convertObjectValues(obj, fn) {
  const ret = {};
  for (const entry of Object.entries(obj)) {
    ret[entry[0]] = fn(entry[1]);
  }
  return ret;
}
function createZeroMessage(desc) {
  let msg;
  if (!needsPrototypeChain(desc)) {
    msg = {
      $typeName: desc.typeName
    };
    for (const member of desc.members) {
      if (member.kind == "oneof" || member.presence == IMPLICIT2) {
        msg[member.localName] = createZeroField(member);
      }
    }
  } else {
    const cached = messagePrototypes.get(desc);
    let prototype;
    let members;
    if (cached) {
      ({ prototype, members } = cached);
    } else {
      prototype = {};
      members = /* @__PURE__ */ new Set();
      for (const member of desc.members) {
        if (member.kind == "oneof") {
          continue;
        }
        if (member.fieldKind != "scalar" && member.fieldKind != "enum") {
          continue;
        }
        if (member.presence == IMPLICIT2) {
          continue;
        }
        members.add(member);
        prototype[member.localName] = createZeroField(member);
      }
      messagePrototypes.set(desc, { prototype, members });
    }
    msg = Object.create(prototype);
    msg.$typeName = desc.typeName;
    for (const member of desc.members) {
      if (members.has(member)) {
        continue;
      }
      if (member.kind == "field") {
        if (member.fieldKind == "message") {
          continue;
        }
        if (member.fieldKind == "scalar" || member.fieldKind == "enum") {
          if (member.presence != IMPLICIT2) {
            continue;
          }
        }
      }
      msg[member.localName] = createZeroField(member);
    }
  }
  return msg;
}
function needsPrototypeChain(desc) {
  switch (desc.file.edition) {
    case EDITION_PROTO3:
      return false;
    case EDITION_PROTO2:
      return true;
    default:
      return desc.fields.some((f) => f.presence != IMPLICIT2 && f.fieldKind != "message" && !f.oneof);
  }
}
function createZeroField(field) {
  if (field.kind == "oneof") {
    return { case: void 0 };
  }
  if (field.fieldKind == "list") {
    return [];
  }
  if (field.fieldKind == "map") {
    return {};
  }
  if (field.fieldKind == "message") {
    return tokenZeroMessageField;
  }
  const defaultValue = field.getDefaultValue();
  if (defaultValue !== void 0) {
    return field.fieldKind == "scalar" && field.longAsString ? defaultValue.toString() : defaultValue;
  }
  return field.fieldKind == "scalar" ? scalarZeroValue(field.scalar, field.longAsString) : field.enum.values[0].number;
}
var EDITION_PROTO3, EDITION_PROTO2, IMPLICIT2, tokenZeroMessageField, messagePrototypes;
var init_create = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/create.js"() {
    init_is_message();
    init_descriptors();
    init_scalar();
    init_guard();
    init_unsafe();
    init_wrappers();
    EDITION_PROTO3 = 999;
    EDITION_PROTO2 = 998;
    IMPLICIT2 = 2;
    tokenZeroMessageField = /* @__PURE__ */ Symbol();
    messagePrototypes = /* @__PURE__ */ new WeakMap();
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/reflect/reflect.js
function reflect(messageDesc, message, check = true) {
  return new ReflectMessageImpl(messageDesc, message, check);
}
function assertOwn(owner, member) {
  if (member.parent.typeName !== owner.$typeName) {
    throw new FieldError(member, `cannot use ${member.toString()} with message ${owner.$typeName}`, "ForeignFieldError");
  }
}
function messageToLocal(field, value) {
  if (!isReflectMessage(value)) {
    return value;
  }
  if (isWrapper(value.message) && !field.oneof && field.fieldKind == "message") {
    return value.message.value;
  }
  if (value.desc.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value") {
    return wktStructToLocal(value.message);
  }
  return value.message;
}
function messageToReflect(field, value, check) {
  if (value !== void 0) {
    if (isWrapperDesc(field.message) && !field.oneof && field.fieldKind == "message") {
      value = {
        $typeName: field.message.typeName,
        value: longToReflect(field.message.fields[0], value)
      };
    } else if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value" && isObject(value)) {
      value = wktStructToReflect(value);
    }
  }
  return new ReflectMessageImpl(field.message, value, check);
}
function listItemToLocal(field, value) {
  if (field.listKind == "message") {
    return messageToLocal(field, value);
  }
  return longToLocal(field, value);
}
function listItemToReflect(field, value, check) {
  if (field.listKind == "message") {
    return messageToReflect(field, value, check);
  }
  return longToReflect(field, value);
}
function mapValueToLocal(field, value) {
  if (field.mapKind == "message") {
    return messageToLocal(field, value);
  }
  return longToLocal(field, value);
}
function mapValueToReflect(field, value, check) {
  if (field.mapKind == "message") {
    return messageToReflect(field, value, check);
  }
  return value;
}
function mapKeyToLocal(key) {
  return typeof key == "string" || typeof key == "number" ? key : String(key);
}
function mapKeyToReflect(key, type2) {
  switch (type2) {
    case ScalarType.STRING:
      return key;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32: {
      const n = Number.parseInt(key);
      if (Number.isFinite(n)) {
        return n;
      }
      break;
    }
    case ScalarType.BOOL:
      switch (key) {
        case "true":
          return true;
        case "false":
          return false;
      }
      break;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      try {
        return protoInt64.uParse(key);
      } catch (_a2) {
      }
      break;
    default:
      try {
        return protoInt64.parse(key);
      } catch (_b) {
      }
      break;
  }
  return key;
}
function longToReflect(field, value) {
  switch (field.scalar) {
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if ("longAsString" in field && field.longAsString && typeof value == "string") {
        value = protoInt64.parse(value);
      }
      break;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if ("longAsString" in field && field.longAsString && typeof value == "string") {
        value = protoInt64.uParse(value);
      }
      break;
  }
  return value;
}
function longToLocal(field, value) {
  switch (field.scalar) {
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if ("longAsString" in field && field.longAsString) {
        value = String(value);
      } else if (typeof value == "string" || typeof value == "number") {
        value = protoInt64.parse(value);
      }
      break;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if ("longAsString" in field && field.longAsString) {
        value = String(value);
      } else if (typeof value == "string" || typeof value == "number") {
        value = protoInt64.uParse(value);
      }
      break;
  }
  return value;
}
function wktStructToReflect(json2) {
  const struct = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (isObject(json2)) {
    for (const [k, v] of Object.entries(json2)) {
      struct.fields[k] = wktValueToReflect(v);
    }
  }
  return struct;
}
function wktStructToLocal(val) {
  const json2 = {};
  for (const [k, v] of Object.entries(val.fields)) {
    json2[k] = wktValueToLocal(v);
  }
  return json2;
}
function wktValueToLocal(val) {
  switch (val.kind.case) {
    case "structValue":
      return wktStructToLocal(val.kind.value);
    case "listValue":
      return val.kind.value.values.map(wktValueToLocal);
    case "nullValue":
    case void 0:
      return null;
    default:
      return val.kind.value;
  }
}
function wktValueToReflect(json2) {
  const value = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof json2) {
    case "number":
      value.kind = { case: "numberValue", value: json2 };
      break;
    case "string":
      value.kind = { case: "stringValue", value: json2 };
      break;
    case "boolean":
      value.kind = { case: "boolValue", value: json2 };
      break;
    case "object":
      if (json2 === null) {
        const nullValue = 0;
        value.kind = { case: "nullValue", value: nullValue };
      } else if (Array.isArray(json2)) {
        const listValue = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(json2)) {
          for (const e of json2) {
            listValue.values.push(wktValueToReflect(e));
          }
        }
        value.kind = {
          case: "listValue",
          value: listValue
        };
      } else {
        value.kind = {
          case: "structValue",
          value: wktStructToReflect(json2)
        };
      }
      break;
  }
  return value;
}
var messageSortedFields, ReflectMessageImpl, ReflectListImpl, ReflectMapImpl;
var init_reflect = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/reflect/reflect.js"() {
    init_descriptors();
    init_reflect_check();
    init_error();
    init_unsafe();
    init_create();
    init_wrappers();
    init_scalar();
    init_proto_int64();
    init_guard();
    messageSortedFields = /* @__PURE__ */ new WeakMap();
    ReflectMessageImpl = class {
      get sortedFields() {
        const cached = messageSortedFields.get(this.desc);
        if (cached) {
          return cached;
        }
        const sortedFields = this.desc.fields.concat().sort((a, b) => a.number - b.number);
        messageSortedFields.set(this.desc, sortedFields);
        return sortedFields;
      }
      constructor(messageDesc, message, check = true) {
        this.lists = /* @__PURE__ */ new Map();
        this.maps = /* @__PURE__ */ new Map();
        this.check = check;
        this.desc = messageDesc;
        this.message = this[unsafeLocal] = message !== null && message !== void 0 ? message : create(messageDesc);
        this.fields = messageDesc.fields;
        this.oneofs = messageDesc.oneofs;
        this.members = messageDesc.members;
      }
      findNumber(number) {
        if (!this._fieldsByNumber) {
          this._fieldsByNumber = new Map(this.desc.fields.map((f) => [f.number, f]));
        }
        return this._fieldsByNumber.get(number);
      }
      oneofCase(oneof) {
        assertOwn(this.message, oneof);
        return unsafeOneofCase(this.message, oneof);
      }
      isSet(field) {
        assertOwn(this.message, field);
        return unsafeIsSet(this.message, field);
      }
      clear(field) {
        assertOwn(this.message, field);
        unsafeClear(this.message, field);
      }
      get(field) {
        assertOwn(this.message, field);
        const value = unsafeGet(this.message, field);
        switch (field.fieldKind) {
          case "list":
            let list = this.lists.get(field);
            if (!list || list[unsafeLocal] !== value) {
              this.lists.set(
                field,
                // biome-ignore lint/suspicious/noAssignInExpressions: no
                list = new ReflectListImpl(field, value, this.check)
              );
            }
            return list;
          case "map":
            let map2 = this.maps.get(field);
            if (!map2 || map2[unsafeLocal] !== value) {
              this.maps.set(
                field,
                // biome-ignore lint/suspicious/noAssignInExpressions: no
                map2 = new ReflectMapImpl(field, value, this.check)
              );
            }
            return map2;
          case "message":
            return messageToReflect(field, value, this.check);
          case "scalar":
            return value === void 0 ? scalarZeroValue(field.scalar, false) : longToReflect(field, value);
          case "enum":
            return value !== null && value !== void 0 ? value : field.enum.values[0].number;
        }
      }
      set(field, value) {
        assertOwn(this.message, field);
        if (this.check) {
          const err = checkField(field, value);
          if (err) {
            throw err;
          }
        }
        let local;
        if (field.fieldKind == "message") {
          local = messageToLocal(field, value);
        } else if (isReflectMap(value) || isReflectList(value)) {
          local = value[unsafeLocal];
        } else {
          local = longToLocal(field, value);
        }
        unsafeSet(this.message, field, local);
      }
      getUnknown() {
        return this.message.$unknown;
      }
      setUnknown(value) {
        this.message.$unknown = value;
      }
    };
    ReflectListImpl = class {
      field() {
        return this._field;
      }
      get size() {
        return this._arr.length;
      }
      constructor(field, unsafeInput, check) {
        this._field = field;
        this._arr = this[unsafeLocal] = unsafeInput;
        this.check = check;
      }
      get(index) {
        const item = this._arr[index];
        return item === void 0 ? void 0 : listItemToReflect(this._field, item, this.check);
      }
      set(index, item) {
        if (index < 0 || index >= this._arr.length) {
          throw new FieldError(this._field, `list item #${index + 1}: out of range`);
        }
        if (this.check) {
          const err = checkListItem(this._field, index, item);
          if (err) {
            throw err;
          }
        }
        this._arr[index] = listItemToLocal(this._field, item);
      }
      add(item) {
        if (this.check) {
          const err = checkListItem(this._field, this._arr.length, item);
          if (err) {
            throw err;
          }
        }
        this._arr.push(listItemToLocal(this._field, item));
        return void 0;
      }
      clear() {
        this._arr.splice(0, this._arr.length);
      }
      [Symbol.iterator]() {
        return this.values();
      }
      keys() {
        return this._arr.keys();
      }
      *values() {
        for (const item of this._arr) {
          yield listItemToReflect(this._field, item, this.check);
        }
      }
      *entries() {
        for (let i = 0; i < this._arr.length; i++) {
          yield [i, listItemToReflect(this._field, this._arr[i], this.check)];
        }
      }
    };
    ReflectMapImpl = class {
      constructor(field, unsafeInput, check = true) {
        this.obj = this[unsafeLocal] = unsafeInput !== null && unsafeInput !== void 0 ? unsafeInput : {};
        this.check = check;
        this._field = field;
      }
      field() {
        return this._field;
      }
      set(key, value) {
        if (this.check) {
          const err = checkMapEntry(this._field, key, value);
          if (err) {
            throw err;
          }
        }
        this.obj[mapKeyToLocal(key)] = mapValueToLocal(this._field, value);
        return this;
      }
      delete(key) {
        const k = mapKeyToLocal(key);
        const has = Object.prototype.hasOwnProperty.call(this.obj, k);
        if (has) {
          delete this.obj[k];
        }
        return has;
      }
      clear() {
        for (const key of Object.keys(this.obj)) {
          delete this.obj[key];
        }
      }
      get(key) {
        let val = this.obj[mapKeyToLocal(key)];
        if (val !== void 0) {
          val = mapValueToReflect(this._field, val, this.check);
        }
        return val;
      }
      has(key) {
        return Object.prototype.hasOwnProperty.call(this.obj, mapKeyToLocal(key));
      }
      *keys() {
        for (const objKey of Object.keys(this.obj)) {
          yield mapKeyToReflect(objKey, this._field.mapKey);
        }
      }
      *entries() {
        for (const objEntry of Object.entries(this.obj)) {
          yield [
            mapKeyToReflect(objEntry[0], this._field.mapKey),
            mapValueToReflect(this._field, objEntry[1], this.check)
          ];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      get size() {
        return Object.keys(this.obj).length;
      }
      *values() {
        for (const val of Object.values(this.obj)) {
          yield mapValueToReflect(this._field, val, this.check);
        }
      }
      forEach(callbackfn, thisArg) {
        for (const mapEntry of this.entries()) {
          callbackfn.call(thisArg, mapEntry[1], mapEntry[0], this);
        }
      }
    };
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/from-binary.js
function makeReadOptions(options) {
  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function fromBinary(schema4, bytes, options) {
  const msg = reflect(schema4, void 0, false);
  readMessage(msg, new BinaryReader(bytes), makeReadOptions(options), false, bytes.byteLength);
  return msg.message;
}
function readMessage(message, reader, options, delimited, lengthOrDelimitedFieldNo) {
  var _a2;
  const end = delimited ? reader.len : reader.pos + lengthOrDelimitedFieldNo;
  let fieldNo;
  let wireType;
  const unknownFields = (_a2 = message.getUnknown()) !== null && _a2 !== void 0 ? _a2 : [];
  while (reader.pos < end) {
    [fieldNo, wireType] = reader.tag();
    if (delimited && wireType == WireType.EndGroup) {
      break;
    }
    const field = message.findNumber(fieldNo);
    if (!field) {
      const data2 = reader.skip(wireType, fieldNo);
      if (options.readUnknownFields) {
        unknownFields.push({ no: fieldNo, wireType, data: data2 });
      }
      continue;
    }
    readField(message, reader, field, wireType, options);
  }
  if (delimited) {
    if (wireType != WireType.EndGroup || fieldNo !== lengthOrDelimitedFieldNo) {
      throw new Error("invalid end group tag");
    }
  }
  if (unknownFields.length > 0) {
    message.setUnknown(unknownFields);
  }
}
function readField(message, reader, field, wireType, options) {
  var _a2;
  switch (field.fieldKind) {
    case "scalar":
      message.set(field, readScalar(reader, field.scalar));
      break;
    case "enum":
      const val = readScalar(reader, ScalarType.INT32);
      if (field.enum.open) {
        message.set(field, val);
      } else {
        const ok = field.enum.values.some((v) => v.number === val);
        if (ok) {
          message.set(field, val);
        } else if (options.readUnknownFields) {
          const bytes = [];
          varint32write(val, bytes);
          const unknownFields = (_a2 = message.getUnknown()) !== null && _a2 !== void 0 ? _a2 : [];
          unknownFields.push({
            no: field.number,
            wireType,
            data: new Uint8Array(bytes)
          });
          message.setUnknown(unknownFields);
        }
      }
      break;
    case "message":
      message.set(field, readMessageField(reader, options, field, message.get(field)));
      break;
    case "list":
      readListField(reader, wireType, message.get(field), options);
      break;
    case "map":
      readMapEntry(reader, message.get(field), options);
      break;
  }
}
function readMapEntry(reader, map2, options) {
  const field = map2.field();
  let key;
  let val;
  const len = reader.uint32();
  const end = reader.pos + len;
  while (reader.pos < end) {
    const [fieldNo] = reader.tag();
    switch (fieldNo) {
      case 1:
        key = readScalar(reader, field.mapKey);
        break;
      case 2:
        switch (field.mapKind) {
          case "scalar":
            val = readScalar(reader, field.scalar);
            break;
          case "enum":
            val = reader.int32();
            break;
          case "message":
            val = readMessageField(reader, options, field);
            break;
        }
        break;
    }
  }
  if (key === void 0) {
    key = scalarZeroValue(field.mapKey, false);
  }
  if (val === void 0) {
    switch (field.mapKind) {
      case "scalar":
        val = scalarZeroValue(field.scalar, false);
        break;
      case "enum":
        val = field.enum.values[0].number;
        break;
      case "message":
        val = reflect(field.message, void 0, false);
        break;
    }
  }
  map2.set(key, val);
}
function readListField(reader, wireType, list, options) {
  var _a2;
  const field = list.field();
  if (field.listKind === "message") {
    list.add(readMessageField(reader, options, field));
    return;
  }
  const scalarType = (_a2 = field.scalar) !== null && _a2 !== void 0 ? _a2 : ScalarType.INT32;
  const packed = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
  if (!packed) {
    list.add(readScalar(reader, scalarType));
    return;
  }
  const e = reader.uint32() + reader.pos;
  while (reader.pos < e) {
    list.add(readScalar(reader, scalarType));
  }
}
function readMessageField(reader, options, field, mergeMessage) {
  const delimited = field.delimitedEncoding;
  const message = mergeMessage !== null && mergeMessage !== void 0 ? mergeMessage : reflect(field.message, void 0, false);
  readMessage(message, reader, options, delimited, delimited ? field.number : reader.uint32());
  return message;
}
function readScalar(reader, type2) {
  switch (type2) {
    case ScalarType.STRING:
      return reader.string();
    case ScalarType.BOOL:
      return reader.bool();
    case ScalarType.DOUBLE:
      return reader.double();
    case ScalarType.FLOAT:
      return reader.float();
    case ScalarType.INT32:
      return reader.int32();
    case ScalarType.INT64:
      return reader.int64();
    case ScalarType.UINT64:
      return reader.uint64();
    case ScalarType.FIXED64:
      return reader.fixed64();
    case ScalarType.BYTES:
      return reader.bytes();
    case ScalarType.FIXED32:
      return reader.fixed32();
    case ScalarType.SFIXED32:
      return reader.sfixed32();
    case ScalarType.SFIXED64:
      return reader.sfixed64();
    case ScalarType.SINT64:
      return reader.sint64();
    case ScalarType.UINT32:
      return reader.uint32();
    case ScalarType.SINT32:
      return reader.sint32();
  }
}
var readDefaults;
var init_from_binary = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/from-binary.js"() {
    init_descriptors();
    init_scalar();
    init_reflect();
    init_binary_encoding();
    init_varint();
    readDefaults = {
      readUnknownFields: true
    };
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/wire/size-delimited.js
var init_size_delimited = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/wire/size-delimited.js"() {
  }
});

// ../../node_modules/@bufbuild/protobuf/dist/esm/wire/index.js
var init_wire = __esm({
  "../../node_modules/@bufbuild/protobuf/dist/esm/wire/index.js"() {
    init_binary_encoding();
    init_base64_encoding();
    init_text_encoding();
    init_text_format();
    init_size_delimited();
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-35BIJBXD.js
function isSet(value) {
  return value !== null && value !== void 0;
}
var __defProp2, __defNormalProp, __publicField, bytesFromBase64, base64FromBytes;
var init_chunk_35BIJBXD = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-35BIJBXD.js"() {
    init_long();
    init_wire();
    init_long();
    __defProp2 = Object.defineProperty;
    __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    bytesFromBase64 = globalThis.Buffer ? (b64) => Uint8Array.from(globalThis.Buffer.from(b64, "base64")) : (b64) => {
      if ("fromBase64" in Uint8Array && typeof Uint8Array.fromBase64 === "function") {
        return Uint8Array.fromBase64(b64);
      }
      const bin = globalThis.atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    };
    base64FromBytes = globalThis.Buffer ? (arr) => globalThis.Buffer.from(arr).toString("base64") : (arr) => {
      if ("toBase64" in arr && typeof arr.toBase64 === "function") {
        return arr.toBase64();
      }
      const bin = [];
      arr.forEach((byte) => {
        bin.push(globalThis.String.fromCharCode(byte));
      });
      return globalThis.btoa(bin.join(""));
    };
  }
});
var init_chunk_JGBH2EPB = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-JGBH2EPB.js"() {
    init_chunk_35BIJBXD();
    init_wire();
  }
});
var init_chunk_5DCYIWCG = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-5DCYIWCG.js"() {
    init_chunk_JGBH2EPB();
    init_chunk_35BIJBXD();
    init_wire();
    init_wire();
    init_wire();
    init_wire();
    init_wire();
    init_wire();
    init_wire();
  }
});
var init_chunk_VRE72ZD5 = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-VRE72ZD5.js"() {
    init_chunk_5DCYIWCG();
    init_chunk_35BIJBXD();
    init_wire();
    init_wire();
    init_wire();
    init_wire();
  }
});
var init_chunk_2NTJ26VF = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-2NTJ26VF.js"() {
    init_chunk_35BIJBXD();
    init_wire();
  }
});

// ../../node_modules/@cosmjs/math/build/decimal.js
var require_decimal = __commonJS({
  "../../node_modules/@cosmjs/math/build/decimal.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Decimal = void 0;
    var maxFractionalDigits = 100;
    var Decimal2 = class _Decimal {
      static fromUserInput(input, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        const badCharacter = input.match(/[^0-9.]/);
        if (badCharacter) {
          throw new Error(`Invalid character at position ${badCharacter.index + 1}`);
        }
        let whole;
        let fractional;
        if (input === "") {
          whole = "0";
          fractional = "";
        } else if (input.search(/\./) === -1) {
          whole = input;
          fractional = "";
        } else {
          const parts = input.split(".");
          switch (parts.length) {
            case 0:
            case 1:
              throw new Error("Fewer than two elements in split result. This must not happen here.");
            case 2:
              if (!parts[1])
                throw new Error("Fractional part missing");
              whole = parts[0];
              fractional = parts[1].replace(/0+$/, "");
              break;
            default:
              throw new Error("More than one separator found");
          }
        }
        if (fractional.length > fractionalDigits) {
          throw new Error("Got more fractional digits than supported");
        }
        const quantity = `${whole}${fractional.padEnd(fractionalDigits, "0")}`;
        return new _Decimal(quantity, fractionalDigits);
      }
      static fromAtomics(atomics, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal(atomics, fractionalDigits);
      }
      /**
       * Creates a Decimal with value 0.0 and the given number of fractional digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static zero(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("0", fractionalDigits);
      }
      /**
       * Creates a Decimal with value 1.0 and the given number of fractional digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static one(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("1" + "0".repeat(fractionalDigits), fractionalDigits);
      }
      static verifyFractionalDigits(fractionalDigits) {
        if (!Number.isInteger(fractionalDigits))
          throw new Error("Fractional digits is not an integer");
        if (fractionalDigits < 0)
          throw new Error("Fractional digits must not be negative");
        if (fractionalDigits > maxFractionalDigits) {
          throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);
        }
      }
      static compare(a, b) {
        if (a.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const difference = a.data.atomics - b.data.atomics;
        if (difference < 0n)
          return -1;
        if (difference > 0n)
          return 1;
        return 0;
      }
      get atomics() {
        return this.data.atomics.toString();
      }
      get fractionalDigits() {
        return this.data.fractionalDigits;
      }
      data;
      constructor(atomics, fractionalDigits) {
        if (!atomics.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format. Only non-negative integers in decimal representation supported.");
        }
        this.data = {
          atomics: BigInt(atomics),
          fractionalDigits
        };
      }
      /** Creates a new instance with the same value */
      clone() {
        return new _Decimal(this.atomics, this.fractionalDigits);
      }
      /** Returns the greatest decimal <= this which has no fractional part (rounding down) */
      floor() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics((whole * factor).toString(), this.fractionalDigits);
        }
      }
      /** Returns the smallest decimal >= this which has no fractional part (rounding up) */
      ceil() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics(((whole + 1n) * factor).toString(), this.fractionalDigits);
        }
      }
      toString() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
          return whole.toString();
        } else {
          const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, "0");
          const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, "");
          return `${whole.toString()}.${trimmedFractionalPart}`;
        }
      }
      /**
       * Returns an approximation as a float type. Only use this if no
       * exact calculation is required.
       */
      toFloatApproximation() {
        const out = Number(this.toString());
        if (Number.isNaN(out))
          throw new Error("Conversion to number failed");
        return out;
      }
      /**
       * a.plus(b) returns a+b.
       *
       * Both values need to have the same fractional digits.
       */
      plus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const sum = this.data.atomics + b.data.atomics;
        return new _Decimal(sum.toString(), this.fractionalDigits);
      }
      /**
       * a.minus(b) returns a-b.
       *
       * Both values need to have the same fractional digits.
       * The resulting difference needs to be non-negative.
       */
      minus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const difference = this.data.atomics - b.data.atomics;
        if (difference < 0n)
          throw new Error("Difference must not be negative");
        return new _Decimal(difference.toString(), this.fractionalDigits);
      }
      /**
       * a.multiply(b) returns a*b.
       *
       * We only allow multiplication by unsigned integers to avoid rounding errors.
       */
      multiply(b) {
        const product = this.data.atomics * b.toBigInt();
        return new _Decimal(product.toString(), this.fractionalDigits);
      }
      equals(b) {
        return _Decimal.compare(this, b) === 0;
      }
      isLessThan(b) {
        return _Decimal.compare(this, b) < 0;
      }
      isLessThanOrEqual(b) {
        return _Decimal.compare(this, b) <= 0;
      }
      isGreaterThan(b) {
        return _Decimal.compare(this, b) > 0;
      }
      isGreaterThanOrEqual(b) {
        return _Decimal.compare(this, b) >= 0;
      }
    };
    exports$1.Decimal = Decimal2;
  }
});

// ../../node_modules/@cosmjs/math/build/integers.js
var require_integers = __commonJS({
  "../../node_modules/@cosmjs/math/build/integers.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Uint64 = exports$1.Uint53 = exports$1.Int53 = exports$1.Uint32 = void 0;
    var uint64MaxValue = 18446744073709551615n;
    var Uint32 = class _Uint32 {
      /** @deprecated use Uint32.fromBytes */
      static fromBigEndianBytes(bytes) {
        return _Uint32.fromBytes(bytes);
      }
      /**
       * Creates a Uint32 from a fixed length byte array.
       *
       * @param bytes a list of exactly 4 bytes
       * @param endianness defaults to big endian
       */
      static fromBytes(bytes, endianness = "be") {
        if (bytes.length !== 4) {
          throw new Error("Invalid input length. Expected 4 bytes.");
        }
        for (let i = 0; i < bytes.length; ++i) {
          if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {
            throw new Error(`Invalid value in byte. Found: ${bytes[i]}`);
          }
        }
        const beBytes = endianness === "be" ? bytes : Array.from(bytes).reverse();
        return new _Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);
      }
      static fromString(str2) {
        if (!str2.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint32(Number.parseInt(str2, 10));
      }
      data;
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < 0 || input > 4294967295) {
          throw new Error("Input not in uint32 range: " + input.toString());
        }
        this.data = input;
      }
      toBytesBigEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 24) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 0) & 255
        ]);
      }
      toBytesLittleEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 0) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 24) & 255
        ]);
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports$1.Uint32 = Uint32;
    var Int53 = class _Int53 {
      static fromString(str2) {
        if (!str2.match(/^-?[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Int53(Number.parseInt(str2, 10));
      }
      data;
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {
          throw new Error("Input not in int53 range: " + input.toString());
        }
        this.data = input;
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports$1.Int53 = Int53;
    var Uint53 = class _Uint53 {
      static fromString(str2) {
        const signed = Int53.fromString(str2);
        return new _Uint53(signed.toNumber());
      }
      data;
      constructor(input) {
        const signed = new Int53(input);
        if (signed.toNumber() < 0) {
          throw new Error("Input is negative");
        }
        this.data = signed;
      }
      toNumber() {
        return this.data.toNumber();
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports$1.Uint53 = Uint53;
    var Uint64 = class _Uint64 {
      /** @deprecated use Uint64.fromBytes */
      static fromBytesBigEndian(bytes) {
        return _Uint64.fromBytes(bytes);
      }
      /**
       * Creates a Uint64 from a fixed length byte array.
       *
       * @param bytes a list of exactly 8 bytes
       * @param endianness defaults to big endian
       */
      static fromBytes(bytes, endianness = "be") {
        if (bytes.length !== 8) {
          throw new Error("Invalid input length. Expected 8 bytes.");
        }
        const beBytes = endianness === "be" ? Array.from(bytes) : Array.from(bytes).reverse();
        let value = 0n;
        for (const byte of beBytes) {
          value *= 256n;
          if (!Number.isInteger(byte) || byte > 255 || byte < 0) {
            throw new Error(`Invalid value in byte. Found: ${byte}`);
          }
          value += BigInt(byte);
        }
        return new _Uint64(value);
      }
      static fromString(str2) {
        if (!str2.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint64(BigInt(str2));
      }
      static fromNumber(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (!Number.isSafeInteger(input)) {
          throw new Error("Input is not a safe integer");
        }
        const bigint = BigInt(input);
        return new _Uint64(bigint);
      }
      data;
      constructor(data2) {
        if (data2 < 0n) {
          throw new Error("Input is negative");
        }
        if (data2 > uint64MaxValue) {
          throw new Error("Input exceeds uint64 range");
        }
        this.data = data2;
      }
      toBytesBigEndian() {
        return this.toBytesLittleEndian().reverse();
      }
      toBytesLittleEndian() {
        const bytes = new Uint8Array(8);
        let value = this.data;
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = Number(value % 256n);
          value /= 256n;
        }
        return bytes;
      }
      toString() {
        return this.data.toString(10);
      }
      toBigInt() {
        return this.data;
      }
      toNumber() {
        if (this.data > BigInt(Number.MAX_SAFE_INTEGER)) {
          throw new Error("number can only safely store up to 53 bits");
        }
        const num = Number(this.data);
        return num;
      }
    };
    exports$1.Uint64 = Uint64;
  }
});

// ../../node_modules/@cosmjs/math/build/index.js
var require_build = __commonJS({
  "../../node_modules/@cosmjs/math/build/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Uint64 = exports$1.Uint53 = exports$1.Uint32 = exports$1.Int53 = exports$1.Decimal = void 0;
    var decimal_1 = require_decimal();
    Object.defineProperty(exports$1, "Decimal", { enumerable: true, get: function() {
      return decimal_1.Decimal;
    } });
    var integers_1 = require_integers();
    Object.defineProperty(exports$1, "Int53", { enumerable: true, get: function() {
      return integers_1.Int53;
    } });
    Object.defineProperty(exports$1, "Uint32", { enumerable: true, get: function() {
      return integers_1.Uint32;
    } });
    Object.defineProperty(exports$1, "Uint53", { enumerable: true, get: function() {
      return integers_1.Uint53;
    } });
    Object.defineProperty(exports$1, "Uint64", { enumerable: true, get: function() {
      return integers_1.Uint64;
    } });
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-WEZWIYX4.js
function unsignedDecimal(value) {
  if (value[0] !== "-") return { sign: "", value };
  const positiveValue = value.slice(1);
  return { sign: "-", value: positiveValue };
}
var import_math, PRECISION, LegacyDec;
var init_chunk_WEZWIYX4 = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-WEZWIYX4.js"() {
    import_math = __toESM(require_build(), 1);
    PRECISION = 18;
    LegacyDec = {
      typeName: "cosmossdk.io/math.LegacyDec",
      shortName: "LegacyDec",
      encode(value) {
        if (!value.length) return "";
        const { sign, value: positiveValue } = unsignedDecimal(value);
        return sign + import_math.Decimal.fromUserInput(positiveValue, PRECISION).atomics;
      },
      decode(value) {
        if (!value.length) return "";
        const { sign, value: positiveValue } = unsignedDecimal(value);
        return sign + import_math.Decimal.fromAtomics(positiveValue, PRECISION).toString();
      }
    };
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-VTTNPU3L.js
function decodeBinary(input) {
  return decoder.decode(input);
}
function encodeBinary(input) {
  return encoder.encode(input);
}
var decoder, encoder, p, patches, patched;
var init_chunk_VTTNPU3L = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-VTTNPU3L.js"() {
    init_chunk_WEZWIYX4();
    decoder = new TextDecoder("utf-8");
    encoder = new TextEncoder();
    p = {
      "cosmos.base.v1beta1.DecCoin"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.amount != null) newValue.amount = LegacyDec[transformType](value.amount);
        return newValue;
      },
      "cosmos.base.v1beta1.DecProto"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.dec != null) newValue.dec = LegacyDec[transformType](value.dec);
        return newValue;
      },
      "cosmos.distribution.v1beta1.Params"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.communityTax != null) newValue.communityTax = LegacyDec[transformType](value.communityTax);
        if (value.baseProposerReward != null) newValue.baseProposerReward = LegacyDec[transformType](value.baseProposerReward);
        if (value.bonusProposerReward != null) newValue.bonusProposerReward = LegacyDec[transformType](value.bonusProposerReward);
        return newValue;
      },
      "cosmos.distribution.v1beta1.ValidatorSlashEvent"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.fraction != null) newValue.fraction = LegacyDec[transformType](value.fraction);
        return newValue;
      },
      "cosmos.distribution.v1beta1.DelegatorStartingInfo"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.stake != null) newValue.stake = LegacyDec[transformType](value.stake);
        return newValue;
      },
      "cosmos.gov.v1beta1.WeightedVoteOption"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.weight != null) newValue.weight = LegacyDec[transformType](value.weight);
        return newValue;
      },
      "cosmos.gov.v1beta1.TallyParams"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.quorum != null) newValue.quorum = encodeBinary(LegacyDec[transformType](decodeBinary(value.quorum)));
        if (value.threshold != null) newValue.threshold = encodeBinary(LegacyDec[transformType](decodeBinary(value.threshold)));
        if (value.vetoThreshold != null) newValue.vetoThreshold = encodeBinary(LegacyDec[transformType](decodeBinary(value.vetoThreshold)));
        return newValue;
      },
      "cosmos.mint.v1beta1.Minter"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.inflation != null) newValue.inflation = LegacyDec[transformType](value.inflation);
        if (value.annualProvisions != null) newValue.annualProvisions = LegacyDec[transformType](value.annualProvisions);
        return newValue;
      },
      "cosmos.mint.v1beta1.Params"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.inflationRateChange != null) newValue.inflationRateChange = LegacyDec[transformType](value.inflationRateChange);
        if (value.inflationMax != null) newValue.inflationMax = LegacyDec[transformType](value.inflationMax);
        if (value.inflationMin != null) newValue.inflationMin = LegacyDec[transformType](value.inflationMin);
        if (value.goalBonded != null) newValue.goalBonded = LegacyDec[transformType](value.goalBonded);
        return newValue;
      },
      "cosmos.mint.v1beta1.QueryInflationResponse"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.inflation != null) newValue.inflation = encodeBinary(LegacyDec[transformType](decodeBinary(value.inflation)));
        return newValue;
      },
      "cosmos.mint.v1beta1.QueryAnnualProvisionsResponse"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.annualProvisions != null) newValue.annualProvisions = encodeBinary(LegacyDec[transformType](decodeBinary(value.annualProvisions)));
        return newValue;
      },
      "cosmos.protocolpool.v1.ContinuousFund"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.percentage != null) newValue.percentage = LegacyDec[transformType](value.percentage);
        return newValue;
      },
      "cosmos.protocolpool.v1.MsgCreateContinuousFund"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.percentage != null) newValue.percentage = LegacyDec[transformType](value.percentage);
        return newValue;
      },
      "cosmos.slashing.v1beta1.Params"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.minSignedPerWindow != null) newValue.minSignedPerWindow = encodeBinary(LegacyDec[transformType](decodeBinary(value.minSignedPerWindow)));
        if (value.slashFractionDoubleSign != null) newValue.slashFractionDoubleSign = encodeBinary(LegacyDec[transformType](decodeBinary(value.slashFractionDoubleSign)));
        if (value.slashFractionDowntime != null) newValue.slashFractionDowntime = encodeBinary(LegacyDec[transformType](decodeBinary(value.slashFractionDowntime)));
        return newValue;
      },
      "cosmos.staking.v1beta1.Validator"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.delegatorShares != null) newValue.delegatorShares = LegacyDec[transformType](value.delegatorShares);
        return newValue;
      },
      "cosmos.staking.v1beta1.CommissionRates"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.rate != null) newValue.rate = LegacyDec[transformType](value.rate);
        if (value.maxRate != null) newValue.maxRate = LegacyDec[transformType](value.maxRate);
        if (value.maxChangeRate != null) newValue.maxChangeRate = LegacyDec[transformType](value.maxChangeRate);
        return newValue;
      },
      "cosmos.staking.v1beta1.Delegation"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.shares != null) newValue.shares = LegacyDec[transformType](value.shares);
        return newValue;
      },
      "cosmos.staking.v1beta1.RedelegationEntry"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.sharesDst != null) newValue.sharesDst = LegacyDec[transformType](value.sharesDst);
        return newValue;
      },
      "cosmos.staking.v1beta1.Params"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.minCommissionRate != null) newValue.minCommissionRate = LegacyDec[transformType](value.minCommissionRate);
        return newValue;
      },
      "cosmos.staking.v1beta1.MsgEditValidator"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.commissionRate != null) newValue.commissionRate = LegacyDec[transformType](value.commissionRate);
        return newValue;
      }
    };
    patches = p;
    patched = (messageDesc) => {
      const patchMessage = patches[messageDesc.$type];
      if (!patchMessage) return messageDesc;
      return {
        ...messageDesc,
        encode(message, writer) {
          return messageDesc.encode(patchMessage(message, "encode"), writer);
        },
        decode(input, length) {
          return patchMessage(messageDesc.decode(input, length), "decode");
        }
      };
    };
  }
});
function createBaseDecCoin() {
  return { denom: "", amount: "" };
}
function createBaseDecProto() {
  return { dec: "" };
}
var _DecCoin, _DecProto;
var init_chunk_ESEV5MX6 = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-ESEV5MX6.js"() {
    init_chunk_VTTNPU3L();
    init_chunk_35BIJBXD();
    init_wire();
    _DecCoin = {
      $type: "cosmos.base.v1beta1.DecCoin",
      encode(message, writer = new BinaryWriter()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.denom = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.amount = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
          amount: isSet(object.amount) ? globalThis.String(object.amount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
          obj.denom = message.denom;
        }
        if (message.amount !== "") {
          obj.amount = message.amount;
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
      }
    };
    _DecProto = {
      $type: "cosmos.base.v1beta1.DecProto",
      encode(message, writer = new BinaryWriter()) {
        if (message.dec !== "") {
          writer.uint32(10).string(message.dec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.dec = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { dec: isSet(object.dec) ? globalThis.String(object.dec) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.dec !== "") {
          obj.dec = message.dec;
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecProto();
        message.dec = object.dec ?? "";
        return message;
      }
    };
    patched(_DecCoin);
    patched(_DecProto);
  }
});
function createBaseTxRaw() {
  return { bodyBytes: new Uint8Array(0), authInfoBytes: new Uint8Array(0), signatures: [] };
}
var TxRaw;
var init_chunk_XIHNXIBW = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-XIHNXIBW.js"() {
    init_chunk_2NTJ26VF();
    init_chunk_ESEV5MX6();
    init_chunk_35BIJBXD();
    init_wire();
    init_long();
    init_wire();
    init_long();
    TxRaw = {
      $type: "cosmos.tx.v1beta1.TxRaw",
      encode(message, writer = new BinaryWriter()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxRaw();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.bodyBytes = reader.bytes();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.authInfoBytes = reader.bytes();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.signatures.push(reader.bytes());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          bodyBytes: isSet(object.body_bytes) ? bytesFromBase64(object.body_bytes) : new Uint8Array(0),
          authInfoBytes: isSet(object.auth_info_bytes) ? bytesFromBase64(object.auth_info_bytes) : new Uint8Array(0),
          signatures: globalThis.Array.isArray(object?.signatures) ? object.signatures.map((e) => bytesFromBase64(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.bodyBytes.length !== 0) {
          obj.body_bytes = base64FromBytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          obj.auth_info_bytes = base64FromBytes(message.authInfoBytes);
        }
        if (message.signatures?.length) {
          obj.signatures = message.signatures.map((e) => base64FromBytes(e));
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxRaw();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array(0);
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array(0);
        message.signatures = object.signatures?.map((e) => e) || [];
        return message;
      }
    };
  }
});
var init_chunk_5YECXI3P = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-5YECXI3P.js"() {
    init_chunk_5DCYIWCG();
    init_chunk_JGBH2EPB();
    init_chunk_ESEV5MX6();
    init_chunk_35BIJBXD();
    init_wire();
    init_wire();
  }
});

// ../../node_modules/jsonify/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/jsonify/lib/parse.js"(exports$1, module) {
    var at;
    var ch;
    var escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
    };
    var text;
    function error(m) {
      throw {
        name: "SyntaxError",
        message: m,
        at,
        text
      };
    }
    function next(c) {
      if (c && c !== ch) {
        error("Expected '" + c + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    }
    function number() {
      var num;
      var str2 = "";
      if (ch === "-") {
        str2 = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        str2 += ch;
        next();
      }
      if (ch === ".") {
        str2 += ".";
        while (next() && ch >= "0" && ch <= "9") {
          str2 += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        str2 += ch;
        next();
        if (ch === "-" || ch === "+") {
          str2 += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          str2 += ch;
          next();
        }
      }
      num = Number(str2);
      if (!isFinite(num)) {
        error("Bad number");
      }
      return num;
    }
    function string() {
      var hex;
      var i;
      var str2 = "";
      var uffff;
      if (ch === '"') {
        while (next()) {
          if (ch === '"') {
            next();
            return str2;
          } else if (ch === "\\") {
            next();
            if (ch === "u") {
              uffff = 0;
              for (i = 0; i < 4; i += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              str2 += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              str2 += escapee[ch];
            } else {
              break;
            }
          } else {
            str2 += ch;
          }
        }
      }
      error("Bad string");
    }
    function white() {
      while (ch && ch <= " ") {
        next();
      }
    }
    function word() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
        default:
          error("Unexpected '" + ch + "'");
      }
    }
    function array() {
      var arr = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return arr;
        }
        while (ch) {
          arr.push(value());
          white();
          if (ch === "]") {
            next("]");
            return arr;
          }
          next(",");
          white();
        }
      }
      error("Bad array");
    }
    function object() {
      var key;
      var obj = {};
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return obj;
        }
        while (ch) {
          key = string();
          white();
          next(":");
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            error('Duplicate key "' + key + '"');
          }
          obj[key] = value();
          white();
          if (ch === "}") {
            next("}");
            return obj;
          }
          next(",");
          white();
        }
      }
      error("Bad object");
    }
    function value() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array();
        case '"':
          return string();
        case "-":
          return number();
        default:
          return ch >= "0" && ch <= "9" ? number() : word();
      }
    }
    module.exports = function(source, reviver) {
      var result2;
      text = source;
      at = 0;
      ch = " ";
      result2 = value();
      white();
      if (ch) {
        error("Syntax error");
      }
      return typeof reviver === "function" ? (function walk(holder, key) {
        var k;
        var v;
        var val = holder[key];
        if (val && typeof val === "object") {
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(val, k)) {
              v = walk(val, k);
              if (typeof v === "undefined") {
                delete val[k];
              } else {
                val[k] = v;
              }
            }
          }
        }
        return reviver.call(holder, key, val);
      })({ "": result2 }, "") : result2;
    };
  }
});

// ../../node_modules/jsonify/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/jsonify/lib/stringify.js"(exports$1, module) {
    var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var gap;
    var indent;
    var meta = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
        var c = meta[a];
        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str2(key, holder) {
      var i;
      var k;
      var v;
      var length;
      var mind = gap;
      var partial;
      var value = holder[key];
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          return quote(value);
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
          return String(value);
        case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i = 0; i < length; i += 1) {
              partial[i] = str2(i, value) || "null";
            }
            v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i = 0; i < length; i += 1) {
              k = rep[i];
              if (typeof k === "string") {
                v = str2(k, value);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          } else {
            for (k in value) {
              if (Object.prototype.hasOwnProperty.call(value, k)) {
                v = str2(k, value);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          }
          v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v;
      }
    }
    module.exports = function(value, replacer, space) {
      var i;
      gap = "";
      indent = "";
      if (typeof space === "number") {
        for (i = 0; i < space; i += 1) {
          indent += " ";
        }
      } else if (typeof space === "string") {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }
      return str2("", { "": value });
    };
  }
});

// ../../node_modules/jsonify/index.js
var require_jsonify = __commonJS({
  "../../node_modules/jsonify/index.js"(exports$1) {
    exports$1.parse = require_parse();
    exports$1.stringify = require_stringify();
  }
});

// ../../node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../../node_modules/isarray/index.js"(exports$1, module) {
    var toString3 = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString3.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/object-keys/isArguments.js"(exports$1, module) {
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str2 = toStr.call(value);
      var isArgs = str2 === "[object Arguments]";
      if (!isArgs) {
        isArgs = str2 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// ../../node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/object-keys/implementation.js"(exports$1, module) {
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = (function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      })();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject4 = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject4 && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject4 && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name2 in object) {
            if (!(skipProto && name2 === "prototype") && has.call(object, name2)) {
              theKeys.push(String(name2));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// ../../node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "../../node_modules/object-keys/index.js"(exports$1, module) {
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = (function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        })(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// ../../node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../../node_modules/es-object-atoms/index.js"(exports$1, module) {
    module.exports = Object;
  }
});

// ../../node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../../node_modules/es-errors/index.js"(exports$1, module) {
    module.exports = Error;
  }
});

// ../../node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../../node_modules/es-errors/eval.js"(exports$1, module) {
    module.exports = EvalError;
  }
});

// ../../node_modules/es-errors/range.js
var require_range = __commonJS({
  "../../node_modules/es-errors/range.js"(exports$1, module) {
    module.exports = RangeError;
  }
});

// ../../node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../../node_modules/es-errors/ref.js"(exports$1, module) {
    module.exports = ReferenceError;
  }
});

// ../../node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../../node_modules/es-errors/syntax.js"(exports$1, module) {
    module.exports = SyntaxError;
  }
});

// ../../node_modules/es-errors/type.js
var require_type = __commonJS({
  "../../node_modules/es-errors/type.js"(exports$1, module) {
    module.exports = TypeError;
  }
});

// ../../node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../../node_modules/es-errors/uri.js"(exports$1, module) {
    module.exports = URIError;
  }
});

// ../../node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../../node_modules/math-intrinsics/abs.js"(exports$1, module) {
    module.exports = Math.abs;
  }
});

// ../../node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../../node_modules/math-intrinsics/floor.js"(exports$1, module) {
    module.exports = Math.floor;
  }
});

// ../../node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../../node_modules/math-intrinsics/max.js"(exports$1, module) {
    module.exports = Math.max;
  }
});

// ../../node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../../node_modules/math-intrinsics/min.js"(exports$1, module) {
    module.exports = Math.min;
  }
});

// ../../node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../../node_modules/math-intrinsics/pow.js"(exports$1, module) {
    module.exports = Math.pow;
  }
});

// ../../node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../../node_modules/math-intrinsics/round.js"(exports$1, module) {
    module.exports = Math.round;
  }
});

// ../../node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/math-intrinsics/isNaN.js"(exports$1, module) {
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// ../../node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../../node_modules/math-intrinsics/sign.js"(exports$1, module) {
    var $isNaN = require_isNaN();
    module.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// ../../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../../node_modules/gopd/gOPD.js"(exports$1, module) {
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/gopd/index.js"(exports$1, module) {
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// ../../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../../node_modules/es-define-property/index.js"(exports$1, module) {
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports$1, module) {
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports$1, module) {
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Reflect.getPrototypeOf.js"(exports$1, module) {
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Object.getPrototypeOf.js"(exports$1, module) {
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports$1, module) {
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str2 = "";
      for (var i = 0; i < arr.length; i += 1) {
        str2 += arr[i];
        if (i + 1 < arr.length) {
          str2 += joiner;
        }
      }
      return str2;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result2 = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result2) === result2) {
            return result2;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty2 = function Empty3() {
        };
        Empty2.prototype = target.prototype;
        bound.prototype = new Empty2();
        Empty2.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports$1, module) {
    var implementation = require_implementation2();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionCall.js"(exports$1, module) {
    module.exports = Function.prototype.call;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionApply.js"(exports$1, module) {
    module.exports = Function.prototype.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/reflectApply.js"(exports$1, module) {
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/actualApply.js"(exports$1, module) {
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// ../../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../../node_modules/call-bind-apply-helpers/index.js"(exports$1, module) {
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// ../../node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../../node_modules/dunder-proto/get.js"(exports$1, module) {
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// ../../node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../../node_modules/get-proto/index.js"(exports$1, module) {
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports$1, module) {
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports$1, module) {
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name2) {
      var value;
      if (name2 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result2 = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result2[result2.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result2;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "../../node_modules/define-data-property/index.js"(exports$1, module) {
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// ../../node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../../node_modules/has-property-descriptors/index.js"(exports$1, module) {
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// ../../node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "../../node_modules/set-function-length/index.js"(exports$1, module) {
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// ../../node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "../../node_modules/call-bind-apply-helpers/applyBind.js"(exports$1, module) {
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// ../../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../node_modules/call-bind/index.js"(exports$1, module) {
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// ../../node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "../../node_modules/call-bound/index.js"(exports$1, module) {
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name2, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// ../../node_modules/json-stable-stringify/index.js
var require_json_stable_stringify = __commonJS({
  "../../node_modules/json-stable-stringify/index.js"(exports$1, module) {
    var jsonStringify = (typeof JSON !== "undefined" ? JSON : require_jsonify()).stringify;
    var isArray = require_isarray();
    var objectKeys = require_object_keys();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var $join = callBound("Array.prototype.join");
    var $indexOf = callBound("Array.prototype.indexOf");
    var $splice = callBound("Array.prototype.splice");
    var $sort = callBound("Array.prototype.sort");
    var strRepeat = function repeat2(n, char) {
      var str2 = "";
      for (var i = 0; i < n; i += 1) {
        str2 += char;
      }
      return str2;
    };
    var defaultReplacer = function(_parent, _key, value) {
      return value;
    };
    module.exports = function stableStringify4(obj) {
      var opts = arguments.length > 1 ? arguments[1] : void 0;
      var space = opts && opts.space || "";
      if (typeof space === "number") {
        space = strRepeat(space, " ");
      }
      var cycles = !!opts && typeof opts.cycles === "boolean" && opts.cycles;
      var replacer = opts && opts.replacer ? callBind(opts.replacer) : defaultReplacer;
      if (opts && typeof opts.collapseEmpty !== "undefined" && typeof opts.collapseEmpty !== "boolean") {
        throw new TypeError("`collapseEmpty` must be a boolean, if provided");
      }
      var collapseEmpty = !!opts && opts.collapseEmpty;
      var cmpOpt = typeof opts === "function" ? opts : opts && opts.cmp;
      var cmp = cmpOpt && function(node) {
        var get = (
          /** @type {NonNullable<typeof cmpOpt>} */
          cmpOpt.length > 2 && /** @type {import('.').Getter['get']} */
          function get2(k) {
            return node[k];
          }
        );
        return function(a, b) {
          return (
            /** @type {NonNullable<typeof cmpOpt>} */
            cmpOpt(
              { key: a, value: node[a] },
              { key: b, value: node[b] },
              // @ts-expect-error TS doesn't understand the optimization used here
              get ? (
                /** @type {import('.').Getter} */
                { __proto__: null, get }
              ) : void 0
            )
          );
        };
      };
      var seen = [];
      return (
        /** @type {(parent: import('.').Node, key: string | number, node: unknown, level: number) => string | undefined} */
        (function stringify(parent, key, node, level) {
          var indent = space ? "\n" + strRepeat(level, space) : "";
          var colonSeparator = space ? ": " : ":";
          if (node && /** @type {{ toJSON?: unknown }} */
          node.toJSON && typeof /** @type {{ toJSON?: unknown }} */
          node.toJSON === "function") {
            node = /** @type {{ toJSON: Function }} */
            node.toJSON();
          }
          node = replacer(parent, key, node);
          if (node === void 0) {
            return;
          }
          if (typeof node !== "object" || node === null) {
            return jsonStringify(node);
          }
          var groupOutput = function(out2, brackets) {
            return collapseEmpty && out2.length === 0 ? brackets : (brackets === "[]" ? "[" : "{") + $join(out2, ",") + indent + (brackets === "[]" ? "]" : "}");
          };
          if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
              var item = stringify(node, i, node[i], level + 1) || jsonStringify(null);
              out[out.length] = indent + space + item;
            }
            return groupOutput(out, "[]");
          }
          if ($indexOf(seen, node) !== -1) {
            if (cycles) {
              return jsonStringify("__cycle__");
            }
            throw new TypeError("Converting circular structure to JSON");
          } else {
            seen[seen.length] = /** @type {import('.').NonArrayNode} */
            node;
          }
          var keys = $sort(objectKeys(node), cmp && cmp(
            /** @type {import('.').NonArrayNode} */
            node
          ));
          var out = [];
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(
              /** @type {import('.').Node} */
              node,
              key,
              /** @type {import('.').NonArrayNode} */
              node[key],
              level + 1
            );
            if (!value) {
              continue;
            }
            var keyValue = jsonStringify(key) + colonSeparator + value;
            out[out.length] = indent + space + keyValue;
          }
          $splice(seen, $indexOf(seen, node), 1);
          return groupOutput(out, "{}");
        })({ "": obj }, "", obj, 0)
      );
    };
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports$1) {
    exports$1.byteLength = byteLength;
    exports$1.toByteArray = toByteArray;
    exports$1.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-YR4WN3VM.js
var query_akash_YR4WN3VM_exports = {};
__export(query_akash_YR4WN3VM_exports, {
  Query: () => Query
});
var Query;
var init_chunk_HA6PREOG = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-HA6PREOG.js"() {
    init_chunk_35BIJBXD();
    init_wire();
    init_long();
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-QTSSWL6T.js
var query_akash_QTSSWL6T_exports = {};
__export(query_akash_QTSSWL6T_exports, {
  Query: () => Query2
});
var Query2;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-GBMTXRJ5.js
var tx_akash_GBMTXRJ5_exports = {};
__export(tx_akash_GBMTXRJ5_exports, {
  Msg: () => Msg
});
var Msg;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-RWDIACGH.js
var query_akash_RWDIACGH_exports = {};
__export(query_akash_RWDIACGH_exports, {
  Query: () => Query3
});
var Query3;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-ACY5H4V3.js
var tx_akash_ACY5H4V3_exports = {};
__export(tx_akash_ACY5H4V3_exports, {
  Msg: () => Msg2
});
var Msg2;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-YADYAEYF.js
var query_akash_YADYAEYF_exports = {};
__export(query_akash_YADYAEYF_exports, {
  Query: () => Query4
});
var Query4;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-AQHBNLRW.js
var query_akash_AQHBNLRW_exports = {};
__export(query_akash_AQHBNLRW_exports, {
  Query: () => Query5
});
var Query5;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-A6JLTFE3.js
var tx_akash_A6JLTFE3_exports = {};
__export(tx_akash_A6JLTFE3_exports, {
  Msg: () => Msg3
});
var Msg3;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/types_akash-NO63F5II.js
var types_akash_NO63F5II_exports = {};
__export(types_akash_NO63F5II_exports, {
  ABCI: () => ABCI
});
var ABCI;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-2L2Y5GBF.js
var query_akash_2L2Y5GBF_exports = {};
__export(query_akash_2L2Y5GBF_exports, {
  Service: () => Service2
});
var Service2;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/reflection_akash-7N6IBKOV.js
var reflection_akash_7N6IBKOV_exports = {};
__export(reflection_akash_7N6IBKOV_exports, {
  ReflectionService: () => ReflectionService
});
var ReflectionService;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/reflection_akash-QXZHFUVK.js
var reflection_akash_QXZHFUVK_exports = {};
__export(reflection_akash_QXZHFUVK_exports, {
  ReflectionService: () => ReflectionService2
});
var ReflectionService2;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-J6WGNFRM.js
var query_akash_J6WGNFRM_exports = {};
__export(query_akash_J6WGNFRM_exports, {
  Service: () => Service3
});
var Service3;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-7ZQ464ZM.js
var tx_akash_7ZQ464ZM_exports = {};
__export(tx_akash_7ZQ464ZM_exports, {
  Msg: () => Msg4
});
var Msg4;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-EM4NPFZC.js
var query_akash_EM4NPFZC_exports = {};
__export(query_akash_EM4NPFZC_exports, {
  Query: () => Query6
});
var Query6;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-K4GE3YDZ.js
var tx_akash_K4GE3YDZ_exports = {};
__export(tx_akash_K4GE3YDZ_exports, {
  Msg: () => Msg5
});
var Msg5;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-CC4GPK5T.js
var query_akash_CC4GPK5T_exports = {};
__export(query_akash_CC4GPK5T_exports, {
  Query: () => Query7
});
var Query7;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-Q5JR6ORF.js
var tx_akash_Q5JR6ORF_exports = {};
__export(tx_akash_Q5JR6ORF_exports, {
  Msg: () => Msg6
});
var Msg6;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-RYPKVZ7C.js
var query_akash_RYPKVZ7C_exports = {};
__export(query_akash_RYPKVZ7C_exports, {
  Query: () => Query8
});
var Query8;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-RUUUEZS3.js
var tx_akash_RUUUEZS3_exports = {};
__export(tx_akash_RUUUEZS3_exports, {
  Msg: () => Msg7
});
var Msg7;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-WEQYHIC3.js
var tx_akash_WEQYHIC3_exports = {};
__export(tx_akash_WEQYHIC3_exports, {
  Msg: () => Msg8
});
var Msg8;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-ZYKYGHGB.js
var query_akash_ZYKYGHGB_exports = {};
__export(query_akash_ZYKYGHGB_exports, {
  Query: () => Query9
});
var Query9;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-ZTQQ7B6W.js
var tx_akash_ZTQQ7B6W_exports = {};
__export(tx_akash_ZTQQ7B6W_exports, {
  Msg: () => Msg9
});
var Msg9;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-2AHFSNJL.js
var query_akash_2AHFSNJL_exports = {};
__export(query_akash_2AHFSNJL_exports, {
  Query: () => Query10
});
var Query10;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-QD6WT5TA.js
var query_akash_QD6WT5TA_exports = {};
__export(query_akash_QD6WT5TA_exports, {
  Query: () => Query11
});
var Query11;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-A37CN5OX.js
var tx_akash_A37CN5OX_exports = {};
__export(tx_akash_A37CN5OX_exports, {
  Msg: () => Msg10
});
var Msg10;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-O2VK7XI7.js
var query_akash_O2VK7XI7_exports = {};
__export(query_akash_O2VK7XI7_exports, {
  Query: () => Query12
});
var Query12;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-3YCJMS6Y.js
var tx_akash_3YCJMS6Y_exports = {};
__export(tx_akash_3YCJMS6Y_exports, {
  Msg: () => Msg11
});
var Msg11;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-IST3STNQ.js
var query_akash_IST3STNQ_exports = {};
__export(query_akash_IST3STNQ_exports, {
  Query: () => Query13
});
var Query13;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-FXR4FY7E.js
var tx_akash_FXR4FY7E_exports = {};
__export(tx_akash_FXR4FY7E_exports, {
  Msg: () => Msg12
});
var Msg12;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-LHHLETWS.js
var query_akash_LHHLETWS_exports = {};
__export(query_akash_LHHLETWS_exports, {
  Query: () => Query14
});
var Query14;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-U5OICQIY.js
var tx_akash_U5OICQIY_exports = {};
__export(tx_akash_U5OICQIY_exports, {
  Msg: () => Msg13
});
var Msg13;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-RPKTKSHZ.js
var query_akash_RPKTKSHZ_exports = {};
__export(query_akash_RPKTKSHZ_exports, {
  Query: () => Query15
});
var Query15;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-U5ZGXJJO.js
var tx_akash_U5ZGXJJO_exports = {};
__export(tx_akash_U5ZGXJJO_exports, {
  Msg: () => Msg14
});
var Msg14;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-ASZNXGQS.js
var query_akash_ASZNXGQS_exports = {};
__export(query_akash_ASZNXGQS_exports, {
  Query: () => Query16
});
var Query16;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-XQRCTZUO.js
var tx_akash_XQRCTZUO_exports = {};
__export(tx_akash_XQRCTZUO_exports, {
  Msg: () => Msg15
});
var Msg15;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-CZGC5YK6.js
var query_akash_CZGC5YK6_exports = {};
__export(query_akash_CZGC5YK6_exports, {
  Query: () => Query17
});
var Query17;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-L42YNERM.js
var tx_akash_L42YNERM_exports = {};
__export(tx_akash_L42YNERM_exports, {
  Msg: () => Msg16
});
var Msg16;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-U6FTSX7A.js
var query_akash_U6FTSX7A_exports = {};
__export(query_akash_U6FTSX7A_exports, {
  Query: () => Query18
});
var Query18;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-QCNQA3ZB.js
var query_akash_QCNQA3ZB_exports = {};
__export(query_akash_QCNQA3ZB_exports, {
  Query: () => Query19
});
var Query19;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-MFMRS2ID.js
var tx_akash_MFMRS2ID_exports = {};
__export(tx_akash_MFMRS2ID_exports, {
  Msg: () => Msg17
});
var Msg17;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/reflection_akash-WUBSNT7I.js
var reflection_akash_WUBSNT7I_exports = {};
__export(reflection_akash_WUBSNT7I_exports, {
  ReflectionService: () => ReflectionService3
});
var ReflectionService3;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-RNOEMF2J.js
var query_akash_RNOEMF2J_exports = {};
__export(query_akash_RNOEMF2J_exports, {
  Query: () => Query20
});
var Query20;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-PJAUGODB.js
var tx_akash_PJAUGODB_exports = {};
__export(tx_akash_PJAUGODB_exports, {
  Msg: () => Msg18
});
var Msg18;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-LQWOK2TQ.js
var query_akash_LQWOK2TQ_exports = {};
__export(query_akash_LQWOK2TQ_exports, {
  Query: () => Query21
});
var Query21;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-2CJAERYQ.js
var tx_akash_2CJAERYQ_exports = {};
__export(tx_akash_2CJAERYQ_exports, {
  Msg: () => Msg19
});
var Msg19;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/grpc_akash-WPXYPHAW.js
var grpc_akash_WPXYPHAW_exports = {};
__export(grpc_akash_WPXYPHAW_exports, {
  ABCIListenerService: () => ABCIListenerService
});
var ABCIListenerService;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-WPIJ5Y3Z.js
var service_akash_WPIJ5Y3Z_exports = {};
__export(service_akash_WPIJ5Y3Z_exports, {
  Service: () => Service4
});
var Service4;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-AHDMWBOV.js
var query_akash_AHDMWBOV_exports = {};
__export(query_akash_AHDMWBOV_exports, {
  Query: () => Query22
});
var Query22;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-PAKHDTTZ.js
var tx_akash_PAKHDTTZ_exports = {};
__export(tx_akash_PAKHDTTZ_exports, {
  Msg: () => Msg20
});
var Msg20;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/tx_akash-XMYD5SGR.js
var tx_akash_XMYD5SGR_exports = {};
__export(tx_akash_XMYD5SGR_exports, {
  Msg: () => Msg21
});
var Msg21;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-ZPJ6T5NI.js
var query_akash_ZPJ6T5NI_exports = {};
__export(query_akash_ZPJ6T5NI_exports, {
  Query: () => Query23
});
var Query23;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-EJTYKJTM.js
var service_akash_EJTYKJTM_exports = {};
__export(service_akash_EJTYKJTM_exports, {
  Msg: () => Msg22
});
var Msg22;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-GEEFQK3U.js
var p2, patches2, patched2;
var init_chunk_GEEFQK3U = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-GEEFQK3U.js"() {
    init_chunk_WEZWIYX4();
    p2 = {
      "akash.bme.v1.CollateralRatio"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.ratio != null) newValue.ratio = LegacyDec[transformType](value.ratio);
        if (value.referencePrice != null) newValue.referencePrice = LegacyDec[transformType](value.referencePrice);
        return newValue;
      },
      "akash.bme.v1.CoinPrice"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.price != null) newValue.price = LegacyDec[transformType](value.price);
        return newValue;
      },
      "akash.bme.v1.EventMintStatusChange"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.collateralRatio != null) newValue.collateralRatio = LegacyDec[transformType](value.collateralRatio);
        return newValue;
      },
      "akash.bme.v1.QueryStatusResponse"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.collateralRatio != null) newValue.collateralRatio = LegacyDec[transformType](value.collateralRatio);
        if (value.warnThreshold != null) newValue.warnThreshold = LegacyDec[transformType](value.warnThreshold);
        if (value.haltThreshold != null) newValue.haltThreshold = LegacyDec[transformType](value.haltThreshold);
        return newValue;
      },
      "cosmos.base.v1beta1.DecCoin"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.amount != null) newValue.amount = LegacyDec[transformType](value.amount);
        return newValue;
      },
      "akash.escrow.types.v1.Balance"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.amount != null) newValue.amount = LegacyDec[transformType](value.amount);
        return newValue;
      },
      "akash.oracle.v1.PriceDataState"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.price != null) newValue.price = LegacyDec[transformType](value.price);
        return newValue;
      },
      "akash.oracle.v1.AggregatedPrice"(value, transformType) {
        if (value == null) return;
        const newValue = { ...value };
        if (value.twap != null) newValue.twap = LegacyDec[transformType](value.twap);
        if (value.medianPrice != null) newValue.medianPrice = LegacyDec[transformType](value.medianPrice);
        if (value.minPrice != null) newValue.minPrice = LegacyDec[transformType](value.minPrice);
        if (value.maxPrice != null) newValue.maxPrice = LegacyDec[transformType](value.maxPrice);
        return newValue;
      }
    };
    patches2 = p2;
    patched2 = (messageDesc) => {
      const patchMessage = patches2[messageDesc.$type];
      if (!patchMessage) return messageDesc;
      return {
        ...messageDesc,
        encode(message, writer) {
          return messageDesc.encode(patchMessage(message, "encode"), writer);
        },
        decode(input, length) {
          return patchMessage(messageDesc.decode(input, length), "decode");
        }
      };
    };
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-N2BNNOTD.js
var query_akash_N2BNNOTD_exports = {};
__export(query_akash_N2BNNOTD_exports, {
  Query: () => Query24
});
var Query24;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-KPU6LPVP.js
var service_akash_KPU6LPVP_exports = {};
__export(service_akash_KPU6LPVP_exports, {
  Msg: () => Msg23
});
var Msg23;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-LWCKZPHL.js
var query_akash_LWCKZPHL_exports = {};
__export(query_akash_LWCKZPHL_exports, {
  Query: () => Query25
});
var Query25;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-5O4BYIF2.js
var service_akash_5O4BYIF2_exports = {};
__export(service_akash_5O4BYIF2_exports, {
  Msg: () => Msg24
});
var Msg24;
var init_chunk_CVQBDXFP = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-CVQBDXFP.js"() {
    init_chunk_ESEV5MX6();
    init_wire();
  }
});
var init_chunk_OHAEKHAC = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-OHAEKHAC.js"() {
    init_chunk_35BIJBXD();
    init_wire();
    init_long();
    init_wire();
    init_long();
  }
});
var init_chunk_HAJWJBJS = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-HAJWJBJS.js"() {
    init_chunk_35BIJBXD();
    init_wire();
  }
});
var init_chunk_NX2OO5DC = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-NX2OO5DC.js"() {
    init_chunk_ESEV5MX6();
    init_chunk_35BIJBXD();
    init_wire();
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-CT7AHZAH.js
function createBaseBalance() {
  return { denom: "", amount: "" };
}
var _Balance;
var init_chunk_CT7AHZAH = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-CT7AHZAH.js"() {
    init_chunk_HAJWJBJS();
    init_chunk_NX2OO5DC();
    init_chunk_GEEFQK3U();
    init_chunk_ESEV5MX6();
    init_chunk_35BIJBXD();
    init_wire();
    init_wire();
    init_long();
    init_wire();
    init_long();
    _Balance = {
      $type: "akash.escrow.types.v1.Balance",
      encode(message, writer = new BinaryWriter()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBalance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.denom = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.amount = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
          amount: isSet(object.amount) ? globalThis.String(object.amount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
          obj.denom = message.denom;
        }
        if (message.amount !== "") {
          obj.amount = message.amount;
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBalance();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
      }
    };
    patched2(_Balance);
  }
});
var init_chunk_JISXXX24 = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-JISXXX24.js"() {
    init_chunk_CVQBDXFP();
    init_chunk_OHAEKHAC();
    init_chunk_5YECXI3P();
    init_chunk_CT7AHZAH();
    init_chunk_HA6PREOG();
    init_chunk_35BIJBXD();
    init_wire();
    init_long();
    init_wire();
    init_long();
    init_wire();
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-4CTLBKZR.js
var query_akash_4CTLBKZR_exports = {};
__export(query_akash_4CTLBKZR_exports, {
  Query: () => Query26
});
var Query26;
var init_chunk_XFCN5LRY = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-XFCN5LRY.js"() {
    init_chunk_CVQBDXFP();
    init_chunk_OHAEKHAC();
    init_chunk_5YECXI3P();
    init_chunk_NX2OO5DC();
    init_chunk_35BIJBXD();
    init_wire();
    init_wire();
    init_wire();
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-AZFAYT7H.js
var service_akash_AZFAYT7H_exports = {};
__export(service_akash_AZFAYT7H_exports, {
  Msg: () => Msg25
});
var Msg25;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-GYTMDAAY.js
var query_akash_GYTMDAAY_exports = {};
__export(query_akash_GYTMDAAY_exports, {
  Query: () => Query27
});
var Query27;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-KKNAAUKF.js
var query_akash_KKNAAUKF_exports = {};
__export(query_akash_KKNAAUKF_exports, {
  Query: () => Query28
});
var Query28;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-4OVOGRBT.js
var query_akash_4OVOGRBT_exports = {};
__export(query_akash_4OVOGRBT_exports, {
  Query: () => Query29
});
var Query29;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-KKV7TGYK.js
var service_akash_KKV7TGYK_exports = {};
__export(service_akash_KKV7TGYK_exports, {
  Msg: () => Msg26
});
var Msg26;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-DJ7LTLRE.js
var query_akash_DJ7LTLRE_exports = {};
__export(query_akash_DJ7LTLRE_exports, {
  Query: () => Query30
});
var Query30;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-WRGOVR7I.js
var service_akash_WRGOVR7I_exports = {};
__export(service_akash_WRGOVR7I_exports, {
  Msg: () => Msg27
});
var Msg27;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-RGYTHUNZ.js
var query_akash_RGYTHUNZ_exports = {};
__export(query_akash_RGYTHUNZ_exports, {
  Query: () => Query31
});
var Query31;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-RQDCQLQH.js
var service_akash_RQDCQLQH_exports = {};
__export(service_akash_RQDCQLQH_exports, {
  Msg: () => Msg28
});
var Msg28;
var init_chunk_ZG2HL3EK = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-ZG2HL3EK.js"() {
    init_chunk_JGBH2EPB();
    init_chunk_35BIJBXD();
    init_wire();
  }
});
var init_chunk_JVVKYOWN = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-JVVKYOWN.js"() {
    init_chunk_ZG2HL3EK();
    init_chunk_HA6PREOG();
    init_chunk_35BIJBXD();
    init_wire();
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-ERHU5RE6.js
var query_akash_ERHU5RE6_exports = {};
__export(query_akash_ERHU5RE6_exports, {
  Query: () => Query32
});
var Query32;
var init_chunk_FDDF54PA = __esm({
  "../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-FDDF54PA.js"() {
    init_chunk_ZG2HL3EK();
    init_chunk_JGBH2EPB();
    init_chunk_35BIJBXD();
    init_wire();
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-7YFQQXNZ.js
var service_akash_7YFQQXNZ_exports = {};
__export(service_akash_7YFQQXNZ_exports, {
  Msg: () => Msg29
});
var Msg29;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-JQTWE7KL.js
var query_akash_JQTWE7KL_exports = {};
__export(query_akash_JQTWE7KL_exports, {
  Query: () => Query33
});
var Query33;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-VYA7TLGK.js
var service_akash_VYA7TLGK_exports = {};
__export(service_akash_VYA7TLGK_exports, {
  Msg: () => Msg30
});
var Msg30;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/query_akash-4IKUAI5T.js
var query_akash_4IKUAI5T_exports = {};
__export(query_akash_4IKUAI5T_exports, {
  Query: () => Query34
});
var Query34;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-VU4ZMTYD.js
var service_akash_VU4ZMTYD_exports = {};
__export(service_akash_VU4ZMTYD_exports, {
  Msg: () => Msg31
});
var Msg31;

// ../../node_modules/cosmjs-types/utf8.js
var require_utf8 = __commonJS({
  "../../node_modules/cosmjs-types/utf8.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.utf8Write = exports$1.utf8Read = exports$1.utf8Length = void 0;
    function utf8Length(str2) {
      let len = 0, c = 0;
      for (let i = 0; i < str2.length; ++i) {
        c = str2.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (str2.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    }
    exports$1.utf8Length = utf8Length;
    function utf8Read(buffer, start, end) {
      const len = end - start;
      if (len < 1)
        return "";
      const chunk = [];
      let parts = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode(...chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode(...chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode(...chunk.slice(0, i));
    }
    exports$1.utf8Read = utf8Read;
    function utf8Write(str2, buffer, offset) {
      const start = offset;
      let c1, c2;
      for (let i = 0; i < str2.length; ++i) {
        c1 = str2.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = str2.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    }
    exports$1.utf8Write = utf8Write;
  }
});

// ../../node_modules/cosmjs-types/varint.js
var require_varint = __commonJS({
  "../../node_modules/cosmjs-types/varint.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.writeByte = exports$1.writeFixed32 = exports$1.int64Length = exports$1.writeVarint64 = exports$1.writeVarint32 = exports$1.readInt32 = exports$1.readUInt32 = exports$1.zzDecode = exports$1.zzEncode = exports$1.varint32read = exports$1.varint32write = exports$1.uInt64ToString = exports$1.int64ToString = exports$1.int64FromString = exports$1.varint64write = exports$1.varint64read = void 0;
    function varint64read2() {
      let lowBits = 0;
      let highBits = 0;
      for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      let middleByte = this.buf[this.pos++];
      lowBits |= (middleByte & 15) << 28;
      highBits = (middleByte & 112) >> 4;
      if ((middleByte & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
      for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      throw new Error("invalid varint");
    }
    exports$1.varint64read = varint64read2;
    function varint64write2(lo, hi, bytes) {
      for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !(shift >>> 7 == 0 && hi == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
      const hasMoreBits = !(hi >> 3 == 0);
      bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
      if (!hasMoreBits) {
        return;
      }
      for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      bytes.push(hi >>> 31 & 1);
    }
    exports$1.varint64write = varint64write2;
    var TWO_PWR_32_DBL3 = 4294967296;
    function int64FromString2(dec) {
      const minus = dec[0] === "-";
      if (minus) {
        dec = dec.slice(1);
      }
      const base = 1e6;
      let lowBits = 0;
      let highBits = 0;
      function add1e6digit(begin, end) {
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        if (lowBits >= TWO_PWR_32_DBL3) {
          highBits = highBits + (lowBits / TWO_PWR_32_DBL3 | 0);
          lowBits = lowBits % TWO_PWR_32_DBL3;
        }
      }
      add1e6digit(-24, -18);
      add1e6digit(-18, -12);
      add1e6digit(-12, -6);
      add1e6digit(-6);
      return minus ? negate3(lowBits, highBits) : newBits2(lowBits, highBits);
    }
    exports$1.int64FromString = int64FromString2;
    function int64ToString2(lo, hi) {
      let bits = newBits2(lo, hi);
      const negative = bits.hi & 2147483648;
      if (negative) {
        bits = negate3(bits.lo, bits.hi);
      }
      const result2 = uInt64ToString2(bits.lo, bits.hi);
      return negative ? "-" + result2 : result2;
    }
    exports$1.int64ToString = int64ToString2;
    function uInt64ToString2(lo, hi) {
      ({ lo, hi } = toUnsigned3(lo, hi));
      if (hi <= 2097151) {
        return String(TWO_PWR_32_DBL3 * hi + lo);
      }
      const low = lo & 16777215;
      const mid = (lo >>> 24 | hi << 8) & 16777215;
      const high = hi >> 16 & 65535;
      let digitA = low + mid * 6777216 + high * 6710656;
      let digitB = mid + high * 8147497;
      let digitC = high * 2;
      const base = 1e7;
      if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
      }
      if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
      }
      return digitC.toString() + decimalFrom1e7WithLeadingZeros2(digitB) + decimalFrom1e7WithLeadingZeros2(digitA);
    }
    exports$1.uInt64ToString = uInt64ToString2;
    function toUnsigned3(lo, hi) {
      return { lo: lo >>> 0, hi: hi >>> 0 };
    }
    function newBits2(lo, hi) {
      return { lo: lo | 0, hi: hi | 0 };
    }
    function negate3(lowBits, highBits) {
      highBits = ~highBits;
      if (lowBits) {
        lowBits = ~lowBits + 1;
      } else {
        highBits += 1;
      }
      return newBits2(lowBits, highBits);
    }
    var decimalFrom1e7WithLeadingZeros2 = (digit1e7) => {
      const partial = String(digit1e7);
      return "0000000".slice(partial.length) + partial;
    };
    function varint32write2(value, bytes) {
      if (value >= 0) {
        while (value > 127) {
          bytes.push(value & 127 | 128);
          value = value >>> 7;
        }
        bytes.push(value);
      } else {
        for (let i = 0; i < 9; i++) {
          bytes.push(value & 127 | 128);
          value = value >> 7;
        }
        bytes.push(1);
      }
    }
    exports$1.varint32write = varint32write2;
    function varint32read2() {
      let b = this.buf[this.pos++];
      let result2 = b & 127;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result2;
      }
      b = this.buf[this.pos++];
      result2 |= (b & 127) << 7;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result2;
      }
      b = this.buf[this.pos++];
      result2 |= (b & 127) << 14;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result2;
      }
      b = this.buf[this.pos++];
      result2 |= (b & 127) << 21;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result2;
      }
      b = this.buf[this.pos++];
      result2 |= (b & 15) << 28;
      for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
      if ((b & 128) != 0)
        throw new Error("invalid varint");
      this.assertBounds();
      return result2 >>> 0;
    }
    exports$1.varint32read = varint32read2;
    function zzEncode(lo, hi) {
      let mask = hi >> 31;
      hi = ((hi << 1 | lo >>> 31) ^ mask) >>> 0;
      lo = (lo << 1 ^ mask) >>> 0;
      return [lo, hi];
    }
    exports$1.zzEncode = zzEncode;
    function zzDecode(lo, hi) {
      let mask = -(lo & 1);
      lo = ((lo >>> 1 | hi << 31) ^ mask) >>> 0;
      hi = (hi >>> 1 ^ mask) >>> 0;
      return [lo, hi];
    }
    exports$1.zzDecode = zzDecode;
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    exports$1.readUInt32 = readUInt32;
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    exports$1.readInt32 = readInt32;
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    exports$1.writeVarint32 = writeVarint32;
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    exports$1.writeVarint64 = writeVarint64;
    function int64Length(lo, hi) {
      let part0 = lo, part1 = (lo >>> 28 | hi << 4) >>> 0, part2 = hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }
    exports$1.int64Length = int64Length;
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    exports$1.writeFixed32 = writeFixed32;
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    exports$1.writeByte = writeByte;
  }
});

// ../../node_modules/cosmjs-types/binary.js
var require_binary = __commonJS({
  "../../node_modules/cosmjs-types/binary.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.BinaryWriter = exports$1.BinaryReader = exports$1.WireType = void 0;
    var utf8_1 = require_utf8();
    var varint_1 = require_varint();
    var WireType2;
    (function(WireType3) {
      WireType3[WireType3["Varint"] = 0] = "Varint";
      WireType3[WireType3["Fixed64"] = 1] = "Fixed64";
      WireType3[WireType3["Bytes"] = 2] = "Bytes";
      WireType3[WireType3["Fixed32"] = 5] = "Fixed32";
    })(WireType2 || (exports$1.WireType = WireType2 = {}));
    var BinaryReader2 = class {
      assertBounds() {
        if (this.pos > this.len)
          throw new RangeError("premature EOF");
      }
      constructor(buf) {
        this.buf = buf ? new Uint8Array(buf) : new Uint8Array(0);
        this.pos = 0;
        this.type = 0;
        this.len = this.buf.length;
      }
      tag() {
        const tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
          throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType, tag];
      }
      skip(length) {
        if (typeof length === "number") {
          if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
          this.pos += length;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      }
      skipType(wireType) {
        switch (wireType) {
          case WireType2.Varint:
            this.skip();
            break;
          case WireType2.Fixed64:
            this.skip(8);
            break;
          case WireType2.Bytes:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case WireType2.Fixed32:
            this.skip(4);
            break;
          /* istanbul ignore next */
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      }
      uint32() {
        return varint_1.varint32read.bind(this)();
      }
      int32() {
        return this.uint32() | 0;
      }
      sint32() {
        const num = this.uint32();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      }
      fixed32() {
        const val = (0, varint_1.readUInt32)(this.buf, this.pos);
        this.pos += 4;
        return val;
      }
      sfixed32() {
        const val = (0, varint_1.readInt32)(this.buf, this.pos);
        this.pos += 4;
        return val;
      }
      int64() {
        const [lo, hi] = varint_1.varint64read.bind(this)();
        return BigInt((0, varint_1.int64ToString)(lo, hi));
      }
      uint64() {
        const [lo, hi] = varint_1.varint64read.bind(this)();
        return BigInt((0, varint_1.uInt64ToString)(lo, hi));
      }
      sint64() {
        let [lo, hi] = varint_1.varint64read.bind(this)();
        [lo, hi] = (0, varint_1.zzDecode)(lo, hi);
        return BigInt((0, varint_1.int64ToString)(lo, hi));
      }
      fixed64() {
        const lo = this.sfixed32();
        const hi = this.sfixed32();
        return BigInt((0, varint_1.uInt64ToString)(lo, hi));
      }
      sfixed64() {
        const lo = this.sfixed32();
        const hi = this.sfixed32();
        return BigInt((0, varint_1.int64ToString)(lo, hi));
      }
      float() {
        throw new Error("float not supported");
      }
      double() {
        throw new Error("double not supported");
      }
      bool() {
        const [lo, hi] = varint_1.varint64read.bind(this)();
        return lo !== 0 || hi !== 0;
      }
      bytes() {
        const len = this.uint32(), start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
      }
      string() {
        const bytes = this.bytes();
        return (0, utf8_1.utf8Read)(bytes, 0, bytes.length);
      }
    };
    exports$1.BinaryReader = BinaryReader2;
    var Op2 = class {
      constructor(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.val = val;
      }
      proceed(buf, pos) {
        if (this.fn) {
          this.fn(this.val, buf, pos);
        }
      }
    };
    var State3 = class {
      constructor(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
    };
    var BinaryWriter2 = class _BinaryWriter {
      constructor() {
        this.len = 0;
        this.uint64 = _BinaryWriter.prototype.int64;
        this.sfixed64 = _BinaryWriter.prototype.fixed64;
        this.sfixed32 = _BinaryWriter.prototype.fixed32;
        this.head = new Op2(null, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      static create() {
        return new _BinaryWriter();
      }
      static alloc(size) {
        if (typeof Uint8Array !== "undefined") {
          return pool((size2) => new Uint8Array(size2), Uint8Array.prototype.subarray)(size);
        } else {
          return new Array(size);
        }
      }
      _push(fn, len, val) {
        this.tail = this.tail.next = new Op2(fn, len, val);
        this.len += len;
        return this;
      }
      finish() {
        let head = this.head.next, pos = 0;
        const buf = _BinaryWriter.alloc(this.len);
        while (head) {
          head.proceed(buf, pos);
          pos += head.len;
          head = head.next;
        }
        return buf;
      }
      fork() {
        this.states = new State3(this);
        this.head = this.tail = new Op2(null, 0, 0);
        this.len = 0;
        return this;
      }
      reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op2(null, 0, 0);
          this.len = 0;
        }
        return this;
      }
      ldelim() {
        const head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      }
      tag(fieldNo, type2) {
        return this.uint32((fieldNo << 3 | type2) >>> 0);
      }
      uint32(value) {
        this.len += (this.tail = this.tail.next = new Op2(varint_1.writeVarint32, (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
        return this;
      }
      int32(value) {
        return value < 0 ? this._push(varint_1.writeVarint64, 10, (0, varint_1.int64FromString)(value.toString())) : this.uint32(value);
      }
      sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      }
      int64(value) {
        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());
        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), { lo, hi });
      }
      sint64(value) {
        let { lo, hi } = (0, varint_1.int64FromString)(value.toString());
        [lo, hi] = (0, varint_1.zzEncode)(lo, hi);
        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), { lo, hi });
      }
      fixed64(value) {
        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());
        return this._push(varint_1.writeFixed32, 4, lo)._push(varint_1.writeFixed32, 4, hi);
      }
      bool(value) {
        return this._push(varint_1.writeByte, 1, value ? 1 : 0);
      }
      fixed32(value) {
        return this._push(varint_1.writeFixed32, 4, value >>> 0);
      }
      float(value) {
        throw new Error("float not supported" + value);
      }
      double(value) {
        throw new Error("double not supported" + value);
      }
      bytes(value) {
        const len = value.length >>> 0;
        if (!len)
          return this._push(varint_1.writeByte, 1, 0);
        return this.uint32(len)._push(writeBytes, len, value);
      }
      string(value) {
        const len = (0, utf8_1.utf8Length)(value);
        return len ? this.uint32(len)._push(utf8_1.utf8Write, len, value) : this._push(varint_1.writeByte, 1, 0);
      }
    };
    exports$1.BinaryWriter = BinaryWriter2;
    function writeBytes(val, buf, pos) {
      if (typeof Uint8Array !== "undefined") {
        buf.set(val, pos);
      } else {
        for (let i = 0; i < val.length; ++i)
          buf[pos + i] = val[i];
      }
    }
    function pool(alloc, slice, size) {
      const SIZE = 8192;
      const MAX = SIZE >>> 1;
      let slab = null;
      let offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        const buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
  }
});

// ../../node_modules/cosmjs-types/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/cosmjs-types/helpers.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.fromJsonTimestamp = exports$1.fromTimestamp = exports$1.toTimestamp = exports$1.isRpc = exports$1.setPaginationParams = exports$1.isObject = exports$1.isSet = exports$1.fromDuration = exports$1.toDuration = exports$1.omitDefault = exports$1.base64FromBytes = exports$1.bytesFromBase64 = void 0;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob2 = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob2(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    exports$1.bytesFromBase64 = bytesFromBase642;
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      arr.forEach((byte) => {
        bin.push(String.fromCharCode(byte));
      });
      return btoa(bin.join(""));
    }
    exports$1.base64FromBytes = base64FromBytes2;
    function omitDefault(input) {
      if (typeof input === "string") {
        return input === "" ? void 0 : input;
      }
      if (typeof input === "number") {
        return input === 0 ? void 0 : input;
      }
      if (typeof input === "boolean") {
        return input === false ? void 0 : input;
      }
      if (typeof input === "bigint") {
        return input === BigInt(0) ? void 0 : input;
      }
      throw new Error(`Got unsupported type ${typeof input}`);
    }
    exports$1.omitDefault = omitDefault;
    function toDuration(duration) {
      return {
        seconds: BigInt(Math.floor(parseInt(duration) / 1e9)),
        nanos: parseInt(duration) % 1e9
      };
    }
    exports$1.toDuration = toDuration;
    function fromDuration(duration) {
      return (parseInt(duration.seconds.toString()) * 1e9 + duration.nanos).toString();
    }
    exports$1.fromDuration = fromDuration;
    function isSet2(value) {
      return value !== null && value !== void 0;
    }
    exports$1.isSet = isSet2;
    function isObject4(value) {
      return typeof value === "object" && value !== null;
    }
    exports$1.isObject = isObject4;
    var setPaginationParams = (options, pagination) => {
      if (!pagination) {
        return options;
      }
      if (typeof pagination?.countTotal !== "undefined") {
        options.params["pagination.count_total"] = pagination.countTotal;
      }
      if (typeof pagination?.key !== "undefined") {
        options.params["pagination.key"] = Buffer.from(pagination.key).toString("base64");
      }
      if (typeof pagination?.limit !== "undefined") {
        options.params["pagination.limit"] = pagination.limit.toString();
      }
      if (typeof pagination?.offset !== "undefined") {
        options.params["pagination.offset"] = pagination.offset.toString();
      }
      if (typeof pagination?.reverse !== "undefined") {
        options.params["pagination.reverse"] = pagination.reverse;
      }
      return options;
    };
    exports$1.setPaginationParams = setPaginationParams;
    function isRpc(rpc) {
      return rpc !== null && rpc !== void 0 && typeof rpc.request === "function";
    }
    exports$1.isRpc = isRpc;
    function toTimestamp2(date) {
      const seconds = numberToLong2(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return {
        seconds,
        nanos
      };
    }
    exports$1.toTimestamp = toTimestamp2;
    function fromTimestamp2(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    exports$1.fromTimestamp = fromTimestamp2;
    var timestampFromJSON = (object) => {
      return {
        seconds: isSet2(object.seconds) ? BigInt(object.seconds.toString()) : BigInt(0),
        nanos: isSet2(object.nanos) ? Number(object.nanos) : 0
      };
    };
    function fromJsonTimestamp2(o) {
      if (o instanceof Date) {
        return toTimestamp2(o);
      } else if (typeof o === "string") {
        return toTimestamp2(new Date(o));
      } else {
        return timestampFromJSON(o);
      }
    }
    exports$1.fromJsonTimestamp = fromJsonTimestamp2;
    function numberToLong2(number) {
      return BigInt(Math.trunc(number));
    }
  }
});

// ../../node_modules/cosmjs-types/google/protobuf/any.js
var require_any = __commonJS({
  "../../node_modules/cosmjs-types/google/protobuf/any.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Any = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "google.protobuf";
    function createBaseAny2() {
      return {
        typeUrl: "",
        value: new Uint8Array()
      };
    }
    exports$1.Any = {
      typeUrl: "/google.protobuf.Any",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.typeUrl !== "") {
          writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAny2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.typeUrl = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAny2();
        if ((0, helpers_1.isSet)(object.typeUrl))
          obj.typeUrl = String(object.typeUrl);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAny2();
        message.typeUrl = object.typeUrl ?? "";
        message.value = object.value ?? new Uint8Array();
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js
var require_multisig = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CompactBitArray = exports$1.MultiSignature = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.crypto.multisig.v1beta1";
    function createBaseMultiSignature() {
      return {
        signatures: []
      };
    }
    exports$1.MultiSignature = {
      typeUrl: "/cosmos.crypto.multisig.v1beta1.MultiSignature",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signatures) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiSignature();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMultiSignature();
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMultiSignature();
        message.signatures = object.signatures?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseCompactBitArray2() {
      return {
        extraBitsStored: 0,
        elems: new Uint8Array()
      };
    }
    exports$1.CompactBitArray = {
      typeUrl: "/cosmos.crypto.multisig.v1beta1.CompactBitArray",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.extraBitsStored !== 0) {
          writer.uint32(8).uint32(message.extraBitsStored);
        }
        if (message.elems.length !== 0) {
          writer.uint32(18).bytes(message.elems);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompactBitArray2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.extraBitsStored = reader.uint32();
              break;
            case 2:
              message.elems = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompactBitArray2();
        if ((0, helpers_1.isSet)(object.extraBitsStored))
          obj.extraBitsStored = Number(object.extraBitsStored);
        if ((0, helpers_1.isSet)(object.elems))
          obj.elems = (0, helpers_1.bytesFromBase64)(object.elems);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.extraBitsStored !== void 0 && (obj.extraBitsStored = Math.round(message.extraBitsStored));
        message.elems !== void 0 && (obj.elems = (0, helpers_1.base64FromBytes)(message.elems !== void 0 ? message.elems : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompactBitArray2();
        message.extraBitsStored = object.extraBitsStored ?? 0;
        message.elems = object.elems ?? new Uint8Array();
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js
var require_signing = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SignatureDescriptor_Data_Multi = exports$1.SignatureDescriptor_Data_Single = exports$1.SignatureDescriptor_Data = exports$1.SignatureDescriptor = exports$1.SignatureDescriptors = exports$1.signModeToJSON = exports$1.signModeFromJSON = exports$1.SignMode = exports$1.protobufPackage = void 0;
    var multisig_1 = require_multisig();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.tx.signing.v1beta1";
    var SignMode;
    (function(SignMode2) {
      SignMode2[SignMode2["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
      SignMode2[SignMode2["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
      SignMode2[SignMode2["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
      SignMode2[SignMode2["SIGN_MODE_DIRECT_AUX"] = 3] = "SIGN_MODE_DIRECT_AUX";
      SignMode2[SignMode2["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
      SignMode2[SignMode2["SIGN_MODE_EIP_191"] = 191] = "SIGN_MODE_EIP_191";
      SignMode2[SignMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignMode || (exports$1.SignMode = SignMode = {}));
    function signModeFromJSON2(object) {
      switch (object) {
        case 0:
        case "SIGN_MODE_UNSPECIFIED":
          return SignMode.SIGN_MODE_UNSPECIFIED;
        case 1:
        case "SIGN_MODE_DIRECT":
          return SignMode.SIGN_MODE_DIRECT;
        case 2:
        case "SIGN_MODE_TEXTUAL":
          return SignMode.SIGN_MODE_TEXTUAL;
        case 3:
        case "SIGN_MODE_DIRECT_AUX":
          return SignMode.SIGN_MODE_DIRECT_AUX;
        case 127:
        case "SIGN_MODE_LEGACY_AMINO_JSON":
          return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        case 191:
        case "SIGN_MODE_EIP_191":
          return SignMode.SIGN_MODE_EIP_191;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignMode.UNRECOGNIZED;
      }
    }
    exports$1.signModeFromJSON = signModeFromJSON2;
    function signModeToJSON2(object) {
      switch (object) {
        case SignMode.SIGN_MODE_UNSPECIFIED:
          return "SIGN_MODE_UNSPECIFIED";
        case SignMode.SIGN_MODE_DIRECT:
          return "SIGN_MODE_DIRECT";
        case SignMode.SIGN_MODE_TEXTUAL:
          return "SIGN_MODE_TEXTUAL";
        case SignMode.SIGN_MODE_DIRECT_AUX:
          return "SIGN_MODE_DIRECT_AUX";
        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
          return "SIGN_MODE_LEGACY_AMINO_JSON";
        case SignMode.SIGN_MODE_EIP_191:
          return "SIGN_MODE_EIP_191";
        case SignMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.signModeToJSON = signModeToJSON2;
    function createBaseSignatureDescriptors() {
      return {
        signatures: []
      };
    }
    exports$1.SignatureDescriptors = {
      typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptors",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signatures) {
          exports$1.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptors();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(exports$1.SignatureDescriptor.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptors();
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => exports$1.SignatureDescriptor.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports$1.SignatureDescriptor.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptors();
        message.signatures = object.signatures?.map((e) => exports$1.SignatureDescriptor.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSignatureDescriptor() {
      return {
        publicKey: void 0,
        data: void 0,
        sequence: BigInt(0)
      };
    }
    exports$1.SignatureDescriptor = {
      typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptor",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          exports$1.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = exports$1.SignatureDescriptor_Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor();
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = exports$1.SignatureDescriptor_Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.data !== void 0 && (obj.data = message.data ? exports$1.SignatureDescriptor_Data.toJSON(message.data) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        if (object.data !== void 0 && object.data !== null) {
          message.data = exports$1.SignatureDescriptor_Data.fromPartial(object.data);
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data() {
      return {
        single: void 0,
        multi: void 0
      };
    }
    exports$1.SignatureDescriptor_Data = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Data",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== void 0) {
          exports$1.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports$1.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports$1.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports$1.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data();
        if ((0, helpers_1.isSet)(object.single))
          obj.single = exports$1.SignatureDescriptor_Data_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi))
          obj.multi = exports$1.SignatureDescriptor_Data_Multi.fromJSON(object.multi);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports$1.SignatureDescriptor_Data_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports$1.SignatureDescriptor_Data_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data();
        if (object.single !== void 0 && object.single !== null) {
          message.single = exports$1.SignatureDescriptor_Data_Single.fromPartial(object.single);
        }
        if (object.multi !== void 0 && object.multi !== null) {
          message.multi = exports$1.SignatureDescriptor_Data_Multi.fromPartial(object.multi);
        }
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Single() {
      return {
        mode: 0,
        signature: new Uint8Array()
      };
    }
    exports$1.SignatureDescriptor_Data_Single = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Single",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        if (message.signature.length !== 0) {
          writer.uint32(18).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            case 2:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data_Single();
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = signModeFromJSON2(object.mode);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = signModeToJSON2(message.mode));
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data_Single();
        message.mode = object.mode ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Multi() {
      return {
        bitarray: void 0,
        signatures: []
      };
    }
    exports$1.SignatureDescriptor_Data_Multi = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Multi",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports$1.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.signatures.push(exports$1.SignatureDescriptor_Data.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data_Multi();
        if ((0, helpers_1.isSet)(object.bitarray))
          obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => exports$1.SignatureDescriptor_Data.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports$1.SignatureDescriptor_Data.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data_Multi();
        if (object.bitarray !== void 0 && object.bitarray !== null) {
          message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        }
        message.signatures = object.signatures?.map((e) => exports$1.SignatureDescriptor_Data.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js
var require_coin = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DecProto = exports$1.IntProto = exports$1.DecCoin = exports$1.Coin = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.base.v1beta1";
    function createBaseCoin2() {
      return {
        denom: "",
        amount: ""
      };
    }
    exports$1.Coin = {
      typeUrl: "/cosmos.base.v1beta1.Coin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCoin2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCoin2();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCoin2();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
      }
    };
    function createBaseDecCoin2() {
      return {
        denom: "",
        amount: ""
      };
    }
    exports$1.DecCoin = {
      typeUrl: "/cosmos.base.v1beta1.DecCoin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecCoin2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecCoin2();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecCoin2();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
      }
    };
    function createBaseIntProto() {
      return {
        int: ""
      };
    }
    exports$1.IntProto = {
      typeUrl: "/cosmos.base.v1beta1.IntProto",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.int !== "") {
          writer.uint32(10).string(message.int);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIntProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.int = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIntProto();
        if ((0, helpers_1.isSet)(object.int))
          obj.int = String(object.int);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.int !== void 0 && (obj.int = message.int);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIntProto();
        message.int = object.int ?? "";
        return message;
      }
    };
    function createBaseDecProto2() {
      return {
        dec: ""
      };
    }
    exports$1.DecProto = {
      typeUrl: "/cosmos.base.v1beta1.DecProto",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.dec !== "") {
          writer.uint32(10).string(message.dec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecProto2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.dec = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecProto2();
        if ((0, helpers_1.isSet)(object.dec))
          obj.dec = String(object.dec);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.dec !== void 0 && (obj.dec = message.dec);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecProto2();
        message.dec = object.dec ?? "";
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js
var require_tx = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.AuxSignerData = exports$1.Tip = exports$1.Fee = exports$1.ModeInfo_Multi = exports$1.ModeInfo_Single = exports$1.ModeInfo = exports$1.SignerInfo = exports$1.AuthInfo = exports$1.TxBody = exports$1.SignDocDirectAux = exports$1.SignDoc = exports$1.TxRaw = exports$1.Tx = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var signing_1 = require_signing();
    var multisig_1 = require_multisig();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.tx.v1beta1";
    function createBaseTx2() {
      return {
        body: void 0,
        authInfo: void 0,
        signatures: []
      };
    }
    exports$1.Tx = {
      typeUrl: "/cosmos.tx.v1beta1.Tx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.body !== void 0) {
          exports$1.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
        }
        if (message.authInfo !== void 0) {
          exports$1.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTx2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.body = exports$1.TxBody.decode(reader, reader.uint32());
              break;
            case 2:
              message.authInfo = exports$1.AuthInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTx2();
        if ((0, helpers_1.isSet)(object.body))
          obj.body = exports$1.TxBody.fromJSON(object.body);
        if ((0, helpers_1.isSet)(object.authInfo))
          obj.authInfo = exports$1.AuthInfo.fromJSON(object.authInfo);
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.body !== void 0 && (obj.body = message.body ? exports$1.TxBody.toJSON(message.body) : void 0);
        message.authInfo !== void 0 && (obj.authInfo = message.authInfo ? exports$1.AuthInfo.toJSON(message.authInfo) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTx2();
        if (object.body !== void 0 && object.body !== null) {
          message.body = exports$1.TxBody.fromPartial(object.body);
        }
        if (object.authInfo !== void 0 && object.authInfo !== null) {
          message.authInfo = exports$1.AuthInfo.fromPartial(object.authInfo);
        }
        message.signatures = object.signatures?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseTxRaw2() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        signatures: []
      };
    }
    exports$1.TxRaw = {
      typeUrl: "/cosmos.tx.v1beta1.TxRaw",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxRaw2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxRaw2();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes))
          obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxRaw2();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.signatures = object.signatures?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseSignDoc() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        chainId: "",
        accountNumber: BigInt(0)
      };
    }
    exports$1.SignDoc = {
      typeUrl: "/cosmos.tx.v1beta1.SignDoc",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(32).uint64(message.accountNumber);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDoc();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignDoc();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes))
          obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignDoc();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        return message;
      }
    };
    function createBaseSignDocDirectAux() {
      return {
        bodyBytes: new Uint8Array(),
        publicKey: void 0,
        chainId: "",
        accountNumber: BigInt(0),
        sequence: BigInt(0),
        tip: void 0
      };
    }
    exports$1.SignDocDirectAux = {
      typeUrl: "/cosmos.tx.v1beta1.SignDocDirectAux",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(32).uint64(message.accountNumber);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(40).uint64(message.sequence);
        }
        if (message.tip !== void 0) {
          exports$1.Tip.encode(message.tip, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDocDirectAux();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = reader.uint64();
              break;
            case 5:
              message.sequence = reader.uint64();
              break;
            case 6:
              message.tip = exports$1.Tip.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignDocDirectAux();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.tip))
          obj.tip = exports$1.Tip.fromJSON(object.tip);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.tip !== void 0 && (obj.tip = message.tip ? exports$1.Tip.toJSON(message.tip) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignDocDirectAux();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        if (object.tip !== void 0 && object.tip !== null) {
          message.tip = exports$1.Tip.fromPartial(object.tip);
        }
        return message;
      }
    };
    function createBaseTxBody2() {
      return {
        messages: [],
        memo: "",
        timeoutHeight: BigInt(0),
        extensionOptions: [],
        nonCriticalExtensionOptions: []
      };
    }
    exports$1.TxBody = {
      typeUrl: "/cosmos.tx.v1beta1.TxBody",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.memo !== "") {
          writer.uint32(18).string(message.memo);
        }
        if (message.timeoutHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.timeoutHeight);
        }
        for (const v of message.extensionOptions) {
          any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();
        }
        for (const v of message.nonCriticalExtensionOptions) {
          any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxBody2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.memo = reader.string();
              break;
            case 3:
              message.timeoutHeight = reader.uint64();
              break;
            case 1023:
              message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2047:
              message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxBody2();
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.memo))
          obj.memo = String(object.memo);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = BigInt(object.timeoutHeight.toString());
        if (Array.isArray(object?.extensionOptions))
          obj.extensionOptions = object.extensionOptions.map((e) => any_1.Any.fromJSON(e));
        if (Array.isArray(object?.nonCriticalExtensionOptions))
          obj.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.memo !== void 0 && (obj.memo = message.memo);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = (message.timeoutHeight || BigInt(0)).toString());
        if (message.extensionOptions) {
          obj.extensionOptions = message.extensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.extensionOptions = [];
        }
        if (message.nonCriticalExtensionOptions) {
          obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.nonCriticalExtensionOptions = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxBody2();
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.memo = object.memo ?? "";
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = BigInt(object.timeoutHeight.toString());
        }
        message.extensionOptions = object.extensionOptions?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseAuthInfo2() {
      return {
        signerInfos: [],
        fee: void 0,
        tip: void 0
      };
    }
    exports$1.AuthInfo = {
      typeUrl: "/cosmos.tx.v1beta1.AuthInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signerInfos) {
          exports$1.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.fee !== void 0) {
          exports$1.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        }
        if (message.tip !== void 0) {
          exports$1.Tip.encode(message.tip, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signerInfos.push(exports$1.SignerInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.fee = exports$1.Fee.decode(reader, reader.uint32());
              break;
            case 3:
              message.tip = exports$1.Tip.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAuthInfo2();
        if (Array.isArray(object?.signerInfos))
          obj.signerInfos = object.signerInfos.map((e) => exports$1.SignerInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.fee))
          obj.fee = exports$1.Fee.fromJSON(object.fee);
        if ((0, helpers_1.isSet)(object.tip))
          obj.tip = exports$1.Tip.fromJSON(object.tip);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signerInfos) {
          obj.signerInfos = message.signerInfos.map((e) => e ? exports$1.SignerInfo.toJSON(e) : void 0);
        } else {
          obj.signerInfos = [];
        }
        message.fee !== void 0 && (obj.fee = message.fee ? exports$1.Fee.toJSON(message.fee) : void 0);
        message.tip !== void 0 && (obj.tip = message.tip ? exports$1.Tip.toJSON(message.tip) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAuthInfo2();
        message.signerInfos = object.signerInfos?.map((e) => exports$1.SignerInfo.fromPartial(e)) || [];
        if (object.fee !== void 0 && object.fee !== null) {
          message.fee = exports$1.Fee.fromPartial(object.fee);
        }
        if (object.tip !== void 0 && object.tip !== null) {
          message.tip = exports$1.Tip.fromPartial(object.tip);
        }
        return message;
      }
    };
    function createBaseSignerInfo2() {
      return {
        publicKey: void 0,
        modeInfo: void 0,
        sequence: BigInt(0)
      };
    }
    exports$1.SignerInfo = {
      typeUrl: "/cosmos.tx.v1beta1.SignerInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.modeInfo !== void 0) {
          exports$1.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignerInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfo = exports$1.ModeInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignerInfo2();
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.modeInfo))
          obj.modeInfo = exports$1.ModeInfo.fromJSON(object.modeInfo);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.modeInfo !== void 0 && (obj.modeInfo = message.modeInfo ? exports$1.ModeInfo.toJSON(message.modeInfo) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignerInfo2();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        if (object.modeInfo !== void 0 && object.modeInfo !== null) {
          message.modeInfo = exports$1.ModeInfo.fromPartial(object.modeInfo);
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseModeInfo2() {
      return {
        single: void 0,
        multi: void 0
      };
    }
    exports$1.ModeInfo = {
      typeUrl: "/cosmos.tx.v1beta1.ModeInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== void 0) {
          exports$1.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports$1.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports$1.ModeInfo_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports$1.ModeInfo_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo2();
        if ((0, helpers_1.isSet)(object.single))
          obj.single = exports$1.ModeInfo_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi))
          obj.multi = exports$1.ModeInfo_Multi.fromJSON(object.multi);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports$1.ModeInfo_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports$1.ModeInfo_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo2();
        if (object.single !== void 0 && object.single !== null) {
          message.single = exports$1.ModeInfo_Single.fromPartial(object.single);
        }
        if (object.multi !== void 0 && object.multi !== null) {
          message.multi = exports$1.ModeInfo_Multi.fromPartial(object.multi);
        }
        return message;
      }
    };
    function createBaseModeInfo_Single2() {
      return {
        mode: 0
      };
    }
    exports$1.ModeInfo_Single = {
      typeUrl: "/cosmos.tx.v1beta1.Single",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Single2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo_Single2();
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo_Single2();
        message.mode = object.mode ?? 0;
        return message;
      }
    };
    function createBaseModeInfo_Multi2() {
      return {
        bitarray: void 0,
        modeInfos: []
      };
    }
    exports$1.ModeInfo_Multi = {
      typeUrl: "/cosmos.tx.v1beta1.Multi",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.modeInfos) {
          exports$1.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Multi2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfos.push(exports$1.ModeInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo_Multi2();
        if ((0, helpers_1.isSet)(object.bitarray))
          obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object?.modeInfos))
          obj.modeInfos = object.modeInfos.map((e) => exports$1.ModeInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.modeInfos) {
          obj.modeInfos = message.modeInfos.map((e) => e ? exports$1.ModeInfo.toJSON(e) : void 0);
        } else {
          obj.modeInfos = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo_Multi2();
        if (object.bitarray !== void 0 && object.bitarray !== null) {
          message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        }
        message.modeInfos = object.modeInfos?.map((e) => exports$1.ModeInfo.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseFee2() {
      return {
        amount: [],
        gasLimit: BigInt(0),
        payer: "",
        granter: ""
      };
    }
    exports$1.Fee = {
      typeUrl: "/cosmos.tx.v1beta1.Fee",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.gasLimit !== BigInt(0)) {
          writer.uint32(16).uint64(message.gasLimit);
        }
        if (message.payer !== "") {
          writer.uint32(26).string(message.payer);
        }
        if (message.granter !== "") {
          writer.uint32(34).string(message.granter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFee2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.gasLimit = reader.uint64();
              break;
            case 3:
              message.payer = reader.string();
              break;
            case 4:
              message.granter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFee2();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.gasLimit))
          obj.gasLimit = BigInt(object.gasLimit.toString());
        if ((0, helpers_1.isSet)(object.payer))
          obj.payer = String(object.payer);
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.gasLimit !== void 0 && (obj.gasLimit = (message.gasLimit || BigInt(0)).toString());
        message.payer !== void 0 && (obj.payer = message.payer);
        message.granter !== void 0 && (obj.granter = message.granter);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseFee2();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.gasLimit !== void 0 && object.gasLimit !== null) {
          message.gasLimit = BigInt(object.gasLimit.toString());
        }
        message.payer = object.payer ?? "";
        message.granter = object.granter ?? "";
        return message;
      }
    };
    function createBaseTip2() {
      return {
        amount: [],
        tipper: ""
      };
    }
    exports$1.Tip = {
      typeUrl: "/cosmos.tx.v1beta1.Tip",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.tipper !== "") {
          writer.uint32(18).string(message.tipper);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTip2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.tipper = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTip2();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.tipper))
          obj.tipper = String(object.tipper);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.tipper !== void 0 && (obj.tipper = message.tipper);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTip2();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.tipper = object.tipper ?? "";
        return message;
      }
    };
    function createBaseAuxSignerData() {
      return {
        address: "",
        signDoc: void 0,
        mode: 0,
        sig: new Uint8Array()
      };
    }
    exports$1.AuxSignerData = {
      typeUrl: "/cosmos.tx.v1beta1.AuxSignerData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.signDoc !== void 0) {
          exports$1.SignDocDirectAux.encode(message.signDoc, writer.uint32(18).fork()).ldelim();
        }
        if (message.mode !== 0) {
          writer.uint32(24).int32(message.mode);
        }
        if (message.sig.length !== 0) {
          writer.uint32(34).bytes(message.sig);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuxSignerData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.signDoc = exports$1.SignDocDirectAux.decode(reader, reader.uint32());
              break;
            case 3:
              message.mode = reader.int32();
              break;
            case 4:
              message.sig = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAuxSignerData();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.signDoc))
          obj.signDoc = exports$1.SignDocDirectAux.fromJSON(object.signDoc);
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        if ((0, helpers_1.isSet)(object.sig))
          obj.sig = (0, helpers_1.bytesFromBase64)(object.sig);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.signDoc !== void 0 && (obj.signDoc = message.signDoc ? exports$1.SignDocDirectAux.toJSON(message.signDoc) : void 0);
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        message.sig !== void 0 && (obj.sig = (0, helpers_1.base64FromBytes)(message.sig !== void 0 ? message.sig : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAuxSignerData();
        message.address = object.address ?? "";
        if (object.signDoc !== void 0 && object.signDoc !== null) {
          message.signDoc = exports$1.SignDocDirectAux.fromPartial(object.signDoc);
        }
        message.mode = object.mode ?? 0;
        message.sig = object.sig ?? new Uint8Array();
        return message;
      }
    };
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/decode.js
var require_decode = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/decode.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.decodeTxRaw = decodeTxRaw;
    var tx_1 = require_tx();
    function decodeTxRaw(tx) {
      const txRaw = tx_1.TxRaw.decode(tx);
      return {
        authInfo: tx_1.AuthInfo.decode(txRaw.authInfoBytes),
        body: tx_1.TxBody.decode(txRaw.bodyBytes),
        signatures: txRaw.signatures
      };
    }
  }
});

// ../../node_modules/@cosmjs/encoding/build/ascii.js
var require_ascii = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/ascii.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.toAscii = toAscii;
    exports$1.fromAscii = fromAscii;
    function toAscii(input) {
      const toNums = (str2) => str2.split("").map((x) => {
        const charCode = x.charCodeAt(0);
        if (charCode < 32 || charCode > 126) {
          throw new Error(`Cannot encode character that is out of printable ASCII range: ${charCode}`);
        }
        return charCode;
      });
      return Uint8Array.from(toNums(input));
    }
    function fromAscii(data2) {
      const fromNums = (listOfNumbers) => listOfNumbers.map((x) => {
        if (x < 32 || x > 126) {
          throw new Error(`Cannot decode character that is out of printable ASCII range: ${x}`);
        }
        return String.fromCharCode(x);
      });
      return fromNums(Array.from(data2)).join("");
    }
  }
});

// ../../node_modules/@cosmjs/encoding/build/base64.js
var require_base64 = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/base64.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.toBase64 = toBase64;
    exports$1.fromBase64 = fromBase64;
    var base64js = __importStar(require_base64_js());
    function toBase64(data2) {
      return base64js.fromByteArray(data2);
    }
    function fromBase64(base64String) {
      if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {
        throw new Error("Invalid base64 string format");
      }
      return base64js.toByteArray(base64String);
    }
  }
});

// ../../node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "../../node_modules/bech32/index.js"(exports$1, module) {
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z = 0; z < ALPHABET.length; z++) {
      x = ALPHABET.charAt(z);
      if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
      ALPHABET_MAP[x] = z;
    }
    var x;
    var z;
    function polymodStep(pre) {
      var b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i = 0; i < prefix.length; ++i) {
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (i = 0; i < prefix.length; ++i) {
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function encode(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT) throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string") throw new Error(chk);
      var result2 = prefix + "1";
      for (var i = 0; i < words.length; ++i) {
        var x2 = words[i];
        if (x2 >> 5 !== 0) throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x2;
        result2 += ALPHABET.charAt(x2);
      }
      for (i = 0; i < 6; ++i) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i = 0; i < 6; ++i) {
        var v = chk >> (5 - i) * 5 & 31;
        result2 += ALPHABET.charAt(v);
      }
      return result2;
    }
    function __decode(str2, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str2.length < 8) return str2 + " too short";
      if (str2.length > LIMIT) return "Exceeds length limit";
      var lowered = str2.toLowerCase();
      var uppered = str2.toUpperCase();
      if (str2 !== lowered && str2 !== uppered) return "Mixed-case string " + str2;
      str2 = lowered;
      var split = str2.lastIndexOf("1");
      if (split === -1) return "No separator character for " + str2;
      if (split === 0) return "Missing prefix for " + str2;
      var prefix = str2.slice(0, split);
      var wordChars = str2.slice(split + 1);
      if (wordChars.length < 6) return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string") return chk;
      var words = [];
      for (var i = 0; i < wordChars.length; ++i) {
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === void 0) return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i + 6 >= wordChars.length) continue;
        words.push(v);
      }
      if (chk !== 1) return "Invalid checksum for " + str2;
      return { prefix, words };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object") return res;
    }
    function decode(str2) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object") return res;
      throw new Error(res);
    }
    function convert(data2, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result2 = [];
      for (var i = 0; i < data2.length; ++i) {
        value = value << inBits | data2[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result2.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result2.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits) return "Excess padding";
        if (value << outBits - bits & maxV) return "Non-zero padding";
      }
      return result2;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res)) return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res)) return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res)) return res;
    }
    function fromWords(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res)) return res;
      throw new Error(res);
    }
    module.exports = {
      decodeUnsafe,
      decode,
      encode,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// ../../node_modules/@cosmjs/encoding/build/bech32.js
var require_bech322 = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/bech32.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.toBech32 = toBech32;
    exports$1.fromBech32 = fromBech32;
    exports$1.normalizeBech32 = normalizeBech32;
    var bech32 = __importStar(require_bech32());
    function toBech32(prefix, data2, limit) {
      const address = bech32.encode(prefix, bech32.toWords(data2), limit);
      return address;
    }
    function fromBech32(address, limit = Infinity) {
      const decodedAddress = bech32.decode(address, limit);
      return {
        prefix: decodedAddress.prefix,
        data: new Uint8Array(bech32.fromWords(decodedAddress.words))
      };
    }
    function normalizeBech32(address) {
      const { prefix, data: data2 } = fromBech32(address);
      return toBech32(prefix, data2);
    }
  }
});

// ../../node_modules/@cosmjs/encoding/build/hex.js
var require_hex = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/hex.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.toHex = toHex;
    exports$1.fromHex = fromHex;
    function toHex(data2) {
      let out = "";
      for (const byte of data2) {
        out += ("0" + byte.toString(16)).slice(-2);
      }
      return out;
    }
    function fromHex(hexstring) {
      if (hexstring.length % 2 !== 0) {
        throw new Error("hex string length must be a multiple of 2");
      }
      const out = new Uint8Array(hexstring.length / 2);
      for (let i = 0; i < out.length; i++) {
        const j = 2 * i;
        const hexByteAsString = hexstring.slice(j, j + 2);
        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
          throw new Error("hex string contains invalid characters");
        }
        out[i] = parseInt(hexByteAsString, 16);
      }
      return out;
    }
  }
});

// ../../node_modules/@cosmjs/encoding/build/rfc3339.js
var require_rfc3339 = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/rfc3339.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.fromRfc3339 = fromRfc3339;
    exports$1.toRfc3339 = toRfc3339;
    var rfc3339Matcher = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
    function padded(integer, length = 2) {
      return integer.toString().padStart(length, "0");
    }
    function fromRfc3339(str2) {
      const matches = rfc3339Matcher.exec(str2);
      if (!matches) {
        throw new Error("Date string is not in RFC3339 format");
      }
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      const hour = +matches[4];
      const minute = +matches[5];
      const second = +matches[6];
      const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1e3) : 0;
      let tzOffsetSign;
      let tzOffsetHours;
      let tzOffsetMinutes;
      if (matches[8] === "Z") {
        tzOffsetSign = 1;
        tzOffsetHours = 0;
        tzOffsetMinutes = 0;
      } else {
        tzOffsetSign = matches[8].substring(0, 1) === "-" ? -1 : 1;
        tzOffsetHours = +matches[8].substring(1, 3);
        tzOffsetMinutes = +matches[8].substring(4, 6);
      }
      const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60;
      const date = /* @__PURE__ */ new Date();
      date.setUTCFullYear(year, month - 1, day);
      date.setUTCHours(hour, minute, second, milliSeconds);
      return new Date(date.getTime() - tzOffset * 1e3);
    }
    function toRfc3339(date) {
      const year = date.getUTCFullYear();
      const month = padded(date.getUTCMonth() + 1);
      const day = padded(date.getUTCDate());
      const hour = padded(date.getUTCHours());
      const minute = padded(date.getUTCMinutes());
      const second = padded(date.getUTCSeconds());
      const ms = padded(date.getUTCMilliseconds(), 3);
      return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;
    }
  }
});

// ../../node_modules/@cosmjs/encoding/build/utf8.js
var require_utf82 = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/utf8.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.toUtf8 = toUtf8;
    exports$1.fromUtf8 = fromUtf8;
    function toUtf8(str2) {
      return new TextEncoder().encode(str2);
    }
    function fromUtf8(data2, lossy = false) {
      const fatal = !lossy;
      return new TextDecoder("utf-8", { fatal }).decode(data2);
    }
  }
});

// ../../node_modules/@cosmjs/encoding/build/index.js
var require_build2 = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.toUtf8 = exports$1.fromUtf8 = exports$1.toRfc3339 = exports$1.fromRfc3339 = exports$1.toHex = exports$1.fromHex = exports$1.toBech32 = exports$1.normalizeBech32 = exports$1.fromBech32 = exports$1.toBase64 = exports$1.fromBase64 = exports$1.toAscii = exports$1.fromAscii = void 0;
    var ascii_1 = require_ascii();
    Object.defineProperty(exports$1, "fromAscii", { enumerable: true, get: function() {
      return ascii_1.fromAscii;
    } });
    Object.defineProperty(exports$1, "toAscii", { enumerable: true, get: function() {
      return ascii_1.toAscii;
    } });
    var base64_1 = require_base64();
    Object.defineProperty(exports$1, "fromBase64", { enumerable: true, get: function() {
      return base64_1.fromBase64;
    } });
    Object.defineProperty(exports$1, "toBase64", { enumerable: true, get: function() {
      return base64_1.toBase64;
    } });
    var bech32_1 = require_bech322();
    Object.defineProperty(exports$1, "fromBech32", { enumerable: true, get: function() {
      return bech32_1.fromBech32;
    } });
    Object.defineProperty(exports$1, "normalizeBech32", { enumerable: true, get: function() {
      return bech32_1.normalizeBech32;
    } });
    Object.defineProperty(exports$1, "toBech32", { enumerable: true, get: function() {
      return bech32_1.toBech32;
    } });
    var hex_1 = require_hex();
    Object.defineProperty(exports$1, "fromHex", { enumerable: true, get: function() {
      return hex_1.fromHex;
    } });
    Object.defineProperty(exports$1, "toHex", { enumerable: true, get: function() {
      return hex_1.toHex;
    } });
    var rfc3339_1 = require_rfc3339();
    Object.defineProperty(exports$1, "fromRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.fromRfc3339;
    } });
    Object.defineProperty(exports$1, "toRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.toRfc3339;
    } });
    var utf8_1 = require_utf82();
    Object.defineProperty(exports$1, "fromUtf8", { enumerable: true, get: function() {
      return utf8_1.fromUtf8;
    } });
    Object.defineProperty(exports$1, "toUtf8", { enumerable: true, get: function() {
      return utf8_1.toUtf8;
    } });
  }
});

// ../../node_modules/@cosmjs/utils/build/arrays.js
var require_arrays = __commonJS({
  "../../node_modules/@cosmjs/utils/build/arrays.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.arrayContentEquals = arrayContentEquals;
    exports$1.arrayContentStartsWith = arrayContentStartsWith;
    function arrayContentEquals(a, b) {
      if (a.length !== b.length)
        return false;
      for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    function arrayContentStartsWith(a, b) {
      if (a.length < b.length)
        return false;
      for (let i = 0; i < b.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
  }
});

// ../../node_modules/@cosmjs/utils/build/assert.js
var require_assert = __commonJS({
  "../../node_modules/@cosmjs/utils/build/assert.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.assert = assert;
    exports$1.assertDefined = assertDefined;
    exports$1.assertDefinedAndNotNull = assertDefinedAndNotNull;
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg || "condition is not truthy");
      }
    }
    function assertDefined(value, msg) {
      if (value === void 0) {
        throw new Error(msg ?? "value is undefined");
      }
    }
    function assertDefinedAndNotNull(value, msg) {
      if (value === void 0 || value === null) {
        throw new Error(msg ?? "value is undefined or null");
      }
    }
  }
});

// ../../node_modules/@cosmjs/utils/build/sleep.js
var require_sleep = __commonJS({
  "../../node_modules/@cosmjs/utils/build/sleep.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.sleep = sleep;
    async function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  }
});

// ../../node_modules/@cosmjs/utils/build/typechecks.js
var require_typechecks = __commonJS({
  "../../node_modules/@cosmjs/utils/build/typechecks.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isNonNullObject = isNonNullObject;
    exports$1.isUint8Array = isUint8Array;
    exports$1.isDefined = isDefined;
    function isNonNullObject(data2) {
      return typeof data2 === "object" && data2 !== null;
    }
    function isUint8Array(data2) {
      if (!isNonNullObject(data2))
        return false;
      if (Object.prototype.toString.call(data2) !== "[object Uint8Array]")
        return false;
      if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined") {
        if (Buffer.isBuffer(data2))
          return false;
      }
      return true;
    }
    function isDefined(value) {
      return value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/utils/build/index.js
var require_build3 = __commonJS({
  "../../node_modules/@cosmjs/utils/build/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isUint8Array = exports$1.isNonNullObject = exports$1.isDefined = exports$1.sleep = exports$1.assertDefinedAndNotNull = exports$1.assertDefined = exports$1.assert = exports$1.arrayContentStartsWith = exports$1.arrayContentEquals = void 0;
    var arrays_1 = require_arrays();
    Object.defineProperty(exports$1, "arrayContentEquals", { enumerable: true, get: function() {
      return arrays_1.arrayContentEquals;
    } });
    Object.defineProperty(exports$1, "arrayContentStartsWith", { enumerable: true, get: function() {
      return arrays_1.arrayContentStartsWith;
    } });
    var assert_1 = require_assert();
    Object.defineProperty(exports$1, "assert", { enumerable: true, get: function() {
      return assert_1.assert;
    } });
    Object.defineProperty(exports$1, "assertDefined", { enumerable: true, get: function() {
      return assert_1.assertDefined;
    } });
    Object.defineProperty(exports$1, "assertDefinedAndNotNull", { enumerable: true, get: function() {
      return assert_1.assertDefinedAndNotNull;
    } });
    var sleep_1 = require_sleep();
    Object.defineProperty(exports$1, "sleep", { enumerable: true, get: function() {
      return sleep_1.sleep;
    } });
    var typechecks_1 = require_typechecks();
    Object.defineProperty(exports$1, "isDefined", { enumerable: true, get: function() {
      return typechecks_1.isDefined;
    } });
    Object.defineProperty(exports$1, "isNonNullObject", { enumerable: true, get: function() {
      return typechecks_1.isNonNullObject;
    } });
    Object.defineProperty(exports$1, "isUint8Array", { enumerable: true, get: function() {
      return typechecks_1.isUint8Array;
    } });
  }
});

// ../../node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS({
  "../../node_modules/@noble/hashes/cryptoNode.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.crypto = void 0;
    var nc = __require("crypto");
    exports$1.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;
  }
});

// ../../node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "../../node_modules/@noble/hashes/utils.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.wrapXOFConstructorWithOpts = exports$1.wrapConstructorWithOpts = exports$1.wrapConstructor = exports$1.Hash = exports$1.nextTick = exports$1.swap32IfBE = exports$1.byteSwapIfBE = exports$1.swap8IfBE = exports$1.isLE = void 0;
    exports$1.isBytes = isBytes;
    exports$1.anumber = anumber;
    exports$1.abytes = abytes;
    exports$1.ahash = ahash;
    exports$1.aexists = aexists;
    exports$1.aoutput = aoutput;
    exports$1.u8 = u8;
    exports$1.u32 = u32;
    exports$1.clean = clean;
    exports$1.createView = createView;
    exports$1.rotr = rotr;
    exports$1.rotl = rotl;
    exports$1.byteSwap = byteSwap;
    exports$1.byteSwap32 = byteSwap32;
    exports$1.bytesToHex = bytesToHex;
    exports$1.hexToBytes = hexToBytes;
    exports$1.asyncLoop = asyncLoop;
    exports$1.utf8ToBytes = utf8ToBytes;
    exports$1.bytesToUtf8 = bytesToUtf8;
    exports$1.toBytes = toBytes2;
    exports$1.kdfInputToBytes = kdfInputToBytes;
    exports$1.concatBytes = concatBytes;
    exports$1.checkOpts = checkOpts;
    exports$1.createHasher = createHasher;
    exports$1.createOptHasher = createOptHasher;
    exports$1.createXOFer = createXOFer;
    exports$1.randomBytes = randomBytes;
    var crypto_1 = require_cryptoNode();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance3, checkFinished = true) {
      if (instance3.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance3.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance3) {
      abytes(out);
      const min = instance3.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports$1.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports$1.swap8IfBE = exports$1.isLE ? (n) => n : (n) => byteSwap(n);
    exports$1.byteSwapIfBE = exports$1.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports$1.swap32IfBE = exports$1.isLE ? (u) => u : byteSwap32;
    var hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports$1.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports$1.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str2) {
      if (typeof str2 !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str2));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes2(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes(data2);
      abytes(data2);
      return data2;
    }
    function kdfInputToBytes(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes(data2);
      abytes(data2);
      return data2;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash = class {
    };
    exports$1.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports$1.wrapConstructor = createHasher;
    exports$1.wrapConstructorWithOpts = createOptHasher;
    exports$1.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// ../../node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "../../node_modules/@noble/hashes/hmac.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.hmac = exports$1.HMAC = void 0;
    var utils_ts_1 = require_utils();
    var HMAC = class extends utils_ts_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash2);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports$1.HMAC = HMAC;
    var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
    exports$1.hmac = hmac;
    exports$1.hmac.create = (hash2, key) => new HMAC(hash2, key);
  }
});

// ../../node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "../../node_modules/@noble/hashes/pbkdf2.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.pbkdf2 = pbkdf22;
    exports$1.pbkdf2Async = pbkdf2Async;
    var hmac_ts_1 = require_hmac();
    var utils_ts_1 = require_utils();
    function pbkdf2Init(hash2, _password, _salt, _opts) {
      (0, utils_ts_1.ahash)(hash2);
      const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      (0, utils_ts_1.anumber)(c);
      (0, utils_ts_1.anumber)(dkLen);
      (0, utils_ts_1.anumber)(asyncTick);
      if (c < 1)
        throw new Error("iterations (c) should be >= 1");
      const password = (0, utils_ts_1.kdfInputToBytes)(_password);
      const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_ts_1.hmac.create(hash2, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      (0, utils_ts_1.clean)(u);
      return DK;
    }
    function pbkdf22(hash2, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    async function pbkdf2Async(hash2, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
  }
});

// ../../node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "../../node_modules/@noble/hashes/_md.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SHA512_IV = exports$1.SHA384_IV = exports$1.SHA224_IV = exports$1.SHA256_IV = exports$1.HashMD = void 0;
    exports$1.setBigUint64 = setBigUint64;
    exports$1.Chi = Chi;
    exports$1.Maj = Maj;
    var utils_ts_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function Chi(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    var HashMD = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data2) {
        (0, utils_ts_1.aexists)(this);
        data2 = (0, utils_ts_1.toBytes)(data2);
        (0, utils_ts_1.abytes)(data2);
        const { view, buffer, blockLen } = this;
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_ts_1.createView)(data2);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data2.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data2.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports$1.HashMD = HashMD;
    exports$1.SHA256_IV = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    exports$1.SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    exports$1.SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    exports$1.SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// ../../node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "../../node_modules/@noble/hashes/_u64.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.toBig = exports$1.shrSL = exports$1.shrSH = exports$1.rotrSL = exports$1.rotrSH = exports$1.rotrBL = exports$1.rotrBH = exports$1.rotr32L = exports$1.rotr32H = exports$1.rotlSL = exports$1.rotlSH = exports$1.rotlBL = exports$1.rotlBH = exports$1.add5L = exports$1.add5H = exports$1.add4L = exports$1.add4H = exports$1.add3L = exports$1.add3H = void 0;
    exports$1.add = add2;
    exports$1.fromBig = fromBig;
    exports$1.split = split;
    var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports$1.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports$1.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports$1.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports$1.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports$1.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports$1.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports$1.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports$1.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports$1.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports$1.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports$1.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports$1.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports$1.rotlBL = rotlBL;
    function add2(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports$1.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports$1.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports$1.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports$1.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports$1.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports$1.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add: add2,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports$1.default = u64;
  }
});

// ../../node_modules/@noble/hashes/sha2.js
var require_sha2 = __commonJS({
  "../../node_modules/@noble/hashes/sha2.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.sha512_224 = exports$1.sha512_256 = exports$1.sha384 = exports$1.sha512 = exports$1.sha224 = exports$1.sha256 = exports$1.SHA512_256 = exports$1.SHA512_224 = exports$1.SHA384 = exports$1.SHA512 = exports$1.SHA224 = exports$1.SHA256 = void 0;
    var _md_ts_1 = require_md();
    var u64 = require_u64();
    var utils_ts_1 = require_utils();
    var SHA256_K = /* @__PURE__ */ Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA256 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports$1.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
      }
    };
    exports$1.SHA224 = SHA224;
    var K512 = /* @__PURE__ */ (() => u64.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
    var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
    var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    var SHA512 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
          const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
          const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
          const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
          const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
          const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64.add3L(T1l, sigma0l, MAJl);
          Ah = u64.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports$1.SHA512 = SHA512;
    var SHA384 = class extends SHA512 {
      constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
      }
    };
    exports$1.SHA384 = SHA384;
    var T224_IV = /* @__PURE__ */ Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    var T256_IV = /* @__PURE__ */ Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    exports$1.SHA512_224 = SHA512_224;
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    exports$1.SHA512_256 = SHA512_256;
    exports$1.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
    exports$1.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
    exports$1.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
    exports$1.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
    exports$1.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
    exports$1.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  }
});

// ../../node_modules/@cosmjs/crypto/build/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/pbkdf2.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getSubtle = getSubtle;
    exports$1.pbkdf2Sha512Subtle = pbkdf2Sha512Subtle;
    exports$1.pbkdf2Sha512Noble = pbkdf2Sha512Noble;
    exports$1.pbkdf2Sha512 = pbkdf2Sha512;
    var utils_1 = require_build3();
    var pbkdf2_1 = require_pbkdf2();
    var sha2_1 = require_sha2();
    async function getSubtle() {
      return globalThis?.crypto?.subtle;
    }
    async function pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen) {
      (0, utils_1.assert)(subtle, "Argument subtle is falsy");
      (0, utils_1.assert)(typeof subtle === "object", "Argument subtle is not of type object");
      (0, utils_1.assert)(typeof subtle.importKey === "function", "subtle.importKey is not a function");
      (0, utils_1.assert)(typeof subtle.deriveBits === "function", "subtle.deriveBits is not a function");
      return subtle.importKey("raw", secret, { name: "PBKDF2" }, false, ["deriveBits"]).then((key) => subtle.deriveBits({
        name: "PBKDF2",
        salt,
        iterations,
        hash: { name: "SHA-512" }
      }, key, keylen * 8).then((buffer) => new Uint8Array(buffer)));
    }
    async function pbkdf2Sha512Noble(secret, salt, iterations, keylen) {
      return (0, pbkdf2_1.pbkdf2Async)(sha2_1.sha512, secret, salt, { c: iterations, dkLen: keylen });
    }
    async function pbkdf2Sha512(secret, salt, iterations, keylen) {
      const subtle = await getSubtle();
      if (subtle) {
        return pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen);
      } else {
        return pbkdf2Sha512Noble(secret, salt, iterations, keylen);
      }
    }
  }
});

// ../../node_modules/@cosmjs/crypto/build/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/utils.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.toRealUint8Array = toRealUint8Array;
    function toRealUint8Array(data2) {
      if (data2 instanceof Uint8Array)
        return data2;
      else
        return Uint8Array.from(data2);
    }
  }
});

// ../../node_modules/@cosmjs/crypto/build/sha.js
var require_sha = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/sha.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Sha512 = exports$1.Sha256 = void 0;
    exports$1.sha256 = sha2562;
    exports$1.sha512 = sha5122;
    var sha2_1 = require_sha2();
    var utils_1 = require_utils2();
    var Sha256 = class {
      blockSize = 512 / 8;
      impl = sha2_1.sha256.create();
      constructor(firstData) {
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports$1.Sha256 = Sha256;
    function sha2562(data2) {
      return new Sha256(data2).digest();
    }
    var Sha512 = class {
      blockSize = 1024 / 8;
      impl = sha2_1.sha512.create();
      constructor(firstData) {
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports$1.Sha512 = Sha512;
    function sha5122(data2) {
      return new Sha512(data2).digest();
    }
  }
});

// ../../node_modules/@cosmjs/crypto/build/bip39.js
var require_bip39 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/bip39.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Bip39 = exports$1.EnglishMnemonic = void 0;
    exports$1.entropyToMnemonic = entropyToMnemonic;
    exports$1.mnemonicToEntropy = mnemonicToEntropy;
    var encoding_1 = require_build2();
    var pbkdf2_1 = require_pbkdf22();
    var sha_1 = require_sha();
    var wordlist = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    function bytesToBitstring(bytes) {
      return Array.from(bytes).map((byte) => byte.toString(2).padStart(8, "0")).join("");
    }
    function deriveChecksumBits(entropy) {
      const entropyLengthBits = entropy.length * 8;
      const checksumLengthBits = entropyLengthBits / 32;
      const hash2 = (0, sha_1.sha256)(entropy);
      return bytesToBitstring(hash2).slice(0, checksumLengthBits);
    }
    function bitstringToByte(bin) {
      return parseInt(bin, 2);
    }
    var allowedEntropyLengths = [16, 20, 24, 28, 32];
    var allowedWordLengths = [12, 15, 18, 21, 24];
    function entropyToMnemonic(entropy) {
      if (allowedEntropyLengths.indexOf(entropy.length) === -1) {
        throw new Error("invalid input length");
      }
      const entropyBits = bytesToBitstring(entropy);
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{11})/g);
      const words = chunks.map((binary2) => {
        const index = bitstringToByte(binary2);
        return wordlist[index];
      });
      return words.join(" ");
    }
    var invalidNumberOfWords = "Invalid number of words";
    var wordNotInWordlist = "Found word that is not in the wordlist";
    var invalidEntropy = "Invalid entropy";
    var invalidChecksum = "Invalid mnemonic checksum";
    function normalize(str2) {
      return str2.normalize("NFKD");
    }
    function mnemonicToEntropy(mnemonic) {
      const words = normalize(mnemonic).split(" ");
      if (!allowedWordLengths.includes(words.length)) {
        throw new Error(invalidNumberOfWords);
      }
      const bits = words.map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
          throw new Error(wordNotInWordlist);
        }
        return index.toString(2).padStart(11, "0");
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(bitstringToByte);
      if (entropyBytes.length < 16 || entropyBytes.length > 32 || entropyBytes.length % 4 !== 0) {
        throw new Error(invalidEntropy);
      }
      const entropy = Uint8Array.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(invalidChecksum);
      }
      return entropy;
    }
    var EnglishMnemonic = class _EnglishMnemonic {
      static wordlist = wordlist;
      // list of space separated lower case words (1 or more)
      static mnemonicMatcher = /^[a-z]+( [a-z]+)*$/;
      data;
      constructor(mnemonic) {
        if (!_EnglishMnemonic.mnemonicMatcher.test(mnemonic)) {
          throw new Error("Invalid mnemonic format");
        }
        const words = mnemonic.split(" ");
        const allowedWordsLengths = [12, 15, 18, 21, 24];
        if (allowedWordsLengths.indexOf(words.length) === -1) {
          throw new Error(`Invalid word count in mnemonic (allowed: ${allowedWordsLengths} got: ${words.length})`);
        }
        for (const word of words) {
          if (_EnglishMnemonic.wordlist.indexOf(word) === -1) {
            throw new Error("Mnemonic contains invalid word");
          }
        }
        mnemonicToEntropy(mnemonic);
        this.data = mnemonic;
      }
      toString() {
        return this.data;
      }
    };
    exports$1.EnglishMnemonic = EnglishMnemonic;
    var Bip39 = class {
      /**
       * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
       *
       * | Entropy            | Words |
       * |--------------------|-------|
       * | 128 bit (16 bytes) |    12 |
       * | 160 bit (20 bytes) |    15 |
       * | 192 bit (24 bytes) |    18 |
       * | 224 bit (28 bytes) |    21 |
       * | 256 bit (32 bytes) |    24 |
       *
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
       * @param entropy The entropy to be encoded. This must be cryptographically secure.
       */
      static encode(entropy) {
        return new EnglishMnemonic(entropyToMnemonic(entropy));
      }
      static decode(mnemonic) {
        return mnemonicToEntropy(mnemonic.toString());
      }
      static async mnemonicToSeed(mnemonic, password) {
        const mnemonicBytes = (0, encoding_1.toUtf8)(normalize(mnemonic.toString()));
        const salt = "mnemonic" + (password ? normalize(password) : "");
        const saltBytes = (0, encoding_1.toUtf8)(salt);
        return (0, pbkdf2_1.pbkdf2Sha512)(mnemonicBytes, saltBytes, 2048, 64);
      }
    };
    exports$1.Bip39 = Bip39;
  }
});

// ../../node_modules/@cosmjs/crypto/build/hmac.js
var require_hmac2 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/hmac.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Hmac = void 0;
    var Hmac = class {
      blockSize;
      messageHasher;
      oKeyPad;
      iKeyPad;
      hash;
      constructor(hashFunctionConstructor, originalKey) {
        const blockSize = new hashFunctionConstructor().blockSize;
        this.hash = (data2) => new hashFunctionConstructor().update(data2).digest();
        let key = originalKey;
        if (key.length > blockSize) {
          key = this.hash(key);
        }
        if (key.length < blockSize) {
          const zeroPadding = new Uint8Array(blockSize - key.length);
          key = new Uint8Array([...key, ...zeroPadding]);
        }
        this.oKeyPad = key.map((keyByte) => keyByte ^ 92);
        this.iKeyPad = key.map((keyByte) => keyByte ^ 54);
        this.messageHasher = new hashFunctionConstructor();
        this.blockSize = blockSize;
        this.update(this.iKeyPad);
      }
      update(data2) {
        this.messageHasher.update(data2);
        return this;
      }
      digest() {
        const innerHash = this.messageHasher.digest();
        return this.hash(new Uint8Array([...this.oKeyPad, ...innerHash]));
      }
    };
    exports$1.Hmac = Hmac;
  }
});

// ../../node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "../../node_modules/@noble/hashes/sha3.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.shake256 = exports$1.shake128 = exports$1.keccak_512 = exports$1.keccak_384 = exports$1.keccak_256 = exports$1.keccak_224 = exports$1.sha3_512 = exports$1.sha3_384 = exports$1.sha3_256 = exports$1.sha3_224 = exports$1.Keccak = void 0;
    exports$1.keccakP = keccakP;
    var _u64_ts_1 = require_u64();
    var utils_ts_1 = require_utils();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
    var SHA3_IOTA_H = IOTAS[0];
    var SHA3_IOTA_L = IOTAS[1];
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      (0, utils_ts_1.clean)(B);
    }
    var Keccak = class _Keccak extends utils_ts_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        (0, utils_ts_1.anumber)(outputLen);
        if (!(0 < blockLen && blockLen < 200))
          throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data2) {
        (0, utils_ts_1.aexists)(this);
        data2 = (0, utils_ts_1.toBytes)(data2);
        (0, utils_ts_1.abytes)(data2);
        const { blockLen, state } = this;
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data2[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports$1.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
    exports$1.sha3_224 = (() => gen(6, 144, 224 / 8))();
    exports$1.sha3_256 = (() => gen(6, 136, 256 / 8))();
    exports$1.sha3_384 = (() => gen(6, 104, 384 / 8))();
    exports$1.sha3_512 = (() => gen(6, 72, 512 / 8))();
    exports$1.keccak_224 = (() => gen(1, 144, 224 / 8))();
    exports$1.keccak_256 = (() => gen(1, 136, 256 / 8))();
    exports$1.keccak_384 = (() => gen(1, 104, 384 / 8))();
    exports$1.keccak_512 = (() => gen(1, 72, 512 / 8))();
    var genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports$1.shake128 = (() => genShake(31, 168, 128 / 8))();
    exports$1.shake256 = (() => genShake(31, 136, 256 / 8))();
  }
});

// ../../node_modules/@cosmjs/crypto/build/keccak.js
var require_keccak = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/keccak.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Keccak256 = void 0;
    exports$1.keccak256 = keccak256;
    var sha3_1 = require_sha3();
    var utils_1 = require_utils2();
    var Keccak256 = class {
      blockSize = 512 / 8;
      impl = sha3_1.keccak_256.create();
      constructor(firstData) {
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports$1.Keccak256 = Keccak256;
    function keccak256(data2) {
      return new Keccak256(data2).digest();
    }
  }
});

// ../../node_modules/@noble/ciphers/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/@noble/ciphers/utils.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.wrapCipher = exports$1.Hash = exports$1.nextTick = exports$1.isLE = void 0;
    exports$1.isBytes = isBytes;
    exports$1.abool = abool;
    exports$1.anumber = anumber;
    exports$1.abytes = abytes;
    exports$1.ahash = ahash;
    exports$1.aexists = aexists;
    exports$1.aoutput = aoutput;
    exports$1.u8 = u8;
    exports$1.u32 = u32;
    exports$1.clean = clean;
    exports$1.createView = createView;
    exports$1.bytesToHex = bytesToHex;
    exports$1.hexToBytes = hexToBytes;
    exports$1.hexToNumber = hexToNumber;
    exports$1.bytesToNumberBE = bytesToNumberBE;
    exports$1.numberToBytesBE = numberToBytesBE;
    exports$1.utf8ToBytes = utf8ToBytes;
    exports$1.bytesToUtf8 = bytesToUtf8;
    exports$1.toBytes = toBytes2;
    exports$1.overlapBytes = overlapBytes;
    exports$1.complexOverlapBytes = complexOverlapBytes;
    exports$1.concatBytes = concatBytes;
    exports$1.checkOpts = checkOpts;
    exports$1.equalBytes = equalBytes;
    exports$1.getOutput = getOutput;
    exports$1.setBigUint64 = setBigUint64;
    exports$1.u64Lengths = u64Lengths;
    exports$1.isAligned32 = isAligned32;
    exports$1.copyBytes = copyBytes;
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abool(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance3, checkFinished = true) {
      if (instance3.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance3.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance3) {
      abytes(out);
      const min = instance3.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    exports$1.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    var hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : "0x" + hex);
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    var nextTick = async () => {
    };
    exports$1.nextTick = nextTick;
    function utf8ToBytes(str2) {
      if (typeof str2 !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str2));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes2(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes(data2);
      else if (isBytes(data2))
        data2 = copyBytes(data2);
      else
        throw new Error("Uint8Array expected, got " + typeof data2);
      return data2;
    }
    function overlapBytes(a, b) {
      return a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
      a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
      b.byteOffset < a.byteOffset + a.byteLength;
    }
    function complexOverlapBytes(input, output) {
      if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
        throw new Error("complex overlap of input and output is not supported");
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts == null || typeof opts !== "object")
        throw new Error("options must be defined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    var Hash = class {
    };
    exports$1.Hash = Hash;
    var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
      function wrappedCipher(key, ...args) {
        abytes(key);
        if (!exports$1.isLE)
          throw new Error("Non little-endian hardware is not yet supported");
        if (params.nonceLength !== void 0) {
          const nonce = args[0];
          if (!nonce)
            throw new Error("nonce / iv required");
          if (params.varSizeNonce)
            abytes(nonce);
          else
            abytes(nonce, params.nonceLength);
        }
        const tagl = params.tagLength;
        if (tagl && args[1] !== void 0) {
          abytes(args[1]);
        }
        const cipher = constructor(key, ...args);
        const checkOutput = (fnLength, output) => {
          if (output !== void 0) {
            if (fnLength !== 2)
              throw new Error("cipher output not supported");
            abytes(output);
          }
        };
        let called = false;
        const wrCipher = {
          encrypt(data2, output) {
            if (called)
              throw new Error("cannot encrypt() twice with same key + nonce");
            called = true;
            abytes(data2);
            checkOutput(cipher.encrypt.length, output);
            return cipher.encrypt(data2, output);
          },
          decrypt(data2, output) {
            abytes(data2);
            if (tagl && data2.length < tagl)
              throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
            checkOutput(cipher.decrypt.length, output);
            return cipher.decrypt(data2, output);
          }
        };
        return wrCipher;
      }
      Object.assign(wrappedCipher, params);
      return wrappedCipher;
    };
    exports$1.wrapCipher = wrapCipher;
    function getOutput(expectedLength, out, onlyAligned = true) {
      if (out === void 0)
        return new Uint8Array(expectedLength);
      if (out.length !== expectedLength)
        throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
      if (onlyAligned && !isAligned32(out))
        throw new Error("invalid output, must be aligned");
      return out;
    }
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function u64Lengths(dataLength, aadLength, isLE) {
      abool(isLE);
      const num = new Uint8Array(16);
      const view = createView(num);
      setBigUint64(view, 0, BigInt(aadLength), isLE);
      setBigUint64(view, 8, BigInt(dataLength), isLE);
      return num;
    }
    function isAligned32(bytes) {
      return bytes.byteOffset % 4 === 0;
    }
    function copyBytes(bytes) {
      return Uint8Array.from(bytes);
    }
  }
});

// ../../node_modules/@noble/ciphers/_arx.js
var require_arx = __commonJS({
  "../../node_modules/@noble/ciphers/_arx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.rotl = rotl;
    exports$1.createCipher = createCipher;
    var utils_ts_1 = require_utils3();
    var _utf8ToBytes = (str2) => Uint8Array.from(str2.split("").map((c) => c.charCodeAt(0)));
    var sigma16 = _utf8ToBytes("expand 16-byte k");
    var sigma32 = _utf8ToBytes("expand 32-byte k");
    var sigma16_32 = (0, utils_ts_1.u32)(sigma16);
    var sigma32_32 = (0, utils_ts_1.u32)(sigma32);
    function rotl(a, b) {
      return a << b | a >>> 32 - b;
    }
    function isAligned32(b) {
      return b.byteOffset % 4 === 0;
    }
    var BLOCK_LEN = 64;
    var BLOCK_LEN32 = 16;
    var MAX_COUNTER = 2 ** 32 - 1;
    var U32_EMPTY = new Uint32Array();
    function runCipher(core2, sigma, key, nonce, data2, output, counter, rounds) {
      const len = data2.length;
      const block = new Uint8Array(BLOCK_LEN);
      const b32 = (0, utils_ts_1.u32)(block);
      const isAligned = isAligned32(data2) && isAligned32(output);
      const d32 = isAligned ? (0, utils_ts_1.u32)(data2) : U32_EMPTY;
      const o32 = isAligned ? (0, utils_ts_1.u32)(output) : U32_EMPTY;
      for (let pos = 0; pos < len; counter++) {
        core2(sigma, key, nonce, b32, counter, rounds);
        if (counter >= MAX_COUNTER)
          throw new Error("arx: counter overflow");
        const take = Math.min(BLOCK_LEN, len - pos);
        if (isAligned && take === BLOCK_LEN) {
          const pos32 = pos / 4;
          if (pos % 4 !== 0)
            throw new Error("arx: invalid block position");
          for (let j = 0, posj; j < BLOCK_LEN32; j++) {
            posj = pos32 + j;
            o32[posj] = d32[posj] ^ b32[j];
          }
          pos += BLOCK_LEN;
          continue;
        }
        for (let j = 0, posj; j < take; j++) {
          posj = pos + j;
          output[posj] = data2[posj] ^ block[j];
        }
        pos += take;
      }
    }
    function createCipher(core2, opts) {
      const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0, utils_ts_1.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
      if (typeof core2 !== "function")
        throw new Error("core must be a function");
      (0, utils_ts_1.anumber)(counterLength);
      (0, utils_ts_1.anumber)(rounds);
      (0, utils_ts_1.abool)(counterRight);
      (0, utils_ts_1.abool)(allowShortKeys);
      return (key, nonce, data2, output, counter = 0) => {
        (0, utils_ts_1.abytes)(key);
        (0, utils_ts_1.abytes)(nonce);
        (0, utils_ts_1.abytes)(data2);
        const len = data2.length;
        if (output === void 0)
          output = new Uint8Array(len);
        (0, utils_ts_1.abytes)(output);
        (0, utils_ts_1.anumber)(counter);
        if (counter < 0 || counter >= MAX_COUNTER)
          throw new Error("arx: counter overflow");
        if (output.length < len)
          throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
        const toClean = [];
        let l = key.length;
        let k;
        let sigma;
        if (l === 32) {
          toClean.push(k = (0, utils_ts_1.copyBytes)(key));
          sigma = sigma32_32;
        } else if (l === 16 && allowShortKeys) {
          k = new Uint8Array(32);
          k.set(key);
          k.set(key, 16);
          sigma = sigma16_32;
          toClean.push(k);
        } else {
          throw new Error(`arx: invalid 32-byte key, got length=${l}`);
        }
        if (!isAligned32(nonce))
          toClean.push(nonce = (0, utils_ts_1.copyBytes)(nonce));
        const k32 = (0, utils_ts_1.u32)(k);
        if (extendNonceFn) {
          if (nonce.length !== 24)
            throw new Error(`arx: extended nonce must be 24 bytes`);
          extendNonceFn(sigma, k32, (0, utils_ts_1.u32)(nonce.subarray(0, 16)), k32);
          nonce = nonce.subarray(16);
        }
        const nonceNcLen = 16 - counterLength;
        if (nonceNcLen !== nonce.length)
          throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
        if (nonceNcLen !== 12) {
          const nc = new Uint8Array(12);
          nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
          nonce = nc;
          toClean.push(nonce);
        }
        const n32 = (0, utils_ts_1.u32)(nonce);
        runCipher(core2, sigma, k32, n32, data2, output, counter, rounds);
        (0, utils_ts_1.clean)(...toClean);
        return output;
      };
    }
  }
});

// ../../node_modules/@noble/ciphers/_poly1305.js
var require_poly1305 = __commonJS({
  "../../node_modules/@noble/ciphers/_poly1305.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.poly1305 = void 0;
    exports$1.wrapConstructorWithKey = wrapConstructorWithKey;
    var utils_ts_1 = require_utils3();
    var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
    var Poly1305 = class {
      constructor(key) {
        this.blockLen = 16;
        this.outputLen = 16;
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.pos = 0;
        this.finished = false;
        key = (0, utils_ts_1.toBytes)(key);
        (0, utils_ts_1.abytes)(key, 32);
        const t0 = u8to16(key, 0);
        const t1 = u8to16(key, 2);
        const t2 = u8to16(key, 4);
        const t3 = u8to16(key, 6);
        const t4 = u8to16(key, 8);
        const t5 = u8to16(key, 10);
        const t6 = u8to16(key, 12);
        const t7 = u8to16(key, 14);
        this.r[0] = t0 & 8191;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        for (let i = 0; i < 8; i++)
          this.pad[i] = u8to16(key, 16 + 2 * i);
      }
      process(data2, offset, isLast = false) {
        const hibit = isLast ? 0 : 1 << 11;
        const { h, r } = this;
        const r0 = r[0];
        const r1 = r[1];
        const r2 = r[2];
        const r3 = r[3];
        const r4 = r[4];
        const r5 = r[5];
        const r6 = r[6];
        const r7 = r[7];
        const r8 = r[8];
        const r9 = r[9];
        const t0 = u8to16(data2, offset + 0);
        const t1 = u8to16(data2, offset + 2);
        const t2 = u8to16(data2, offset + 4);
        const t3 = u8to16(data2, offset + 6);
        const t4 = u8to16(data2, offset + 8);
        const t5 = u8to16(data2, offset + 10);
        const t6 = u8to16(data2, offset + 12);
        const t7 = u8to16(data2, offset + 14);
        let h0 = h[0] + (t0 & 8191);
        let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
        let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
        let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
        let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
        let h5 = h[5] + (t4 >>> 1 & 8191);
        let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
        let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
        let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
        let h9 = h[9] + (t7 >>> 5 | hibit);
        let c = 0;
        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h[0] = d0;
        h[1] = d1;
        h[2] = d2;
        h[3] = d3;
        h[4] = d4;
        h[5] = d5;
        h[6] = d6;
        h[7] = d7;
        h[8] = d8;
        h[9] = d9;
      }
      finalize() {
        const { h, pad } = this;
        const g = new Uint16Array(10);
        let c = h[1] >>> 13;
        h[1] &= 8191;
        for (let i = 2; i < 10; i++) {
          h[i] += c;
          c = h[i] >>> 13;
          h[i] &= 8191;
        }
        h[0] += c * 5;
        c = h[0] >>> 13;
        h[0] &= 8191;
        h[1] += c;
        c = h[1] >>> 13;
        h[1] &= 8191;
        h[2] += c;
        g[0] = h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (let i = 1; i < 10; i++) {
          g[i] = h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        let mask = (c ^ 1) - 1;
        for (let i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (let i = 0; i < 10; i++)
          h[i] = h[i] & mask | g[i];
        h[0] = (h[0] | h[1] << 13) & 65535;
        h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
        h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
        h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
        h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
        h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
        h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
        h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
        let f = h[0] + pad[0];
        h[0] = f & 65535;
        for (let i = 1; i < 8; i++) {
          f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
          h[i] = f & 65535;
        }
        (0, utils_ts_1.clean)(g);
      }
      update(data2) {
        (0, utils_ts_1.aexists)(this);
        data2 = (0, utils_ts_1.toBytes)(data2);
        (0, utils_ts_1.abytes)(data2);
        const { buffer, blockLen } = this;
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(data2, pos);
            continue;
          }
          buffer.set(data2.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(buffer, 0, false);
            this.pos = 0;
          }
        }
        return this;
      }
      destroy() {
        (0, utils_ts_1.clean)(this.h, this.r, this.buffer, this.pad);
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, h } = this;
        let { pos } = this;
        if (pos) {
          buffer[pos++] = 1;
          for (; pos < 16; pos++)
            buffer[pos] = 0;
          this.process(buffer, 0, true);
        }
        this.finalize();
        let opos = 0;
        for (let i = 0; i < 8; i++) {
          out[opos++] = h[i] >>> 0;
          out[opos++] = h[i] >>> 8;
        }
        return out;
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
    };
    function wrapConstructorWithKey(hashCons) {
      const hashC = (msg, key) => hashCons(key).update((0, utils_ts_1.toBytes)(msg)).digest();
      const tmp = hashCons(new Uint8Array(32));
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (key) => hashCons(key);
      return hashC;
    }
    exports$1.poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));
  }
});

// ../../node_modules/@noble/ciphers/chacha.js
var require_chacha = __commonJS({
  "../../node_modules/@noble/ciphers/chacha.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.xchacha20poly1305 = exports$1.chacha20poly1305 = exports$1._poly1305_aead = exports$1.chacha12 = exports$1.chacha8 = exports$1.xchacha20 = exports$1.chacha20 = exports$1.chacha20orig = void 0;
    exports$1.hchacha = hchacha;
    var _arx_ts_1 = require_arx();
    var _poly1305_ts_1 = require_poly1305();
    var utils_ts_1 = require_utils3();
    function chachaCore(s, k, n, out, cnt, rounds = 20) {
      let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
      let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
      for (let r = 0; r < rounds; r += 2) {
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 7);
      }
      let oi = 0;
      out[oi++] = y00 + x00 | 0;
      out[oi++] = y01 + x01 | 0;
      out[oi++] = y02 + x02 | 0;
      out[oi++] = y03 + x03 | 0;
      out[oi++] = y04 + x04 | 0;
      out[oi++] = y05 + x05 | 0;
      out[oi++] = y06 + x06 | 0;
      out[oi++] = y07 + x07 | 0;
      out[oi++] = y08 + x08 | 0;
      out[oi++] = y09 + x09 | 0;
      out[oi++] = y10 + x10 | 0;
      out[oi++] = y11 + x11 | 0;
      out[oi++] = y12 + x12 | 0;
      out[oi++] = y13 + x13 | 0;
      out[oi++] = y14 + x14 | 0;
      out[oi++] = y15 + x15 | 0;
    }
    function hchacha(s, k, i, o32) {
      let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
      for (let r = 0; r < 20; r += 2) {
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 7);
      }
      let oi = 0;
      o32[oi++] = x00;
      o32[oi++] = x01;
      o32[oi++] = x02;
      o32[oi++] = x03;
      o32[oi++] = x12;
      o32[oi++] = x13;
      o32[oi++] = x14;
      o32[oi++] = x15;
    }
    exports$1.chacha20orig = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 8,
      allowShortKeys: true
    });
    exports$1.chacha20 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 4,
      allowShortKeys: false
    });
    exports$1.xchacha20 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 8,
      extendNonceFn: hchacha,
      allowShortKeys: false
    });
    exports$1.chacha8 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 4,
      rounds: 8
    });
    exports$1.chacha12 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 4,
      rounds: 12
    });
    var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
    var updatePadded = (h, msg) => {
      h.update(msg);
      const left = msg.length % 16;
      if (left)
        h.update(ZEROS16.subarray(left));
    };
    var ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
    function computeTag(fn, key, nonce, data2, AAD) {
      const authKey = fn(key, nonce, ZEROS32);
      const h = _poly1305_ts_1.poly1305.create(authKey);
      if (AAD)
        updatePadded(h, AAD);
      updatePadded(h, data2);
      const num = (0, utils_ts_1.u64Lengths)(data2.length, AAD ? AAD.length : 0, true);
      h.update(num);
      const res = h.digest();
      (0, utils_ts_1.clean)(authKey, num);
      return res;
    }
    var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
      const tagLength = 16;
      return {
        encrypt(plaintext, output) {
          const plength = plaintext.length;
          output = (0, utils_ts_1.getOutput)(plength + tagLength, output, false);
          output.set(plaintext);
          const oPlain = output.subarray(0, -tagLength);
          xorStream(key, nonce, oPlain, oPlain, 1);
          const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
          output.set(tag, plength);
          (0, utils_ts_1.clean)(tag);
          return output;
        },
        decrypt(ciphertext, output) {
          output = (0, utils_ts_1.getOutput)(ciphertext.length - tagLength, output, false);
          const data2 = ciphertext.subarray(0, -tagLength);
          const passedTag = ciphertext.subarray(-tagLength);
          const tag = computeTag(xorStream, key, nonce, data2, AAD);
          if (!(0, utils_ts_1.equalBytes)(passedTag, tag))
            throw new Error("invalid tag");
          output.set(ciphertext.subarray(0, -tagLength));
          xorStream(key, nonce, output, output, 1);
          (0, utils_ts_1.clean)(tag);
          return output;
        }
      };
    };
    exports$1._poly1305_aead = _poly1305_aead;
    exports$1.chacha20poly1305 = (0, utils_ts_1.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, exports$1._poly1305_aead)(exports$1.chacha20));
    exports$1.xchacha20poly1305 = (0, utils_ts_1.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, exports$1._poly1305_aead)(exports$1.xchacha20));
  }
});

// ../../node_modules/@noble/curves/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/@noble/curves/utils.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.notImplemented = exports$1.bitMask = exports$1.utf8ToBytes = exports$1.randomBytes = exports$1.isBytes = exports$1.hexToBytes = exports$1.concatBytes = exports$1.bytesToUtf8 = exports$1.bytesToHex = exports$1.anumber = exports$1.abytes = void 0;
    exports$1.abool = abool;
    exports$1._abool2 = _abool2;
    exports$1._abytes2 = _abytes2;
    exports$1.numberToHexUnpadded = numberToHexUnpadded;
    exports$1.hexToNumber = hexToNumber;
    exports$1.bytesToNumberBE = bytesToNumberBE;
    exports$1.bytesToNumberLE = bytesToNumberLE;
    exports$1.numberToBytesBE = numberToBytesBE;
    exports$1.numberToBytesLE = numberToBytesLE;
    exports$1.numberToVarBytesBE = numberToVarBytesBE;
    exports$1.ensureBytes = ensureBytes;
    exports$1.equalBytes = equalBytes;
    exports$1.copyBytes = copyBytes;
    exports$1.asciiToBytes = asciiToBytes;
    exports$1.inRange = inRange;
    exports$1.aInRange = aInRange;
    exports$1.bitLen = bitLen;
    exports$1.bitGet = bitGet;
    exports$1.bitSet = bitSet;
    exports$1.createHmacDrbg = createHmacDrbg;
    exports$1.validateObject = validateObject;
    exports$1.isHash = isHash;
    exports$1._validateObject = _validateObject;
    exports$1.memoized = memoized;
    var utils_js_1 = require_utils();
    var utils_js_2 = require_utils();
    Object.defineProperty(exports$1, "abytes", { enumerable: true, get: function() {
      return utils_js_2.abytes;
    } });
    Object.defineProperty(exports$1, "anumber", { enumerable: true, get: function() {
      return utils_js_2.anumber;
    } });
    Object.defineProperty(exports$1, "bytesToHex", { enumerable: true, get: function() {
      return utils_js_2.bytesToHex;
    } });
    Object.defineProperty(exports$1, "bytesToUtf8", { enumerable: true, get: function() {
      return utils_js_2.bytesToUtf8;
    } });
    Object.defineProperty(exports$1, "concatBytes", { enumerable: true, get: function() {
      return utils_js_2.concatBytes;
    } });
    Object.defineProperty(exports$1, "hexToBytes", { enumerable: true, get: function() {
      return utils_js_2.hexToBytes;
    } });
    Object.defineProperty(exports$1, "isBytes", { enumerable: true, get: function() {
      return utils_js_2.isBytes;
    } });
    Object.defineProperty(exports$1, "randomBytes", { enumerable: true, get: function() {
      return utils_js_2.randomBytes;
    } });
    Object.defineProperty(exports$1, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_js_2.utf8ToBytes;
    } });
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    function _abool2(value, title = "") {
      if (typeof value !== "boolean") {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + "expected boolean, got type=" + typeof value);
      }
      return value;
    }
    function _abytes2(value, length, title = "") {
      const bytes = (0, utils_js_1.isBytes)(value);
      const len = value?.length;
      const needsLen = length !== void 0;
      if (!bytes || needsLen && len !== length) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : "";
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
      }
      return value;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? "0" + hex : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return hex === "" ? _0n : BigInt("0x" + hex);
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
    }
    function bytesToNumberLE(bytes) {
      (0, utils_js_1.abytes)(bytes);
      return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = (0, utils_js_1.hexToBytes)(hex);
        } catch (e) {
          throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
        }
      } else if ((0, utils_js_1.isBytes)(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(title + " of length " + expectedLength + " expected, got " + len);
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function copyBytes(bytes) {
      return Uint8Array.from(bytes);
    }
    function asciiToBytes(ascii) {
      return Uint8Array.from(ascii, (c, i) => {
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) {
          throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
        }
        return charCode;
      });
    }
    var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    function inRange(n, min, max) {
      return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
    }
    function aInRange(title, n, min, max) {
      if (!inRange(n, min, max))
        throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_1n << BigInt(n)) - _1n;
    exports$1.bitMask = bitMask;
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      const u8n = (len) => new Uint8Array(len);
      const u8of = (byte) => Uint8Array.of(byte);
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n(0)) => {
        k = h(u8of(0), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8of(1), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1.isBytes)(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField2 = (fieldName, type2, isOptional) => {
        const checkVal = validatorFns[type2];
        if (typeof checkVal !== "function")
          throw new Error("invalid validator function");
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
        }
      };
      for (const [fieldName, type2] of Object.entries(validators))
        checkField2(fieldName, type2, false);
      for (const [fieldName, type2] of Object.entries(optValidators))
        checkField2(fieldName, type2, true);
      return object;
    }
    function isHash(val) {
      return typeof val === "function" && Number.isSafeInteger(val.outputLen);
    }
    function _validateObject(object, fields, optFields = {}) {
      if (!object || typeof object !== "object")
        throw new Error("expected valid options object");
      function checkField2(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === void 0)
          return;
        const current = typeof val;
        if (current !== expectedType || val === null)
          throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
      }
      Object.entries(fields).forEach(([k, v]) => checkField2(k, v, false));
      Object.entries(optFields).forEach(([k, v]) => checkField2(k, v, true));
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports$1.notImplemented = notImplemented;
    function memoized(fn) {
      const map2 = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map2.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn(arg, ...args);
        map2.set(arg, computed);
        return computed;
      };
    }
  }
});

// ../../node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "../../node_modules/@noble/curves/abstract/modular.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isNegativeLE = void 0;
    exports$1.mod = mod;
    exports$1.pow = pow;
    exports$1.pow2 = pow2;
    exports$1.invert = invert;
    exports$1.tonelliShanks = tonelliShanks;
    exports$1.FpSqrt = FpSqrt;
    exports$1.validateField = validateField;
    exports$1.FpPow = FpPow;
    exports$1.FpInvertBatch = FpInvertBatch;
    exports$1.FpDiv = FpDiv;
    exports$1.FpLegendre = FpLegendre;
    exports$1.FpIsSquare = FpIsSquare;
    exports$1.nLength = nLength;
    exports$1.Field = Field;
    exports$1.FpSqrtOdd = FpSqrtOdd;
    exports$1.FpSqrtEven = FpSqrtEven;
    exports$1.hashToPrivateScalar = hashToPrivateScalar;
    exports$1.getFieldBytesLength = getFieldBytesLength;
    exports$1.getMinHashLength = getMinHashLength;
    exports$1.mapHashToField = mapHashToField;
    var utils_ts_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    var _3n = /* @__PURE__ */ BigInt(3);
    var _4n = /* @__PURE__ */ BigInt(4);
    var _5n = /* @__PURE__ */ BigInt(5);
    var _7n = /* @__PURE__ */ BigInt(7);
    var _8n = /* @__PURE__ */ BigInt(8);
    var _9n = /* @__PURE__ */ BigInt(9);
    var _16n = /* @__PURE__ */ BigInt(16);
    function mod(a, b) {
      const result2 = a % b;
      return result2 >= _0n ? result2 : b + result2;
    }
    function pow(num, power, modulo2) {
      return FpPow(Field(modulo2), num, power);
    }
    function pow2(x, power, modulo2) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo2;
      }
      return res;
    }
    function invert(number, modulo2) {
      if (number === _0n)
        throw new Error("invert: expected non-zero number");
      if (modulo2 <= _0n)
        throw new Error("invert: expected positive modulus, got " + modulo2);
      let a = mod(number, modulo2);
      let b = modulo2;
      let x = _0n, u = _1n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        b = a, a = r, x = u, u = m;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo2);
    }
    function assertIsSquare(Fp, root, n) {
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
    }
    function sqrt3mod4(Fp, n) {
      const p1div4 = (Fp.ORDER + _1n) / _4n;
      const root = Fp.pow(n, p1div4);
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt5mod8(Fp, n) {
      const p5div8 = (Fp.ORDER - _5n) / _8n;
      const n2 = Fp.mul(n, _2n);
      const v = Fp.pow(n2, p5div8);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt9mod16(P) {
      const Fp_ = Field(P);
      const tn = tonelliShanks(P);
      const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
      const c2 = tn(Fp_, c1);
      const c3 = tn(Fp_, Fp_.neg(c1));
      const c4 = (P + _7n) / _16n;
      return (Fp, n) => {
        let tv1 = Fp.pow(n, c4);
        let tv2 = Fp.mul(tv1, c1);
        const tv3 = Fp.mul(tv1, c2);
        const tv4 = Fp.mul(tv1, c3);
        const e1 = Fp.eql(Fp.sqr(tv2), n);
        const e2 = Fp.eql(Fp.sqr(tv3), n);
        tv1 = Fp.cmov(tv1, tv2, e1);
        tv2 = Fp.cmov(tv4, tv3, e2);
        const e3 = Fp.eql(Fp.sqr(tv2), n);
        const root = Fp.cmov(tv1, tv2, e3);
        assertIsSquare(Fp, root, n);
        return root;
      };
    }
    function tonelliShanks(P) {
      if (P < _3n)
        throw new Error("sqrt is not defined for small field");
      let Q = P - _1n;
      let S = 0;
      while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
      }
      let Z = _2n;
      const _Fp = Field(P);
      while (FpLegendre(_Fp, Z) === 1) {
        if (Z++ > 1e3)
          throw new Error("Cannot find square root: probably non-prime P");
      }
      if (S === 1)
        return sqrt3mod4;
      let cc = _Fp.pow(Z, Q);
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
          return n;
        if (FpLegendre(Fp, n) !== 1)
          throw new Error("Cannot find square root");
        let M = S;
        let c = Fp.mul(Fp.ONE, cc);
        let t = Fp.pow(n, Q);
        let R = Fp.pow(n, Q1div2);
        while (!Fp.eql(t, Fp.ONE)) {
          if (Fp.is0(t))
            return Fp.ZERO;
          let i = 1;
          let t_tmp = Fp.sqr(t);
          while (!Fp.eql(t_tmp, Fp.ONE)) {
            i++;
            t_tmp = Fp.sqr(t_tmp);
            if (i === M)
              throw new Error("Cannot find square root");
          }
          const exponent = _1n << BigInt(M - i - 1);
          const b = Fp.pow(c, exponent);
          M = i;
          c = Fp.sqr(b);
          t = Fp.mul(t, c);
          R = Fp.mul(R, b);
        }
        return R;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n)
        return sqrt3mod4;
      if (P % _8n === _5n)
        return sqrt5mod8;
      if (P % _16n === _9n)
        return sqrt9mod16(P);
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo2) => (mod(num, modulo2) & _1n) === _1n;
    exports$1.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
      };
      const opts = FIELD_FIELDS.reduce((map2, val) => {
        map2[val] = "function";
        return map2;
      }, initial);
      (0, utils_ts_1._validateObject)(field, opts);
      return field;
    }
    function FpPow(Fp, num, power) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n)
        return Fp.ONE;
      if (power === _1n)
        return num;
      let p3 = Fp.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p3 = Fp.mul(p3, d);
        d = Fp.sqr(d);
        power >>= _1n;
      }
      return p3;
    }
    function FpInvertBatch(Fp, nums, passZero = false) {
      const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
      const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
      }, Fp.ONE);
      const invertedAcc = Fp.inv(multipliedAcc);
      nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
      }, invertedAcc);
      return inverted;
    }
    function FpDiv(Fp, lhs, rhs) {
      return Fp.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
    }
    function FpLegendre(Fp, n) {
      const p1mod2 = (Fp.ORDER - _1n) / _2n;
      const powered = Fp.pow(n, p1mod2);
      const yes = Fp.eql(powered, Fp.ONE);
      const zero = Fp.eql(powered, Fp.ZERO);
      const no = Fp.eql(powered, Fp.neg(Fp.ONE));
      if (!yes && !zero && !no)
        throw new Error("invalid Legendre symbol result");
      return yes ? 1 : zero ? 0 : -1;
    }
    function FpIsSquare(Fp, n) {
      const l = FpLegendre(Fp, n);
      return l === 1;
    }
    function nLength(n, nBitLength) {
      if (nBitLength !== void 0)
        (0, utils_ts_1.anumber)(nBitLength);
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
      if (ORDER <= _0n)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      let _sqrt = void 0;
      let modFromBytes = false;
      let allowedLengths = void 0;
      if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
          throw new Error("cannot specify opts in two arguments");
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
          _nbitLength = _opts.BITS;
        if (_opts.sqrt)
          _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === "boolean")
          isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === "boolean")
          modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
      } else {
        if (typeof bitLenOrOpts === "number")
          _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
          _sqrt = opts.sqrt;
      }
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error("invalid field element: expected bigint, got " + typeof num);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt || ((n) => {
          if (!sqrtP)
            sqrtP = FpSqrt(ORDER);
          return sqrtP(f, n);
        }),
        toBytes: (num) => isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes, skipValidation = true) => {
          if (allowedLengths) {
            if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
              throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
            }
            const padded = new Uint8Array(BYTES);
            padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
            bytes = padded;
          }
          if (bytes.length !== BYTES)
            throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
          let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
          if (modFromBytes)
            scalar = mod(scalar, ORDER);
          if (!skipValidation) {
            if (!f.isValid(scalar))
              throw new Error("invalid field element: outside of range 0..ORDER");
          }
          return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => c ? b : a
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
      hash2 = (0, utils_ts_1.ensureBytes)("privateHash", hash2);
      const hashLen = hash2.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash2) : (0, utils_ts_1.bytesToNumberBE)(hash2);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// ../../node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "../../node_modules/@noble/curves/abstract/curve.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.wNAF = void 0;
    exports$1.negateCt = negateCt;
    exports$1.normalizeZ = normalizeZ;
    exports$1.mulEndoUnsafe = mulEndoUnsafe;
    exports$1.pippenger = pippenger;
    exports$1.precomputeMSMUnsafe = precomputeMSMUnsafe;
    exports$1.validateBasic = validateBasic;
    exports$1._createCurveFields = _createCurveFields;
    var utils_ts_1 = require_utils4();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function negateCt(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function normalizeZ(c, points) {
      const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p3) => p3.Z));
      return points.map((p3, i) => c.fromAffine(p3.toAffine(invertedZs[i])));
    }
    function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
    }
    function calcWOpts(W, scalarBits) {
      validateW(W, scalarBits);
      const windows = Math.ceil(scalarBits / W) + 1;
      const windowSize = 2 ** (W - 1);
      const maxNumber = 2 ** W;
      const mask = (0, utils_ts_1.bitMask)(W);
      const shiftBy = BigInt(W);
      return { windows, windowSize, mask, maxNumber, shiftBy };
    }
    function calcOffsets(n, window2, wOpts) {
      const { windowSize, mask, maxNumber, shiftBy } = wOpts;
      let wbits = Number(n & mask);
      let nextN = n >> shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        nextN += _1n;
      }
      const offsetStart = window2 * windowSize;
      const offset = offsetStart + Math.abs(wbits) - 1;
      const isZero2 = wbits === 0;
      const isNeg = wbits < 0;
      const isNegF = window2 % 2 !== 0;
      const offsetF = offsetStart;
      return { nextN, offset, isZero: isZero2, isNeg, isNegF, offsetF };
    }
    function validateMSMPoints(points, c) {
      if (!Array.isArray(points))
        throw new Error("array expected");
      points.forEach((p3, i) => {
        if (!(p3 instanceof c))
          throw new Error("invalid point at index " + i);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
        throw new Error("array of scalars expected");
      scalars.forEach((s, i) => {
        if (!field.isValid(s))
          throw new Error("invalid scalar at index " + i);
      });
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P) {
      return pointWindowSizes.get(P) || 1;
    }
    function assert0(n) {
      if (n !== _0n)
        throw new Error("invalid wNAF");
    }
    var wNAF = class {
      // Parametrized with a given Point class (not individual point)
      constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
      }
      // non-const time multiplication ladder
      _unsafeLadder(elm, n, p3 = this.ZERO) {
        let d = elm;
        while (n > _0n) {
          if (n & _1n)
            p3 = p3.add(d);
          d = d.double();
          n >>= _1n;
        }
        return p3;
      }
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param point Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p3 = point;
        let base = p3;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p3;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p3);
            points.push(base);
          }
          p3 = base.double();
        }
        return points;
      }
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * More compact implementation:
       * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        if (!this.Fn.isValid(n))
          throw new Error("invalid scalar");
        let p3 = this.ZERO;
        let f = this.BASE;
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero: isZero2, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero2) {
            f = f.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p3 = p3.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n);
        return { p: p3, f };
      }
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n)
            break;
          const { nextN, offset, isZero: isZero2, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero2) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      }
      getPrecomputes(W, point, transform) {
        let comp = pointPrecomputes.get(point);
        if (!comp) {
          comp = this.precomputeWindow(point, W);
          if (W !== 1) {
            if (typeof transform === "function")
              comp = transform(comp);
            pointPrecomputes.set(point, comp);
          }
        }
        return comp;
      }
      cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
      }
      unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
          return this._unsafeLadder(point, scalar, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
      }
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
      hasCache(elm) {
        return getW(elm) !== 1;
      }
    };
    exports$1.wNAF = wNAF;
    function mulEndoUnsafe(Point, point, k1, k2) {
      let acc = point;
      let p1 = Point.ZERO;
      let p22 = Point.ZERO;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
          p1 = p1.add(acc);
        if (k2 & _1n)
          p22 = p22.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
      }
      return { p1, p2: p22 };
    }
    function pippenger(c, fieldN, points, scalars) {
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      const plength = points.length;
      const slength = scalars.length;
      if (plength !== slength)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c.ZERO;
      const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
      let windowSize = 1;
      if (wbits > 12)
        windowSize = wbits - 3;
      else if (wbits > 4)
        windowSize = wbits - 2;
      else if (wbits > 0)
        windowSize = 2;
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const buckets = new Array(Number(MASK) + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
          const scalar = scalars[j];
          const wbits2 = Number(scalar >> BigInt(i) & MASK);
          buckets[wbits2] = buckets[wbits2].add(points[j]);
        }
        let resI = zero;
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
          sumI = sumI.add(buckets[j]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
          for (let j = 0; j < windowSize; j++)
            sum = sum.double();
      }
      return sum;
    }
    function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
      validateW(windowSize, fieldN.BITS);
      validateMSMPoints(points, c);
      const zero = c.ZERO;
      const tableSize = 2 ** windowSize - 1;
      const chunks = Math.ceil(fieldN.BITS / windowSize);
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const tables = points.map((p3) => {
        const res = [];
        for (let i = 0, acc = p3; i < tableSize; i++) {
          res.push(acc);
          acc = acc.add(p3);
        }
        return res;
      });
      return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
          throw new Error("array of scalars must be smaller than array of points");
        let res = zero;
        for (let i = 0; i < chunks; i++) {
          if (res !== zero)
            for (let j = 0; j < windowSize; j++)
              res = res.double();
          const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
          for (let j = 0; j < scalars.length; j++) {
            const n = scalars[j];
            const curr = Number(n >> shiftBy & MASK);
            if (!curr)
              continue;
            res = res.add(tables[j][curr - 1]);
          }
        }
        return res;
      };
    }
    function validateBasic(curve) {
      (0, modular_ts_1.validateField)(curve.Fp);
      (0, utils_ts_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    function createField(order, field, isLE) {
      if (field) {
        if (field.ORDER !== order)
          throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        (0, modular_ts_1.validateField)(field);
        return field;
      } else {
        return (0, modular_ts_1.Field)(order, { isLE });
      }
    }
    function _createCurveFields(type2, CURVE, curveOpts = {}, FpFnLE) {
      if (FpFnLE === void 0)
        FpFnLE = type2 === "edwards";
      if (!CURVE || typeof CURVE !== "object")
        throw new Error(`expected valid ${type2} CURVE object`);
      for (const p3 of ["p", "n", "h"]) {
        const val = CURVE[p3];
        if (!(typeof val === "bigint" && val > _0n))
          throw new Error(`CURVE.${p3} must be positive bigint`);
      }
      const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
      const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
      const _b = type2 === "weierstrass" ? "b" : "d";
      const params = ["Gx", "Gy", "a", _b];
      for (const p3 of params) {
        if (!Fp.isValid(CURVE[p3]))
          throw new Error(`CURVE.${p3} must be valid field element of CURVE.Fp`);
      }
      CURVE = Object.freeze(Object.assign({}, CURVE));
      return { CURVE, Fp, Fn };
    }
  }
});

// ../../node_modules/@noble/curves/abstract/edwards.js
var require_edwards = __commonJS({
  "../../node_modules/@noble/curves/abstract/edwards.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.PrimeEdwardsPoint = void 0;
    exports$1.edwards = edwards;
    exports$1.eddsa = eddsa;
    exports$1.twistedEdwards = twistedEdwards;
    var utils_ts_1 = require_utils4();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _8n = BigInt(8);
    function isEdValidXY(Fp, CURVE, x, y) {
      const x2 = Fp.sqr(x);
      const y2 = Fp.sqr(y);
      const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
      const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
      return Fp.eql(left, right);
    }
    function edwards(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)("edwards", params, extraOpts, extraOpts.FpFnLE);
      const { Fp, Fn } = validated;
      let CURVE = validated.CURVE;
      const { h: cofactor } = CURVE;
      (0, utils_ts_1._validateObject)(extraOpts, {}, { uvRatio: "function" });
      const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;
      const modP = (n) => Fp.create(n);
      const uvRatio = extraOpts.uvRatio || ((u, v) => {
        try {
          return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
        } catch (e) {
          return { isValid: false, value: _0n };
        }
      });
      if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      function acoord(title, n, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)("coordinate " + title, n, min, MASK);
        return n;
      }
      function aextpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ExtendedPoint expected");
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p3, iz) => {
        const { X, Y, Z } = p3;
        const is0 = p3.is0();
        if (iz == null)
          iz = is0 ? _8n : Fp.inv(Z);
        const x = modP(X * iz);
        const y = modP(Y * iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
          return { x: _0n, y: _1n };
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p3) => {
        const { a, d } = CURVE;
        if (p3.is0())
          throw new Error("bad point: ZERO");
        const { X, Y, Z, T } = p3;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d * modP(X2 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
        return true;
      });
      class Point {
        constructor(X, Y, Z, T) {
          this.X = acoord("x", X);
          this.Y = acoord("y", Y);
          this.Z = acoord("z", Z, true);
          this.T = acoord("t", T);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE;
        }
        static fromAffine(p3) {
          if (p3 instanceof Point)
            throw new Error("extended point not allowed");
          const { x, y } = p3 || {};
          acoord("x", x);
          acoord("y", y);
          return new Point(x, y, _1n, modP(x * y));
        }
        // Uses algo from RFC8032 5.1.3.
        static fromBytes(bytes, zip215 = false) {
          const len = Fp.BYTES;
          const { a, d } = CURVE;
          bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, "point"));
          (0, utils_ts_1._abool2)(zip215, "zip215");
          const normed = (0, utils_ts_1.copyBytes)(bytes);
          const lastByte = bytes[len - 1];
          normed[len - 1] = lastByte & -129;
          const y = (0, utils_ts_1.bytesToNumberLE)(normed);
          const max = zip215 ? MASK : Fp.ORDER;
          (0, utils_ts_1.aInRange)("point.y", y, _0n, max);
          const y2 = modP(y * y);
          const u = modP(y2 - _1n);
          const v = modP(d * y2 - a);
          let { isValid, value: x } = uvRatio(u, v);
          if (!isValid)
            throw new Error("bad point: invalid y coordinate");
          const isXOdd = (x & _1n) === _1n;
          const isLastByteOdd = (lastByte & 128) !== 0;
          if (!zip215 && x === _0n && isLastByteOdd)
            throw new Error("bad point: x=0 and x_0=1");
          if (isLastByteOdd !== isXOdd)
            x = modP(-x);
          return Point.fromAffine({ x, y });
        }
        static fromHex(bytes, zip215 = false) {
          return Point.fromBytes((0, utils_ts_1.ensureBytes)("point", bytes), zip215);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_2n);
          return this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
          assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
          aextpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const X1Z2 = modP(X1 * Z2);
          const X2Z1 = modP(X2 * Z1);
          const Y1Z2 = modP(Y1 * Z2);
          const Y2Z1 = modP(Y2 * Z1);
          return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        negate() {
          return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
          const { a } = CURVE;
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const A = modP(X1 * X1);
          const B = modP(Y1 * Y1);
          const C = modP(_2n * modP(Z1 * Z1));
          const D = modP(a * A);
          const x1y1 = X1 + Y1;
          const E = modP(modP(x1y1 * x1y1) - A - B);
          const G = D + B;
          const F = G - C;
          const H = D - B;
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
          aextpoint(other);
          const { a, d } = CURVE;
          const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
          const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
          const A = modP(X1 * X2);
          const B = modP(Y1 * Y2);
          const C = modP(T1 * d * T2);
          const D = modP(Z1 * Z2);
          const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
          const F = D - C;
          const G = D + C;
          const H = modP(B - a * A);
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: expected 1 <= sc < curve.n");
          const { p: p3, f } = wnaf.cached(this, scalar, (p4) => (0, curve_ts_1.normalizeZ)(Point, p4));
          return (0, curve_ts_1.normalizeZ)(Point, [p3, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
          if (!Fn.isValid(scalar))
            throw new Error("invalid scalar: expected 0 <= sc < curve.n");
          if (scalar === _0n)
            return Point.ZERO;
          if (this.is0() || scalar === _1n)
            return this;
          return wnaf.unsafe(this, scalar, (p3) => (0, curve_ts_1.normalizeZ)(Point, p3), acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
          return wnaf.unsafe(this, CURVE.n).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
          if (cofactor === _1n)
            return this;
          return this.multiplyUnsafe(cofactor);
        }
        toBytes() {
          const { x, y } = this.toAffine();
          const bytes = Fp.toBytes(y);
          bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
          return bytes;
        }
        toHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get ex() {
          return this.X;
        }
        get ey() {
          return this.Y;
        }
        get ez() {
          return this.Z;
        }
        get et() {
          return this.T;
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        toRawBytes() {
          return this.toBytes();
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
      Point.ZERO = new Point(_0n, _1n, _1n, _0n);
      Point.Fp = Fp;
      Point.Fn = Fn;
      const wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);
      Point.BASE.precompute(8);
      return Point;
    }
    var PrimeEdwardsPoint = class {
      constructor(ep) {
        this.ep = ep;
      }
      // Static methods that must be implemented by subclasses
      static fromBytes(_bytes) {
        (0, utils_ts_1.notImplemented)();
      }
      static fromHex(_hex) {
        (0, utils_ts_1.notImplemented)();
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      // Common implementations
      clearCofactor() {
        return this;
      }
      assertValidity() {
        this.ep.assertValidity();
      }
      toAffine(invertedZ) {
        return this.ep.toAffine(invertedZ);
      }
      toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
      }
      toString() {
        return this.toHex();
      }
      isTorsionFree() {
        return true;
      }
      isSmallOrder() {
        return false;
      }
      add(other) {
        this.assertSame(other);
        return this.init(this.ep.add(other.ep));
      }
      subtract(other) {
        this.assertSame(other);
        return this.init(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return this.init(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return this.init(this.ep.multiplyUnsafe(scalar));
      }
      double() {
        return this.init(this.ep.double());
      }
      negate() {
        return this.init(this.ep.negate());
      }
      precompute(windowSize, isLazy) {
        return this.init(this.ep.precompute(windowSize, isLazy));
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
    };
    exports$1.PrimeEdwardsPoint = PrimeEdwardsPoint;
    function eddsa(Point, cHash, eddsaOpts = {}) {
      if (typeof cHash !== "function")
        throw new Error('"hash" function param is required');
      (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function"
      });
      const { prehash } = eddsaOpts;
      const { BASE, Fp, Fn } = Point;
      const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
      const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
      const domain = eddsaOpts.domain || ((data2, ctx, phflag) => {
        (0, utils_ts_1._abool2)(phflag, "phflag");
        if (ctx.length || phflag)
          throw new Error("Contexts/pre-hash are not supported");
        return data2;
      });
      function modN_LE(hash2) {
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash2));
      }
      function getPrivateScalar(key) {
        const len = lengths.secretKey;
        key = (0, utils_ts_1.ensureBytes)("private key", key, len);
        const hashed = (0, utils_ts_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len));
        const prefix = hashed.slice(len, 2 * len);
        const scalar = modN_LE(head);
        return { head, prefix, scalar };
      }
      function getExtendedPublicKey(secretKey) {
        const { head, prefix, scalar } = getPrivateScalar(secretKey);
        const point = BASE.multiply(scalar);
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
      }
      function getPublicKey(secretKey) {
        return getExtendedPublicKey(secretKey).pointBytes;
      }
      function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)("context", context), !!prehash)));
      }
      function sign(msg, secretKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        if (prehash)
          msg = prehash(msg);
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
        const r = hashDomainToScalar(options.context, prefix, msg);
        const R = BASE.multiply(r).toBytes();
        const k = hashDomainToScalar(options.context, R, pointBytes, msg);
        const s = Fn.create(r + k * scalar);
        if (!Fn.isValid(s))
          throw new Error("sign failed: invalid s");
        const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
        return (0, utils_ts_1._abytes2)(rs, lengths.signature, "result");
      }
      const verifyOpts = { zip215: true };
      function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = lengths.signature;
        sig = (0, utils_ts_1.ensureBytes)("signature", sig, len);
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, lengths.publicKey);
        if (zip215 !== void 0)
          (0, utils_ts_1._abool2)(zip215, "zip215");
        if (prehash)
          msg = prehash(msg);
        const mid = len / 2;
        const r = sig.subarray(0, mid);
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
        let A, R, SB;
        try {
          A = Point.fromBytes(publicKey, zip215);
          R = Point.fromBytes(r, zip215);
          SB = BASE.multiplyUnsafe(s);
        } catch (error) {
          return false;
        }
        if (!zip215 && A.isSmallOrder())
          return false;
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        return RkA.subtract(SB).clearCofactor().is0();
      }
      const _size = Fp.BYTES;
      const lengths = {
        secretKey: _size,
        publicKey: _size,
        signature: 2 * _size,
        seed: _size
      };
      function randomSecretKey(seed = randomBytes(lengths.seed)) {
        return (0, utils_ts_1._abytes2)(seed, lengths.seed, "seed");
      }
      function keygen(seed) {
        const secretKey = utils.randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      function isValidSecretKey(key) {
        return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
      }
      function isValidPublicKey(key, zip215) {
        try {
          return !!Point.fromBytes(key, zip215);
        } catch (error) {
          return false;
        }
      }
      const utils = {
        getExtendedPublicKey,
        randomSecretKey,
        isValidSecretKey,
        isValidPublicKey,
        /**
         * Converts ed public key to x public key. Uses formula:
         * - ed25519:
         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
         * - ed448:
         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
         */
        toMontgomery(publicKey) {
          const { y } = Point.fromBytes(publicKey);
          const size = lengths.publicKey;
          const is25519 = size === 32;
          if (!is25519 && size !== 57)
            throw new Error("only defined for 25519 and 448");
          const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);
          return Fp.toBytes(u);
        },
        toMontgomerySecret(secretKey) {
          const size = lengths.secretKey;
          (0, utils_ts_1._abytes2)(secretKey, size);
          const hashed = cHash(secretKey.subarray(0, size));
          return adjustScalarBytes(hashed).subarray(0, size);
        },
        /** @deprecated */
        randomPrivateKey: randomSecretKey,
        /** @deprecated */
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      return Object.freeze({
        keygen,
        getPublicKey,
        sign,
        verify,
        utils,
        Point,
        lengths
      });
    }
    function _eddsa_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp = c.Fp;
      const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
      const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
      const eddsaOpts = {
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve
      };
      return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
    }
    function _eddsa_new_output_to_legacy(c, eddsa2) {
      const Point = eddsa2.Point;
      const legacy = Object.assign({}, eddsa2, {
        ExtendedPoint: Point,
        CURVE: c,
        nBitLength: Point.Fn.BITS,
        nByteLength: Point.Fn.BYTES
      });
      return legacy;
    }
    function twistedEdwards(c) {
      const { CURVE, curveOpts, hash: hash2, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
      const Point = edwards(CURVE, curveOpts);
      const EDDSA = eddsa(Point, hash2, eddsaOpts);
      return _eddsa_new_output_to_legacy(c, EDDSA);
    }
  }
});

// ../../node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "../../node_modules/@noble/curves/abstract/hash-to-curve.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1._DST_scalar = void 0;
    exports$1.expand_message_xmd = expand_message_xmd;
    exports$1.expand_message_xof = expand_message_xof;
    exports$1.hash_to_field = hash_to_field;
    exports$1.isogenyMap = isogenyMap;
    exports$1.createHasher = createHasher;
    var utils_ts_1 = require_utils4();
    var modular_ts_1 = require_modular();
    var os2ip = utils_ts_1.bytesToNumberBE;
    function i2osp(value, length) {
      anum(value);
      anum(length);
      if (value < 0 || value >= 1 << 8 * length)
        throw new Error("invalid I2OSP input: " + value);
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function normDST(DST) {
      if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== "string")
        throw new Error("DST must be Uint8Array or string");
      return typeof DST === "string" ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (lenInBytes > 65535 || ell > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_ts_1._validateObject)(options, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
      });
      const { p: p3, k, m, hash: hash2, expand, DST } = options;
      if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error("expected valid hash");
      (0, utils_ts_1.abytes)(msg);
      anum(count);
      const log2p = p3.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_ts_1.mod)(os2ip(tv), p3);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map2) {
      const coeff = map2.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv);
        y = field.mul(y, field.mul(yn, yd_inv));
        return { x, y };
      };
    }
    exports$1._DST_scalar = (0, utils_ts_1.utf8ToBytes)("HashToScalar-");
    function createHasher(Point, mapToCurve, defaults) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      function map2(num) {
        return Point.fromAffine(mapToCurve(num));
      }
      function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
          return Point.ZERO;
        P.assertValidity();
        return P;
      }
      return {
        defaults,
        hashToCurve(msg, options) {
          const opts = Object.assign({}, defaults, options);
          const u = hash_to_field(msg, 2, opts);
          const u0 = map2(u[0]);
          const u1 = map2(u[1]);
          return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
          const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
          const opts = Object.assign({}, defaults, optsDst, options);
          const u = hash_to_field(msg, 1, opts);
          const u0 = map2(u[0]);
          return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error("expected array of bigints");
          return clear(map2(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
          const N = Point.Fn.ORDER;
          const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports$1._DST_scalar }, options);
          return hash_to_field(msg, 1, opts)[0][0];
        }
      };
    }
  }
});

// ../../node_modules/@noble/curves/abstract/montgomery.js
var require_montgomery = __commonJS({
  "../../node_modules/@noble/curves/abstract/montgomery.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.montgomery = montgomery;
    var utils_ts_1 = require_utils4();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function validateOpts(curve) {
      (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: "function",
        powPminus2: "function"
      });
      return Object.freeze({ ...curve });
    }
    function montgomery(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { P, type: type2, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
      const is25519 = type2 === "x25519";
      if (!is25519 && type2 !== "x448")
        throw new Error("invalid type");
      const randomBytes_ = rand || utils_ts_1.randomBytes;
      const montgomeryBits = is25519 ? 255 : 448;
      const fieldLen = is25519 ? 32 : 56;
      const Gu = is25519 ? BigInt(9) : BigInt(5);
      const a24 = is25519 ? BigInt(121665) : BigInt(39081);
      const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
      const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;
      const maxScalar = minScalar + maxAdded + _1n;
      const modP = (n) => (0, modular_ts_1.mod)(n, P);
      const GuBytes = encodeU(Gu);
      function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
      }
      function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)("u coordinate", u, fieldLen);
        if (is25519)
          _u[31] &= 127;
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
      }
      function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)));
      }
      function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        if (pu === _0n)
          throw new Error("invalid private or public key received");
        return encodeU(pu);
      }
      function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
      }
      function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return { x_2, x_3 };
      }
      function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)("u", u, _0n, P);
        (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
          const k_t = k >> t & _1n;
          swap ^= k_t;
          ({ x_2, x_3 } = cswap(swap, x_2, x_3));
          ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
          swap = k_t;
          const A = x_2 + z_2;
          const AA = modP(A * A);
          const B = x_2 - z_2;
          const BB = modP(B * B);
          const E = AA - BB;
          const C = x_3 + z_3;
          const D = x_3 - z_3;
          const DA = modP(D * A);
          const CB = modP(C * B);
          const dacb = DA + CB;
          const da_cb = DA - CB;
          x_3 = modP(dacb * dacb);
          z_3 = modP(x_1 * modP(da_cb * da_cb));
          x_2 = modP(AA * BB);
          z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2);
        return modP(x_2 * z2);
      }
      const lengths = {
        secretKey: fieldLen,
        publicKey: fieldLen,
        seed: fieldLen
      };
      const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
        (0, utils_ts_1.abytes)(seed, lengths.seed);
        return seed;
      };
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: scalarMultBase(secretKey) };
      }
      const utils = {
        randomSecretKey,
        randomPrivateKey: randomSecretKey
      };
      return {
        keygen,
        getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
        getPublicKey: (secretKey) => scalarMultBase(secretKey),
        scalarMult,
        scalarMultBase,
        utils,
        GuBytes: GuBytes.slice(),
        lengths
      };
    }
  }
});

// ../../node_modules/@noble/curves/ed25519.js
var require_ed25519 = __commonJS({
  "../../node_modules/@noble/curves/ed25519.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.hash_to_ristretto255 = exports$1.hashToRistretto255 = exports$1.encodeToCurve = exports$1.hashToCurve = exports$1.RistrettoPoint = exports$1.edwardsToMontgomery = exports$1.ED25519_TORSION_SUBGROUP = exports$1.ristretto255_hasher = exports$1.ristretto255 = exports$1.ed25519_hasher = exports$1.x25519 = exports$1.ed25519ph = exports$1.ed25519ctx = exports$1.ed25519 = void 0;
    exports$1.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
    exports$1.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var curve_ts_1 = require_curve();
    var edwards_ts_1 = require_edwards();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var montgomery_ts_1 = require_montgomery();
    var utils_ts_1 = require_utils4();
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
    var ed25519_CURVE = /* @__PURE__ */ (() => ({
      p: ed25519_CURVE_p,
      n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
      h: _8n,
      a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
      d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
      Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
      Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
    }))();
    function ed25519_pow_2_252_3(x) {
      const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
      const P = ed25519_CURVE_p;
      const x2 = x * x % P;
      const b2 = x2 * x % P;
      const b4 = (0, modular_ts_1.pow2)(b2, _2n, P) * b2 % P;
      const b5 = (0, modular_ts_1.pow2)(b4, _1n, P) * x % P;
      const b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
      const b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
      const b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
      const b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
      const b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
      const b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
      const b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
      const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P) * x % P;
      return { pow_p_5_8, b2 };
    }
    function adjustScalarBytes(bytes) {
      bytes[0] &= 248;
      bytes[31] &= 127;
      bytes[31] |= 64;
      return bytes;
    }
    var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    function uvRatio(u, v) {
      const P = ed25519_CURVE_p;
      const v3 = (0, modular_ts_1.mod)(v * v * v, P);
      const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P);
      const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
      let x = (0, modular_ts_1.mod)(u * v3 * pow, P);
      const vx2 = (0, modular_ts_1.mod)(v * x * x, P);
      const root1 = x;
      const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
      const useRoot1 = vx2 === u;
      const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
      const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
      if (useRoot1)
        x = root1;
      if (useRoot2 || noRoot)
        x = root2;
      if ((0, modular_ts_1.isNegativeLE)(x, P))
        x = (0, modular_ts_1.mod)(-x, P);
      return { isValid: useRoot1 || useRoot2, value: x };
    }
    var Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, { isLE: true }))();
    var Fn = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.n, { isLE: true }))();
    var ed25519Defaults = /* @__PURE__ */ (() => ({
      ...ed25519_CURVE,
      Fp,
      hash: sha2_js_1.sha512,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/v
      uvRatio
    }))();
    exports$1.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
    function ed25519_domain(data2, ctx, phflag) {
      if (ctx.length > 255)
        throw new Error("Context is too big");
      return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data2);
    }
    exports$1.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
      ...ed25519Defaults,
      domain: ed25519_domain
    }))();
    exports$1.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
      domain: ed25519_domain,
      prehash: sha2_js_1.sha512
    })))();
    exports$1.x25519 = (() => {
      const P = Fp.ORDER;
      return (0, montgomery_ts_1.montgomery)({
        P,
        type: "x25519",
        powPminus2: (x) => {
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes
      });
    })();
    var ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)();
    var ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))();
    var ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
    function map_to_curve_elligator2_curve25519(u) {
      const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n;
      const ELL2_J = BigInt(486662);
      let tv1 = Fp.sqr(u);
      tv1 = Fp.mul(tv1, _2n);
      let xd = Fp.add(tv1, Fp.ONE);
      let x1n = Fp.neg(ELL2_J);
      let tv2 = Fp.sqr(xd);
      let gxd = Fp.mul(tv2, xd);
      let gx1 = Fp.mul(tv1, ELL2_J);
      gx1 = Fp.mul(gx1, x1n);
      gx1 = Fp.add(gx1, tv2);
      gx1 = Fp.mul(gx1, x1n);
      let tv3 = Fp.sqr(gxd);
      tv2 = Fp.sqr(tv3);
      tv3 = Fp.mul(tv3, gxd);
      tv3 = Fp.mul(tv3, gx1);
      tv2 = Fp.mul(tv2, tv3);
      let y11 = Fp.pow(tv2, ELL2_C4);
      y11 = Fp.mul(y11, tv3);
      let y12 = Fp.mul(y11, ELL2_C3);
      tv2 = Fp.sqr(y11);
      tv2 = Fp.mul(tv2, gxd);
      let e1 = Fp.eql(tv2, gx1);
      let y1 = Fp.cmov(y12, y11, e1);
      let x2n = Fp.mul(x1n, tv1);
      let y21 = Fp.mul(y11, u);
      y21 = Fp.mul(y21, ELL2_C2);
      let y22 = Fp.mul(y21, ELL2_C3);
      let gx2 = Fp.mul(gx1, tv1);
      tv2 = Fp.sqr(y21);
      tv2 = Fp.mul(tv2, gxd);
      let e2 = Fp.eql(tv2, gx2);
      let y2 = Fp.cmov(y22, y21, e2);
      tv2 = Fp.sqr(y1);
      tv2 = Fp.mul(tv2, gxd);
      let e3 = Fp.eql(tv2, gx1);
      let xn = Fp.cmov(x2n, x1n, e3);
      let y = Fp.cmov(y2, y1, e3);
      let e4 = Fp.isOdd(y);
      y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
      return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
    }
    var ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
    function map_to_curve_elligator2_edwards25519(u) {
      const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
      let xn = Fp.mul(xMn, yMd);
      xn = Fp.mul(xn, ELL2_C1_EDWARDS);
      let xd = Fp.mul(xMd, yMn);
      let yn = Fp.sub(xMn, xMd);
      let yd = Fp.add(xMn, xMd);
      let tv1 = Fp.mul(xd, yd);
      let e = Fp.eql(tv1, Fp.ZERO);
      xn = Fp.cmov(xn, Fp.ZERO, e);
      xd = Fp.cmov(xd, Fp.ONE, e);
      yn = Fp.cmov(yn, Fp.ONE, e);
      yd = Fp.cmov(yd, Fp.ONE, e);
      const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true);
      return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
    }
    exports$1.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports$1.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
      DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
      encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
      p: ed25519_CURVE_p,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha512
    }))();
    var SQRT_M1 = ED25519_SQRT_M1;
    var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    var invertSqrt = (number) => uvRatio(_1n, number);
    var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    var bytes255ToNumberLE = (bytes) => exports$1.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
    function calcElligatorRistrettoMap(r0) {
      const { d } = ed25519_CURVE;
      const P = ed25519_CURVE_p;
      const mod = (n) => Fp.create(n);
      const r = mod(SQRT_M1 * r0 * r0);
      const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
      let c = BigInt(-1);
      const D = mod((c - d * r) * mod(r + d));
      let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
      let s_ = mod(s * r0);
      if (!(0, modular_ts_1.isNegativeLE)(s_, P))
        s_ = mod(-s_);
      if (!Ns_D_is_sq)
        s = s_;
      if (!Ns_D_is_sq)
        c = r;
      const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
      const s2 = s * s;
      const W0 = mod((s + s) * D);
      const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
      const W2 = mod(_1n - s2);
      const W3 = mod(_1n + s2);
      return new exports$1.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
    }
    function ristretto255_map(bytes) {
      (0, utils_js_1.abytes)(bytes, 64);
      const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
      const R1 = calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
      const R2 = calcElligatorRistrettoMap(r2);
      return new _RistrettoPoint(R1.add(R2));
    }
    var _RistrettoPoint = class __RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
      constructor(ep) {
        super(ep);
      }
      static fromAffine(ap) {
        return new __RistrettoPoint(exports$1.ed25519.Point.fromAffine(ap));
      }
      assertSame(other) {
        if (!(other instanceof __RistrettoPoint))
          throw new Error("RistrettoPoint expected");
      }
      init(ep) {
        return new __RistrettoPoint(ep);
      }
      /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
      static hashToCurve(hex) {
        return ristretto255_map((0, utils_ts_1.ensureBytes)("ristrettoHash", hex, 64));
      }
      static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes, 32);
        const { a, d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const s = bytes255ToNumberLE(bytes);
        if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) || (0, modular_ts_1.isNegativeLE)(s, P))
          throw new Error("invalid ristretto255 encoding 1");
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2);
        const u2 = mod(_1n - a * s2);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod(v * u2_2));
        const Dx = mod(I * u2);
        const Dy = mod(I * Dx * v);
        let x = mod((s + s) * Dx);
        if ((0, modular_ts_1.isNegativeLE)(x, P))
          x = mod(-x);
        const y = mod(u1 * Dy);
        const t = mod(x * y);
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
          throw new Error("invalid ristretto255 encoding 2");
        return new __RistrettoPoint(new exports$1.ed25519.Point(x, y, _1n, t));
      }
      /**
       * Converts ristretto-encoded string to ristretto point.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
       * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
       */
      static fromHex(hex) {
        return __RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)("ristrettoHex", hex, 32));
      }
      static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(__RistrettoPoint, exports$1.ed25519.Point.Fn, points, scalars);
      }
      /**
       * Encodes ristretto point to Uint8Array.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
       */
      toBytes() {
        let { X, Y, Z, T } = this.ep;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const u1 = mod(mod(Z + Y) * mod(Z - Y));
        const u2 = mod(X * Y);
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D2 = mod(invsqrt * u2);
        const zInv = mod(D1 * D2 * T);
        let D;
        if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
          let _x = mod(Y * SQRT_M1);
          let _y = mod(X * SQRT_M1);
          X = _x;
          Y = _y;
          D = mod(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if ((0, modular_ts_1.isNegativeLE)(X * zInv, P))
          Y = mod(-Y);
        let s = mod((Z - Y) * D);
        if ((0, modular_ts_1.isNegativeLE)(s, P))
          s = mod(-s);
        return Fp.toBytes(s);
      }
      /**
       * Compares two Ristretto points.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
       */
      equals(other) {
        this.assertSame(other);
        const { X: X1, Y: Y1 } = this.ep;
        const { X: X2, Y: Y2 } = other.ep;
        const mod = (n) => Fp.create(n);
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
      }
      is0() {
        return this.equals(__RistrettoPoint.ZERO);
      }
    };
    _RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(exports$1.ed25519.Point.BASE))();
    _RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(exports$1.ed25519.Point.ZERO))();
    _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
    _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
    exports$1.ristretto255 = { Point: _RistrettoPoint };
    exports$1.ristretto255_hasher = {
      hashToCurve(msg, options) {
        const DST = options?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
        return ristretto255_map(xmd);
      },
      hashToScalar(msg, options = { DST: hash_to_curve_ts_1._DST_scalar }) {
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
      }
    };
    exports$1.ED25519_TORSION_SUBGROUP = [
      "0100000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
      "0000000000000000000000000000000000000000000000000000000000000080",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
      "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
    ];
    function edwardsToMontgomeryPub(edwardsPub) {
      return exports$1.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)("pub", edwardsPub));
    }
    exports$1.edwardsToMontgomery = edwardsToMontgomeryPub;
    function edwardsToMontgomeryPriv(edwardsPriv) {
      return exports$1.ed25519.utils.toMontgomerySecret((0, utils_ts_1.ensureBytes)("pub", edwardsPriv));
    }
    exports$1.RistrettoPoint = _RistrettoPoint;
    exports$1.hashToCurve = (() => exports$1.ed25519_hasher.hashToCurve)();
    exports$1.encodeToCurve = (() => exports$1.ed25519_hasher.encodeToCurve)();
    exports$1.hashToRistretto255 = (() => exports$1.ristretto255_hasher.hashToCurve)();
    exports$1.hash_to_ristretto255 = (() => exports$1.ristretto255_hasher.hashToCurve)();
  }
});

// ../../node_modules/hash-wasm/dist/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  adler32: () => adler32,
  argon2Verify: () => argon2Verify,
  argon2d: () => argon2d,
  argon2i: () => argon2i,
  argon2id: () => argon2id,
  bcrypt: () => bcrypt,
  bcryptVerify: () => bcryptVerify,
  blake2b: () => blake2b,
  blake2s: () => blake2s,
  blake3: () => blake3,
  crc32: () => crc32,
  crc64: () => crc64,
  createAdler32: () => createAdler32,
  createBLAKE2b: () => createBLAKE2b,
  createBLAKE2s: () => createBLAKE2s,
  createBLAKE3: () => createBLAKE3,
  createCRC32: () => createCRC32,
  createCRC64: () => createCRC64,
  createHMAC: () => createHMAC,
  createKeccak: () => createKeccak,
  createMD4: () => createMD4,
  createMD5: () => createMD5,
  createRIPEMD160: () => createRIPEMD160,
  createSHA1: () => createSHA1,
  createSHA224: () => createSHA224,
  createSHA256: () => createSHA256,
  createSHA3: () => createSHA3,
  createSHA384: () => createSHA384,
  createSHA512: () => createSHA512,
  createSM3: () => createSM3,
  createWhirlpool: () => createWhirlpool,
  createXXHash128: () => createXXHash128,
  createXXHash3: () => createXXHash3,
  createXXHash32: () => createXXHash32,
  createXXHash64: () => createXXHash64,
  keccak: () => keccak,
  md4: () => md4,
  md5: () => md5,
  pbkdf2: () => pbkdf2,
  ripemd160: () => ripemd160,
  scrypt: () => scrypt,
  sha1: () => sha1,
  sha224: () => sha224,
  sha256: () => sha256,
  sha3: () => sha3,
  sha384: () => sha384,
  sha512: () => sha512,
  sm3: () => sm3,
  whirlpool: () => whirlpool,
  xxhash128: () => xxhash128,
  xxhash3: () => xxhash3,
  xxhash32: () => xxhash32,
  xxhash64: () => xxhash64
});
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function getGlobal() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  return global;
}
function intArrayToString(arr, len) {
  return String.fromCharCode(...arr.subarray(0, len));
}
function hexCharCodesToInt(a, b) {
  return (a & 15) + (a >> 6 | a >> 3 & 8) << 4 | (b & 15) + (b >> 6 | b >> 3 & 8);
}
function writeHexToUInt8(buf, str2) {
  const size = str2.length >> 1;
  for (let i = 0; i < size; i++) {
    const index = i << 1;
    buf[i] = hexCharCodesToInt(str2.charCodeAt(index), str2.charCodeAt(index + 1));
  }
}
function hexStringEqualsUInt8(str2, buf) {
  if (str2.length !== buf.length * 2) {
    return false;
  }
  for (let i = 0; i < buf.length; i++) {
    const strIndex = i << 1;
    if (buf[i] !== hexCharCodesToInt(str2.charCodeAt(strIndex), str2.charCodeAt(strIndex + 1))) {
      return false;
    }
  }
  return true;
}
function getDigestHex(tmpBuffer, input, hashLength) {
  let p3 = 0;
  for (let i = 0; i < hashLength; i++) {
    let nibble = input[i] >>> 4;
    tmpBuffer[p3++] = nibble > 9 ? nibble + alpha : nibble + digit;
    nibble = input[i] & 15;
    tmpBuffer[p3++] = nibble > 9 ? nibble + alpha : nibble + digit;
  }
  return String.fromCharCode.apply(null, tmpBuffer);
}
function encodeBase64(data2, pad = true) {
  const len = data2.length;
  const extraBytes = len % 3;
  const parts = [];
  const len2 = len - extraBytes;
  for (let i = 0; i < len2; i += 3) {
    const tmp = (data2[i] << 16 & 16711680) + (data2[i + 1] << 8 & 65280) + (data2[i + 2] & 255);
    const triplet = base64Chars.charAt(tmp >> 18 & 63) + base64Chars.charAt(tmp >> 12 & 63) + base64Chars.charAt(tmp >> 6 & 63) + base64Chars.charAt(tmp & 63);
    parts.push(triplet);
  }
  if (extraBytes === 1) {
    const tmp = data2[len - 1];
    const a = base64Chars.charAt(tmp >> 2);
    const b = base64Chars.charAt(tmp << 4 & 63);
    parts.push(`${a}${b}`);
    if (pad) {
      parts.push("==");
    }
  } else if (extraBytes === 2) {
    const tmp = (data2[len - 2] << 8) + data2[len - 1];
    const a = base64Chars.charAt(tmp >> 10);
    const b = base64Chars.charAt(tmp >> 4 & 63);
    const c = base64Chars.charAt(tmp << 2 & 63);
    parts.push(`${a}${b}${c}`);
    if (pad) {
      parts.push("=");
    }
  }
  return parts.join("");
}
function getDecodeBase64Length(data2) {
  let bufferLength = Math.floor(data2.length * 0.75);
  const len = data2.length;
  if (data2[len - 1] === "=") {
    bufferLength -= 1;
    if (data2[len - 2] === "=") {
      bufferLength -= 1;
    }
  }
  return bufferLength;
}
function decodeBase64(data2) {
  const bufferLength = getDecodeBase64Length(data2);
  const len = data2.length;
  const bytes = new Uint8Array(bufferLength);
  let p3 = 0;
  for (let i = 0; i < len; i += 4) {
    const encoded1 = base64Lookup[data2.charCodeAt(i)];
    const encoded2 = base64Lookup[data2.charCodeAt(i + 1)];
    const encoded3 = base64Lookup[data2.charCodeAt(i + 2)];
    const encoded4 = base64Lookup[data2.charCodeAt(i + 3)];
    bytes[p3] = encoded1 << 2 | encoded2 >> 4;
    p3 += 1;
    bytes[p3] = (encoded2 & 15) << 4 | encoded3 >> 2;
    p3 += 1;
    bytes[p3] = (encoded3 & 3) << 6 | encoded4 & 63;
    p3 += 1;
  }
  return bytes;
}
function WASMInterface(binary2, hashLength) {
  return __awaiter(this, void 0, void 0, function* () {
    let wasmInstance = null;
    let memoryView = null;
    let initialized = false;
    if (typeof WebAssembly === "undefined") {
      throw new Error("WebAssembly is not supported in this environment!");
    }
    const writeMemory = (data2, offset = 0) => {
      memoryView.set(data2, offset);
    };
    const getMemory = () => memoryView;
    const getExports = () => wasmInstance.exports;
    const setMemorySize = (totalSize) => {
      wasmInstance.exports.Hash_SetMemorySize(totalSize);
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);
    };
    const getStateSize = () => {
      const view = new DataView(wasmInstance.exports.memory.buffer);
      const stateSize = view.getUint32(wasmInstance.exports.STATE_SIZE, true);
      return stateSize;
    };
    const loadWASMPromise = wasmMutex.dispatch(() => __awaiter(this, void 0, void 0, function* () {
      if (!wasmModuleCache.has(binary2.name)) {
        const asm = decodeBase64(binary2.data);
        const promise = WebAssembly.compile(asm);
        wasmModuleCache.set(binary2.name, promise);
      }
      const module = yield wasmModuleCache.get(binary2.name);
      wasmInstance = yield WebAssembly.instantiate(module, {
        // env: {
        //   emscripten_memcpy_big: (dest, src, num) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     memView.set(memView.subarray(src, src + num), dest);
        //   },
        //   print_memory: (offset, len) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     console.log('print_int32', memView.subarray(offset, offset + len));
        //   },
        // },
      });
    }));
    const setupInterface = () => __awaiter(this, void 0, void 0, function* () {
      if (!wasmInstance) {
        yield loadWASMPromise;
      }
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, MAX_HEAP);
    });
    const init = (bits = null) => {
      initialized = true;
      wasmInstance.exports.Hash_Init(bits);
    };
    const updateUInt8Array = (data2) => {
      let read = 0;
      while (read < data2.length) {
        const chunk = data2.subarray(read, read + MAX_HEAP);
        read += chunk.length;
        memoryView.set(chunk);
        wasmInstance.exports.Hash_Update(chunk.length);
      }
    };
    const update = (data2) => {
      if (!initialized) {
        throw new Error("update() called before init()");
      }
      const Uint8Buffer = getUInt8Buffer(data2);
      updateUInt8Array(Uint8Buffer);
    };
    const digestChars = new Uint8Array(hashLength * 2);
    const digest = (outputType, padding = null) => {
      if (!initialized) {
        throw new Error("digest() called before init()");
      }
      initialized = false;
      wasmInstance.exports.Hash_Final(padding);
      if (outputType === "binary") {
        return memoryView.slice(0, hashLength);
      }
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    const save = () => {
      if (!initialized) {
        throw new Error("save() can only be called after init() and before digest()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);
      const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);
      writeHexToUInt8(prefixedState, binary2.hash);
      prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);
      return prefixedState;
    };
    const load2 = (state) => {
      if (!(state instanceof Uint8Array)) {
        throw new Error("load() expects an Uint8Array generated by save()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      if (state.length !== overallLength) {
        throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);
      }
      if (!hexStringEqualsUInt8(binary2.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) {
        throw new Error("This state was written by an incompatible hash implementation");
      }
      const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);
      new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);
      initialized = true;
    };
    const isDataShort = (data2) => {
      if (typeof data2 === "string") {
        return data2.length < MAX_HEAP / 4;
      }
      return data2.byteLength < MAX_HEAP;
    };
    let canSimplify = isDataShort;
    switch (binary2.name) {
      case "argon2":
      case "scrypt":
        canSimplify = () => true;
        break;
      case "blake2b":
      case "blake2s":
        canSimplify = (data2, initParam) => initParam <= 512 && isDataShort(data2);
        break;
      case "blake3":
        canSimplify = (data2, initParam) => initParam === 0 && isDataShort(data2);
        break;
      case "xxhash64":
      // cannot simplify
      case "xxhash3":
      case "xxhash128":
      case "crc64":
        canSimplify = () => false;
        break;
    }
    const calculate = (data2, initParam = null, digestParam = null) => {
      if (!canSimplify(data2, initParam)) {
        init(initParam);
        update(data2);
        return digest("hex", digestParam);
      }
      const buffer = getUInt8Buffer(data2);
      memoryView.set(buffer);
      wasmInstance.exports.Hash_Calculate(buffer.length, initParam, digestParam);
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    yield setupInterface();
    return {
      getMemory,
      writeMemory,
      getExports,
      setMemorySize,
      init,
      update,
      digest,
      save,
      load: load2,
      calculate,
      hashLength
    };
  });
}
function lockedCreate(mutex2, binary2, hashLength) {
  return __awaiter(this, void 0, void 0, function* () {
    const unlock = yield mutex2.lock();
    const wasm2 = yield WASMInterface(binary2, hashLength);
    unlock();
    return wasm2;
  });
}
function adler32(data2) {
  if (wasmCache$l === null) {
    return lockedCreate(mutex$l, wasmJson$l, 4).then((wasm2) => {
      wasmCache$l = wasm2;
      return wasmCache$l.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$l.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createAdler32() {
  return WASMInterface(wasmJson$l, 4).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 4,
      digestSize: 4
    };
    return obj;
  });
}
function validateBits$4(bits) {
  if (!Number.isInteger(bits) || bits < 8 || bits > 512 || bits % 8 !== 0) {
    return new Error("Invalid variant! Valid values: 8, 16, ..., 512");
  }
  return null;
}
function getInitParam$1(outputBits, keyBits) {
  return outputBits | keyBits << 16;
}
function blake2b(data2, bits = 512, key = null) {
  if (validateBits$4(bits)) {
    return Promise.reject(validateBits$4(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 64) {
      return Promise.reject(new Error("Max key length is 64 bytes"));
    }
    initParam = getInitParam$1(bits, keyBuffer.length);
  }
  const hashLength = bits / 8;
  if (wasmCache$k === null || wasmCache$k.hashLength !== hashLength) {
    return lockedCreate(mutex$k, wasmJson$j, hashLength).then((wasm2) => {
      wasmCache$k = wasm2;
      if (initParam > 512) {
        wasmCache$k.writeMemory(keyBuffer);
      }
      return wasmCache$k.calculate(data2, initParam);
    });
  }
  try {
    if (initParam > 512) {
      wasmCache$k.writeMemory(keyBuffer);
    }
    const hash2 = wasmCache$k.calculate(data2, initParam);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createBLAKE2b(bits = 512, key = null) {
  if (validateBits$4(bits)) {
    return Promise.reject(validateBits$4(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 64) {
      return Promise.reject(new Error("Max key length is 64 bytes"));
    }
    initParam = getInitParam$1(bits, keyBuffer.length);
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$j, outputSize).then((wasm2) => {
    if (initParam > 512) {
      wasm2.writeMemory(keyBuffer);
    }
    wasm2.init(initParam);
    const obj = {
      init: initParam > 512 ? () => {
        wasm2.writeMemory(keyBuffer);
        wasm2.init(initParam);
        return obj;
      } : () => {
        wasm2.init(initParam);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 128,
      digestSize: outputSize
    };
    return obj;
  });
}
function encodeResult(salt, options, res) {
  const parameters = [
    `m=${options.memorySize}`,
    `t=${options.iterations}`,
    `p=${options.parallelism}`
  ].join(",");
  return `$argon2${options.hashType}$v=19$${parameters}$${encodeBase64(salt, false)}$${encodeBase64(res, false)}`;
}
function int32LE(x) {
  uint32View.setInt32(0, x, true);
  return new Uint8Array(uint32View.buffer);
}
function hashFunc(blake512, buf, len) {
  return __awaiter(this, void 0, void 0, function* () {
    if (len <= 64) {
      const blake = yield createBLAKE2b(len * 8);
      blake.update(int32LE(len));
      blake.update(buf);
      return blake.digest("binary");
    }
    const r = Math.ceil(len / 32) - 2;
    const ret = new Uint8Array(len);
    blake512.init();
    blake512.update(int32LE(len));
    blake512.update(buf);
    let vp = blake512.digest("binary");
    ret.set(vp.subarray(0, 32), 0);
    for (let i = 1; i < r; i++) {
      blake512.init();
      blake512.update(vp);
      vp = blake512.digest("binary");
      ret.set(vp.subarray(0, 32), i * 32);
    }
    const partialBytesNeeded = len - 32 * r;
    let blakeSmall;
    if (partialBytesNeeded === 64) {
      blakeSmall = blake512;
      blakeSmall.init();
    } else {
      blakeSmall = yield createBLAKE2b(partialBytesNeeded * 8);
    }
    blakeSmall.update(vp);
    vp = blakeSmall.digest("binary");
    ret.set(vp.subarray(0, partialBytesNeeded), r * 32);
    return ret;
  });
}
function getHashType(type2) {
  switch (type2) {
    case "d":
      return 0;
    case "i":
      return 1;
    default:
      return 2;
  }
}
function argon2Internal(options) {
  return __awaiter(this, void 0, void 0, function* () {
    var _a2;
    const { parallelism, iterations, hashLength } = options;
    const password = getUInt8Buffer(options.password);
    const salt = getUInt8Buffer(options.salt);
    const version = 19;
    const hashType = getHashType(options.hashType);
    const { memorySize } = options;
    const secret = getUInt8Buffer((_a2 = options.secret) !== null && _a2 !== void 0 ? _a2 : "");
    const [argon2Interface, blake512] = yield Promise.all([
      WASMInterface(wasmJson$k, 1024),
      createBLAKE2b(512)
    ]);
    argon2Interface.setMemorySize(memorySize * 1024 + 1024);
    const initVector = new Uint8Array(24);
    const initVectorView = new DataView(initVector.buffer);
    initVectorView.setInt32(0, parallelism, true);
    initVectorView.setInt32(4, hashLength, true);
    initVectorView.setInt32(8, memorySize, true);
    initVectorView.setInt32(12, iterations, true);
    initVectorView.setInt32(16, version, true);
    initVectorView.setInt32(20, hashType, true);
    argon2Interface.writeMemory(initVector, memorySize * 1024);
    blake512.init();
    blake512.update(initVector);
    blake512.update(int32LE(password.length));
    blake512.update(password);
    blake512.update(int32LE(salt.length));
    blake512.update(salt);
    blake512.update(int32LE(secret.length));
    blake512.update(secret);
    blake512.update(int32LE(0));
    const segments = Math.floor(memorySize / (parallelism * 4));
    const lanes = segments * 4;
    const param = new Uint8Array(72);
    const H0 = blake512.digest("binary");
    param.set(H0);
    for (let lane = 0; lane < parallelism; lane++) {
      param.set(int32LE(0), 64);
      param.set(int32LE(lane), 68);
      let position = lane * lanes;
      let chunk = yield hashFunc(blake512, param, 1024);
      argon2Interface.writeMemory(chunk, position * 1024);
      position += 1;
      param.set(int32LE(1), 64);
      chunk = yield hashFunc(blake512, param, 1024);
      argon2Interface.writeMemory(chunk, position * 1024);
    }
    const C = new Uint8Array(1024);
    writeHexToUInt8(C, argon2Interface.calculate(new Uint8Array([]), memorySize));
    const res = yield hashFunc(blake512, C, hashLength);
    if (options.outputType === "hex") {
      const digestChars = new Uint8Array(hashLength * 2);
      return getDigestHex(digestChars, res, hashLength);
    }
    if (options.outputType === "encoded") {
      return encodeResult(salt, options, res);
    }
    return res;
  });
}
function argon2i(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$3(options);
    return argon2Internal(Object.assign(Object.assign({}, options), { hashType: "i" }));
  });
}
function argon2id(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$3(options);
    return argon2Internal(Object.assign(Object.assign({}, options), { hashType: "id" }));
  });
}
function argon2d(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$3(options);
    return argon2Internal(Object.assign(Object.assign({}, options), { hashType: "d" }));
  });
}
function argon2Verify(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateVerifyOptions$1(options);
    const params = getHashParameters(options.password, options.hash, options.secret);
    validateOptions$3(params);
    const hashStart = options.hash.lastIndexOf("$") + 1;
    const result2 = yield argon2Internal(params);
    return result2.substring(hashStart) === options.hash.substring(hashStart);
  });
}
function validateBits$3(bits) {
  if (!Number.isInteger(bits) || bits < 8 || bits > 256 || bits % 8 !== 0) {
    return new Error("Invalid variant! Valid values: 8, 16, ..., 256");
  }
  return null;
}
function getInitParam(outputBits, keyBits) {
  return outputBits | keyBits << 16;
}
function blake2s(data2, bits = 256, key = null) {
  if (validateBits$3(bits)) {
    return Promise.reject(validateBits$3(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 32) {
      return Promise.reject(new Error("Max key length is 32 bytes"));
    }
    initParam = getInitParam(bits, keyBuffer.length);
  }
  const hashLength = bits / 8;
  if (wasmCache$j === null || wasmCache$j.hashLength !== hashLength) {
    return lockedCreate(mutex$j, wasmJson$i, hashLength).then((wasm2) => {
      wasmCache$j = wasm2;
      if (initParam > 512) {
        wasmCache$j.writeMemory(keyBuffer);
      }
      return wasmCache$j.calculate(data2, initParam);
    });
  }
  try {
    if (initParam > 512) {
      wasmCache$j.writeMemory(keyBuffer);
    }
    const hash2 = wasmCache$j.calculate(data2, initParam);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createBLAKE2s(bits = 256, key = null) {
  if (validateBits$3(bits)) {
    return Promise.reject(validateBits$3(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 32) {
      return Promise.reject(new Error("Max key length is 32 bytes"));
    }
    initParam = getInitParam(bits, keyBuffer.length);
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$i, outputSize).then((wasm2) => {
    if (initParam > 512) {
      wasm2.writeMemory(keyBuffer);
    }
    wasm2.init(initParam);
    const obj = {
      init: initParam > 512 ? () => {
        wasm2.writeMemory(keyBuffer);
        wasm2.init(initParam);
        return obj;
      } : () => {
        wasm2.init(initParam);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: outputSize
    };
    return obj;
  });
}
function validateBits$2(bits) {
  if (!Number.isInteger(bits) || bits < 8 || bits % 8 !== 0) {
    return new Error("Invalid variant! Valid values: 8, 16, ...");
  }
  return null;
}
function blake3(data2, bits = 256, key = null) {
  if (validateBits$2(bits)) {
    return Promise.reject(validateBits$2(bits));
  }
  let keyBuffer = null;
  let initParam = 0;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length !== 32) {
      return Promise.reject(new Error("Key length must be exactly 32 bytes"));
    }
    initParam = 32;
  }
  const hashLength = bits / 8;
  const digestParam = hashLength;
  if (wasmCache$i === null || wasmCache$i.hashLength !== hashLength) {
    return lockedCreate(mutex$i, wasmJson$h, hashLength).then((wasm2) => {
      wasmCache$i = wasm2;
      if (initParam === 32) {
        wasmCache$i.writeMemory(keyBuffer);
      }
      return wasmCache$i.calculate(data2, initParam, digestParam);
    });
  }
  try {
    if (initParam === 32) {
      wasmCache$i.writeMemory(keyBuffer);
    }
    const hash2 = wasmCache$i.calculate(data2, initParam, digestParam);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createBLAKE3(bits = 256, key = null) {
  if (validateBits$2(bits)) {
    return Promise.reject(validateBits$2(bits));
  }
  let keyBuffer = null;
  let initParam = 0;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length !== 32) {
      return Promise.reject(new Error("Key length must be exactly 32 bytes"));
    }
    initParam = 32;
  }
  const outputSize = bits / 8;
  const digestParam = outputSize;
  return WASMInterface(wasmJson$h, outputSize).then((wasm2) => {
    if (initParam === 32) {
      wasm2.writeMemory(keyBuffer);
    }
    wasm2.init(initParam);
    const obj = {
      init: initParam === 32 ? () => {
        wasm2.writeMemory(keyBuffer);
        wasm2.init(initParam);
        return obj;
      } : () => {
        wasm2.init(initParam);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType, digestParam),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: outputSize
    };
    return obj;
  });
}
function validatePoly(poly) {
  if (!Number.isInteger(poly) || poly < 0 || poly > 4294967295) {
    return new Error("Polynomial must be a valid 32-bit long unsigned integer");
  }
  return null;
}
function crc32(data2, polynomial = 3988292384) {
  if (validatePoly(polynomial)) {
    return Promise.reject(validatePoly(polynomial));
  }
  if (wasmCache$h === null) {
    return lockedCreate(mutex$h, wasmJson$g, 4).then((wasm2) => {
      wasmCache$h = wasm2;
      return wasmCache$h.calculate(data2, polynomial);
    });
  }
  try {
    const hash2 = wasmCache$h.calculate(data2, polynomial);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createCRC32(polynomial = 3988292384) {
  if (validatePoly(polynomial)) {
    return Promise.reject(validatePoly(polynomial));
  }
  return WASMInterface(wasmJson$g, 4).then((wasm2) => {
    wasm2.init(polynomial);
    const obj = {
      init: () => {
        wasm2.init(polynomial);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 4,
      digestSize: 4
    };
    return obj;
  });
}
function parsePoly(poly) {
  const errText = "Polynomial must be provided as a 16 char long hex string";
  if (typeof poly !== "string" || poly.length !== 16) {
    return { hi: 0, lo: 0, err: new Error(errText) };
  }
  const hi = Number(`0x${poly.slice(0, 8)}`);
  const lo = Number(`0x${poly.slice(8)}`);
  if (Number.isNaN(hi) || Number.isNaN(lo)) {
    return { hi, lo, err: new Error(errText) };
  }
  return { hi, lo, err: null };
}
function writePoly(arr, lo, hi) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, lo, true);
  buffer.setUint32(4, hi, true);
}
function crc64(data2, polynomial = "c96c5795d7870f42") {
  const { hi, lo, err } = parsePoly(polynomial);
  if (err !== null) {
    return Promise.reject(err);
  }
  if (wasmCache$g === null) {
    return lockedCreate(mutex$g, wasmJson$f, 8).then((wasm2) => {
      wasmCache$g = wasm2;
      writePoly(polyBuffer.buffer, lo, hi);
      wasmCache$g.writeMemory(polyBuffer);
      return wasmCache$g.calculate(data2);
    });
  }
  try {
    writePoly(polyBuffer.buffer, lo, hi);
    wasmCache$g.writeMemory(polyBuffer);
    const hash2 = wasmCache$g.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err2) {
    return Promise.reject(err2);
  }
}
function createCRC64(polynomial = "c96c5795d7870f42") {
  const { hi, lo, err } = parsePoly(polynomial);
  if (err !== null) {
    return Promise.reject(err);
  }
  return WASMInterface(wasmJson$f, 8).then((wasm2) => {
    const instanceBuffer = new Uint8Array(8);
    writePoly(instanceBuffer.buffer, lo, hi);
    wasm2.writeMemory(instanceBuffer);
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.writeMemory(instanceBuffer);
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 8,
      digestSize: 8
    };
    return obj;
  });
}
function md4(data2) {
  if (wasmCache$f === null) {
    return lockedCreate(mutex$f, wasmJson$e, 16).then((wasm2) => {
      wasmCache$f = wasm2;
      return wasmCache$f.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$f.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createMD4() {
  return WASMInterface(wasmJson$e, 16).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 16
    };
    return obj;
  });
}
function md5(data2) {
  if (wasmCache$e === null) {
    return lockedCreate(mutex$e, wasmJson$d, 16).then((wasm2) => {
      wasmCache$e = wasm2;
      return wasmCache$e.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$e.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createMD5() {
  return WASMInterface(wasmJson$d, 16).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 16
    };
    return obj;
  });
}
function sha1(data2) {
  if (wasmCache$d === null) {
    return lockedCreate(mutex$d, wasmJson$c, 20).then((wasm2) => {
      wasmCache$d = wasm2;
      return wasmCache$d.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$d.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA1() {
  return WASMInterface(wasmJson$c, 20).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 20
    };
    return obj;
  });
}
function validateBits$1(bits) {
  if (![224, 256, 384, 512].includes(bits)) {
    return new Error("Invalid variant! Valid values: 224, 256, 384, 512");
  }
  return null;
}
function sha3(data2, bits = 512) {
  if (validateBits$1(bits)) {
    return Promise.reject(validateBits$1(bits));
  }
  const hashLength = bits / 8;
  if (wasmCache$c === null || wasmCache$c.hashLength !== hashLength) {
    return lockedCreate(mutex$c, wasmJson$b, hashLength).then((wasm2) => {
      wasmCache$c = wasm2;
      return wasmCache$c.calculate(data2, bits, 6);
    });
  }
  try {
    const hash2 = wasmCache$c.calculate(data2, bits, 6);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA3(bits = 512) {
  if (validateBits$1(bits)) {
    return Promise.reject(validateBits$1(bits));
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$b, outputSize).then((wasm2) => {
    wasm2.init(bits);
    const obj = {
      init: () => {
        wasm2.init(bits);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType, 6),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 200 - 2 * outputSize,
      digestSize: outputSize
    };
    return obj;
  });
}
function validateBits(bits) {
  if (![224, 256, 384, 512].includes(bits)) {
    return new Error("Invalid variant! Valid values: 224, 256, 384, 512");
  }
  return null;
}
function keccak(data2, bits = 512) {
  if (validateBits(bits)) {
    return Promise.reject(validateBits(bits));
  }
  const hashLength = bits / 8;
  if (wasmCache$b === null || wasmCache$b.hashLength !== hashLength) {
    return lockedCreate(mutex$b, wasmJson$b, hashLength).then((wasm2) => {
      wasmCache$b = wasm2;
      return wasmCache$b.calculate(data2, bits, 1);
    });
  }
  try {
    const hash2 = wasmCache$b.calculate(data2, bits, 1);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createKeccak(bits = 512) {
  if (validateBits(bits)) {
    return Promise.reject(validateBits(bits));
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$b, outputSize).then((wasm2) => {
    wasm2.init(bits);
    const obj = {
      init: () => {
        wasm2.init(bits);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType, 1),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 200 - 2 * outputSize,
      digestSize: outputSize
    };
    return obj;
  });
}
function sha224(data2) {
  if (wasmCache$a === null) {
    return lockedCreate(mutex$a, wasmJson$a, 28).then((wasm2) => {
      wasmCache$a = wasm2;
      return wasmCache$a.calculate(data2, 224);
    });
  }
  try {
    const hash2 = wasmCache$a.calculate(data2, 224);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA224() {
  return WASMInterface(wasmJson$a, 28).then((wasm2) => {
    wasm2.init(224);
    const obj = {
      init: () => {
        wasm2.init(224);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 28
    };
    return obj;
  });
}
function sha256(data2) {
  if (wasmCache$9 === null) {
    return lockedCreate(mutex$9, wasmJson$a, 32).then((wasm2) => {
      wasmCache$9 = wasm2;
      return wasmCache$9.calculate(data2, 256);
    });
  }
  try {
    const hash2 = wasmCache$9.calculate(data2, 256);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA256() {
  return WASMInterface(wasmJson$a, 32).then((wasm2) => {
    wasm2.init(256);
    const obj = {
      init: () => {
        wasm2.init(256);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 32
    };
    return obj;
  });
}
function sha384(data2) {
  if (wasmCache$8 === null) {
    return lockedCreate(mutex$8, wasmJson$9, 48).then((wasm2) => {
      wasmCache$8 = wasm2;
      return wasmCache$8.calculate(data2, 384);
    });
  }
  try {
    const hash2 = wasmCache$8.calculate(data2, 384);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA384() {
  return WASMInterface(wasmJson$9, 48).then((wasm2) => {
    wasm2.init(384);
    const obj = {
      init: () => {
        wasm2.init(384);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 128,
      digestSize: 48
    };
    return obj;
  });
}
function sha512(data2) {
  if (wasmCache$7 === null) {
    return lockedCreate(mutex$7, wasmJson$9, 64).then((wasm2) => {
      wasmCache$7 = wasm2;
      return wasmCache$7.calculate(data2, 512);
    });
  }
  try {
    const hash2 = wasmCache$7.calculate(data2, 512);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA512() {
  return WASMInterface(wasmJson$9, 64).then((wasm2) => {
    wasm2.init(512);
    const obj = {
      init: () => {
        wasm2.init(512);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 128,
      digestSize: 64
    };
    return obj;
  });
}
function validateSeed$3(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be a valid 32-bit long unsigned integer.");
  }
  return null;
}
function xxhash32(data2, seed = 0) {
  if (validateSeed$3(seed)) {
    return Promise.reject(validateSeed$3(seed));
  }
  if (wasmCache$6 === null) {
    return lockedCreate(mutex$6, wasmJson$8, 4).then((wasm2) => {
      wasmCache$6 = wasm2;
      return wasmCache$6.calculate(data2, seed);
    });
  }
  try {
    const hash2 = wasmCache$6.calculate(data2, seed);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash32(seed = 0) {
  if (validateSeed$3(seed)) {
    return Promise.reject(validateSeed$3(seed));
  }
  return WASMInterface(wasmJson$8, 4).then((wasm2) => {
    wasm2.init(seed);
    const obj = {
      init: () => {
        wasm2.init(seed);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 16,
      digestSize: 4
    };
    return obj;
  });
}
function validateSeed$2(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
  }
  return null;
}
function writeSeed$2(arr, low, high) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, low, true);
  buffer.setUint32(4, high, true);
}
function xxhash64(data2, seedLow = 0, seedHigh = 0) {
  if (validateSeed$2(seedLow)) {
    return Promise.reject(validateSeed$2(seedLow));
  }
  if (validateSeed$2(seedHigh)) {
    return Promise.reject(validateSeed$2(seedHigh));
  }
  if (wasmCache$5 === null) {
    return lockedCreate(mutex$5, wasmJson$7, 8).then((wasm2) => {
      wasmCache$5 = wasm2;
      writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);
      wasmCache$5.writeMemory(seedBuffer$2);
      return wasmCache$5.calculate(data2);
    });
  }
  try {
    writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);
    wasmCache$5.writeMemory(seedBuffer$2);
    const hash2 = wasmCache$5.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash64(seedLow = 0, seedHigh = 0) {
  if (validateSeed$2(seedLow)) {
    return Promise.reject(validateSeed$2(seedLow));
  }
  if (validateSeed$2(seedHigh)) {
    return Promise.reject(validateSeed$2(seedHigh));
  }
  return WASMInterface(wasmJson$7, 8).then((wasm2) => {
    const instanceBuffer = new Uint8Array(8);
    writeSeed$2(instanceBuffer.buffer, seedLow, seedHigh);
    wasm2.writeMemory(instanceBuffer);
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.writeMemory(instanceBuffer);
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 32,
      digestSize: 8
    };
    return obj;
  });
}
function validateSeed$1(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
  }
  return null;
}
function writeSeed$1(arr, low, high) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, low, true);
  buffer.setUint32(4, high, true);
}
function xxhash3(data2, seedLow = 0, seedHigh = 0) {
  if (validateSeed$1(seedLow)) {
    return Promise.reject(validateSeed$1(seedLow));
  }
  if (validateSeed$1(seedHigh)) {
    return Promise.reject(validateSeed$1(seedHigh));
  }
  if (wasmCache$4 === null) {
    return lockedCreate(mutex$4, wasmJson$6, 8).then((wasm2) => {
      wasmCache$4 = wasm2;
      writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);
      wasmCache$4.writeMemory(seedBuffer$1);
      return wasmCache$4.calculate(data2);
    });
  }
  try {
    writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);
    wasmCache$4.writeMemory(seedBuffer$1);
    const hash2 = wasmCache$4.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash3(seedLow = 0, seedHigh = 0) {
  if (validateSeed$1(seedLow)) {
    return Promise.reject(validateSeed$1(seedLow));
  }
  if (validateSeed$1(seedHigh)) {
    return Promise.reject(validateSeed$1(seedHigh));
  }
  return WASMInterface(wasmJson$6, 8).then((wasm2) => {
    const instanceBuffer = new Uint8Array(8);
    writeSeed$1(instanceBuffer.buffer, seedLow, seedHigh);
    wasm2.writeMemory(instanceBuffer);
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.writeMemory(instanceBuffer);
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 512,
      digestSize: 8
    };
    return obj;
  });
}
function validateSeed(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
  }
  return null;
}
function writeSeed(arr, low, high) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, low, true);
  buffer.setUint32(4, high, true);
}
function xxhash128(data2, seedLow = 0, seedHigh = 0) {
  if (validateSeed(seedLow)) {
    return Promise.reject(validateSeed(seedLow));
  }
  if (validateSeed(seedHigh)) {
    return Promise.reject(validateSeed(seedHigh));
  }
  if (wasmCache$3 === null) {
    return lockedCreate(mutex$3, wasmJson$5, 16).then((wasm2) => {
      wasmCache$3 = wasm2;
      writeSeed(seedBuffer.buffer, seedLow, seedHigh);
      wasmCache$3.writeMemory(seedBuffer);
      return wasmCache$3.calculate(data2);
    });
  }
  try {
    writeSeed(seedBuffer.buffer, seedLow, seedHigh);
    wasmCache$3.writeMemory(seedBuffer);
    const hash2 = wasmCache$3.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash128(seedLow = 0, seedHigh = 0) {
  if (validateSeed(seedLow)) {
    return Promise.reject(validateSeed(seedLow));
  }
  if (validateSeed(seedHigh)) {
    return Promise.reject(validateSeed(seedHigh));
  }
  return WASMInterface(wasmJson$5, 16).then((wasm2) => {
    const instanceBuffer = new Uint8Array(8);
    writeSeed(instanceBuffer.buffer, seedLow, seedHigh);
    wasm2.writeMemory(instanceBuffer);
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.writeMemory(instanceBuffer);
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 512,
      digestSize: 16
    };
    return obj;
  });
}
function ripemd160(data2) {
  if (wasmCache$2 === null) {
    return lockedCreate(mutex$2, wasmJson$4, 20).then((wasm2) => {
      wasmCache$2 = wasm2;
      return wasmCache$2.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$2.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createRIPEMD160() {
  return WASMInterface(wasmJson$4, 20).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 20
    };
    return obj;
  });
}
function calculateKeyBuffer(hasher, key) {
  const { blockSize } = hasher;
  const buf = getUInt8Buffer(key);
  if (buf.length > blockSize) {
    hasher.update(buf);
    const uintArr = hasher.digest("binary");
    hasher.init();
    return uintArr;
  }
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
}
function calculateHmac(hasher, key) {
  hasher.init();
  const { blockSize } = hasher;
  const keyBuf = calculateKeyBuffer(hasher, key);
  const keyBuffer = new Uint8Array(blockSize);
  keyBuffer.set(keyBuf);
  const opad = new Uint8Array(blockSize);
  for (let i = 0; i < blockSize; i++) {
    const v = keyBuffer[i];
    opad[i] = v ^ 92;
    keyBuffer[i] = v ^ 54;
  }
  hasher.update(keyBuffer);
  const obj = {
    init: () => {
      hasher.init();
      hasher.update(keyBuffer);
      return obj;
    },
    update: (data2) => {
      hasher.update(data2);
      return obj;
    },
    digest: ((outputType) => {
      const uintArr = hasher.digest("binary");
      hasher.init();
      hasher.update(opad);
      hasher.update(uintArr);
      return hasher.digest(outputType);
    }),
    save: () => {
      throw new Error("save() not supported");
    },
    load: () => {
      throw new Error("load() not supported");
    },
    blockSize: hasher.blockSize,
    digestSize: hasher.digestSize
  };
  return obj;
}
function createHMAC(hash2, key) {
  if (!hash2 || !hash2.then) {
    throw new Error('Invalid hash function is provided! Usage: createHMAC(createMD5(), "key").');
  }
  return hash2.then((hasher) => calculateHmac(hasher, key));
}
function calculatePBKDF2(digest, salt, iterations, hashLength, outputType) {
  return __awaiter(this, void 0, void 0, function* () {
    const DK = new Uint8Array(hashLength);
    const block1 = new Uint8Array(salt.length + 4);
    const block1View = new DataView(block1.buffer);
    const saltBuffer = getUInt8Buffer(salt);
    const saltUIntBuffer = new Uint8Array(saltBuffer.buffer, saltBuffer.byteOffset, saltBuffer.length);
    block1.set(saltUIntBuffer);
    let destPos = 0;
    const hLen = digest.digestSize;
    const l = Math.ceil(hashLength / hLen);
    let T = null;
    let U = null;
    for (let i = 1; i <= l; i++) {
      block1View.setUint32(salt.length, i);
      digest.init();
      digest.update(block1);
      T = digest.digest("binary");
      U = T.slice();
      for (let j = 1; j < iterations; j++) {
        digest.init();
        digest.update(U);
        U = digest.digest("binary");
        for (let k = 0; k < hLen; k++) {
          T[k] ^= U[k];
        }
      }
      DK.set(T.subarray(0, hashLength - destPos), destPos);
      destPos += hLen;
    }
    if (outputType === "binary") {
      return DK;
    }
    const digestChars = new Uint8Array(hashLength * 2);
    return getDigestHex(digestChars, DK, hashLength);
  });
}
function pbkdf2(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$2(options);
    const hmac = yield createHMAC(options.hashFunction, options.password);
    return calculatePBKDF2(hmac, options.salt, options.iterations, options.hashLength, options.outputType);
  });
}
function scryptInternal(options) {
  return __awaiter(this, void 0, void 0, function* () {
    const { costFactor, blockSize, parallelism, hashLength } = options;
    const SHA256Hasher = createSHA256();
    const blockData = yield pbkdf2({
      password: options.password,
      salt: options.salt,
      iterations: 1,
      hashLength: 128 * blockSize * parallelism,
      hashFunction: SHA256Hasher,
      outputType: "binary"
    });
    const scryptInterface = yield WASMInterface(wasmJson$3, 0);
    const VSize = 128 * blockSize * costFactor;
    const XYSize = 256 * blockSize;
    scryptInterface.setMemorySize(blockData.length + VSize + XYSize);
    scryptInterface.writeMemory(blockData, 0);
    scryptInterface.getExports().scrypt(blockSize, costFactor, parallelism);
    const expensiveSalt = scryptInterface.getMemory().subarray(0, 128 * blockSize * parallelism);
    const outputData = yield pbkdf2({
      password: options.password,
      salt: expensiveSalt,
      iterations: 1,
      hashLength,
      hashFunction: SHA256Hasher,
      outputType: "binary"
    });
    if (options.outputType === "hex") {
      const digestChars = new Uint8Array(hashLength * 2);
      return getDigestHex(digestChars, outputData, hashLength);
    }
    return outputData;
  });
}
function scrypt(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions$1(options);
    return scryptInternal(options);
  });
}
function bcryptInternal(options) {
  return __awaiter(this, void 0, void 0, function* () {
    const { costFactor, password, salt } = options;
    const bcryptInterface = yield WASMInterface(wasmJson$2, 0);
    bcryptInterface.writeMemory(getUInt8Buffer(salt), 0);
    const passwordBuffer = getUInt8Buffer(password);
    bcryptInterface.writeMemory(passwordBuffer, 16);
    const shouldEncode = options.outputType === "encoded" ? 1 : 0;
    bcryptInterface.getExports().bcrypt(passwordBuffer.length, costFactor, shouldEncode);
    const memory = bcryptInterface.getMemory();
    if (options.outputType === "encoded") {
      return intArrayToString(memory, 60);
    }
    if (options.outputType === "hex") {
      const digestChars = new Uint8Array(24 * 2);
      return getDigestHex(digestChars, memory, 24);
    }
    return memory.slice(0, 24);
  });
}
function bcrypt(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateOptions(options);
    return bcryptInternal(options);
  });
}
function bcryptVerify(options) {
  return __awaiter(this, void 0, void 0, function* () {
    validateVerifyOptions(options);
    const { hash: hash2, password } = options;
    const bcryptInterface = yield WASMInterface(wasmJson$2, 0);
    bcryptInterface.writeMemory(getUInt8Buffer(hash2), 0);
    const passwordBuffer = getUInt8Buffer(password);
    bcryptInterface.writeMemory(passwordBuffer, 60);
    return !!bcryptInterface.getExports().bcrypt_verify(passwordBuffer.length);
  });
}
function whirlpool(data2) {
  if (wasmCache$1 === null) {
    return lockedCreate(mutex$1, wasmJson$1, 64).then((wasm2) => {
      wasmCache$1 = wasm2;
      return wasmCache$1.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$1.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createWhirlpool() {
  return WASMInterface(wasmJson$1, 64).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 64
    };
    return obj;
  });
}
function sm3(data2) {
  if (wasmCache === null) {
    return lockedCreate(mutex, wasmJson, 32).then((wasm2) => {
      wasmCache = wasm2;
      return wasmCache.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSM3() {
  return WASMInterface(wasmJson, 32).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 32
    };
    return obj;
  });
}
var name$l, data$l, hash$l, wasmJson$l, Mutex, _a, globalObject, nodeBuffer, textEncoder2, alpha, digit, getUInt8Buffer, base64Chars, base64Lookup, MAX_HEAP, WASM_FUNC_HASH_LENGTH, wasmMutex, wasmModuleCache, mutex$l, wasmCache$l, name$k, data$k, hash$k, wasmJson$k, name$j, data$j, hash$j, wasmJson$j, mutex$k, wasmCache$k, uint32View, validateOptions$3, getHashParameters, validateVerifyOptions$1, name$i, data$i, hash$i, wasmJson$i, mutex$j, wasmCache$j, name$h, data$h, hash$h, wasmJson$h, mutex$i, wasmCache$i, name$g, data$g, hash$g, wasmJson$g, mutex$h, wasmCache$h, name$f, data$f, hash$f, wasmJson$f, mutex$g, wasmCache$g, polyBuffer, name$e, data$e, hash$e, wasmJson$e, mutex$f, wasmCache$f, name$d, data$d, hash$d, wasmJson$d, mutex$e, wasmCache$e, name$c, data$c, hash$c, wasmJson$c, mutex$d, wasmCache$d, name$b, data$b, hash$b, wasmJson$b, mutex$c, wasmCache$c, mutex$b, wasmCache$b, name$a, data$a, hash$a, wasmJson$a, mutex$a, wasmCache$a, mutex$9, wasmCache$9, name$9, data$9, hash$9, wasmJson$9, mutex$8, wasmCache$8, mutex$7, wasmCache$7, name$8, data$8, hash$8, wasmJson$8, mutex$6, wasmCache$6, name$7, data$7, hash$7, wasmJson$7, mutex$5, wasmCache$5, seedBuffer$2, name$6, data$6, hash$6, wasmJson$6, mutex$4, wasmCache$4, seedBuffer$1, name$5, data$5, hash$5, wasmJson$5, mutex$3, wasmCache$3, seedBuffer, name$4, data$4, hash$4, wasmJson$4, mutex$2, wasmCache$2, validateOptions$2, name$3, data$3, hash$3, wasmJson$3, isPowerOfTwo, validateOptions$1, name$2, data$2, hash$2, wasmJson$2, validateOptions, validateHashCharacters, validateVerifyOptions, name$1, data$1, hash$1, wasmJson$1, mutex$1, wasmCache$1, name, data, hash, wasmJson, mutex, wasmCache;
var init_index_esm = __esm({
  "../../node_modules/hash-wasm/dist/index.esm.js"() {
    name$l = "adler32";
    data$l = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAgUEAQECAgYOAn8BQYCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEK6wkGBQBBgAkLCgBBAEEBNgKECAvjCAEHf0EAKAKECCIBQf//A3EhAiABQRB2IQMCQAJAIABBAUcNACACQQAtAIAJaiIBQY+AfGogASABQfD/A0sbIgEgA2oiBEEQdCIFQYCAPGogBSAEQfD/A0sbIAFyIQEMAQsCQAJAAkACQAJAIABBEEkNAEGACSEGIABBsCtJDQFBgAkhBgNAQQAhBQNAIAYgBWoiASgCACIEQf8BcSACaiICIANqIAIgBEEIdkH/AXFqIgJqIAIgBEEQdkH/AXFqIgJqIAIgBEEYdmoiAmogAiABQQRqKAIAIgRB/wFxaiICaiACIARBCHZB/wFxaiICaiACIARBEHZB/wFxaiICaiACIARBGHZqIgJqIAIgAUEIaigCACIEQf8BcWoiAmogAiAEQQh2Qf8BcWoiAmogAiAEQRB2Qf8BcWoiAmogAiAEQRh2aiIEaiAEIAFBDGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiAmohAyAFQRBqIgVBsCtHDQALIANB8f8DcCEDIAJB8f8DcCECIAZBsCtqIQYgAEHQVGoiAEGvK0sNAAsgAEUNBCAAQQ9LDQEMAgsCQCAARQ0AAkACQCAAQQNxIgUNAEGACSEBIAAhBAwBCyAAQXxxIQRBACEBA0AgAiABQYAJai0AAGoiAiADaiEDIAUgAUEBaiIBRw0ACyAFQYAJaiEBCyAAQQRJDQADQCACIAEtAABqIgUgAS0AAWoiBiABLQACaiIAIAFBA2otAABqIgIgACAGIAUgA2pqamohAyABQQRqIQEgBEF8aiIEDQALCyACQY+AfGogAiACQfD/A0sbIANB8f8DcEEQdHIhAQwECwNAIAYoAgAiAUH/AXEgAmoiBCADaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgRqIAQgBkEEaigCACIBQf8BcWoiBGogBCABQQh2Qf8BcWoiBGogBCABQRB2Qf8BcWoiBGogBCABQRh2aiIEaiAEIAZBCGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiBGogBCAGQQxqKAIAIgFB/wFxaiIEaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgJqIQMgBkEQaiEGIABBcGoiAEEPSw0ACyAARQ0BCyAAQX9qIQcCQCAAQQNxIgVFDQAgAEF8cSEAIAUhBCAGIQEDQCACIAEtAABqIgIgA2ohAyABQQFqIQEgBEF/aiIEDQALIAYgBWohBgsgB0EDSQ0AA0AgAiAGLQAAaiIBIAYtAAFqIgQgBi0AAmoiBSAGQQNqLQAAaiICIAUgBCABIANqampqIQMgBkEEaiEGIABBfGoiAA0ACwsgA0Hx/wNwIQMgAkHx/wNwIQILIAIgA0EQdHIhAQtBACABNgKECAsxAQF/QQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwUAQYQICzsAQQBBATYChAggABACQQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwsVAgBBgAgLBAQAAAAAQYQICwQBAAAA";
    hash$l = "02ddbd17";
    wasmJson$l = {
      name: name$l,
      data: data$l,
      hash: hash$l
    };
    Mutex = class {
      constructor() {
        this.mutex = Promise.resolve();
      }
      lock() {
        let begin = () => {
        };
        this.mutex = this.mutex.then(() => new Promise(begin));
        return new Promise((res) => {
          begin = res;
        });
      }
      dispatch(fn) {
        return __awaiter(this, void 0, void 0, function* () {
          const unlock = yield this.lock();
          try {
            return yield Promise.resolve(fn());
          } finally {
            unlock();
          }
        });
      }
    };
    globalObject = getGlobal();
    nodeBuffer = (_a = globalObject.Buffer) !== null && _a !== void 0 ? _a : null;
    textEncoder2 = globalObject.TextEncoder ? new globalObject.TextEncoder() : null;
    alpha = "a".charCodeAt(0) - 10;
    digit = "0".charCodeAt(0);
    getUInt8Buffer = nodeBuffer !== null ? (data2) => {
      if (typeof data2 === "string") {
        const buf = nodeBuffer.from(data2, "utf8");
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
      }
      if (nodeBuffer.isBuffer(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.length);
      }
      if (ArrayBuffer.isView(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      }
      throw new Error("Invalid data type!");
    } : (data2) => {
      if (typeof data2 === "string") {
        return textEncoder2.encode(data2);
      }
      if (ArrayBuffer.isView(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      }
      throw new Error("Invalid data type!");
    };
    base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    base64Lookup = new Uint8Array(256);
    for (let i = 0; i < base64Chars.length; i++) {
      base64Lookup[base64Chars.charCodeAt(i)] = i;
    }
    MAX_HEAP = 16 * 1024;
    WASM_FUNC_HASH_LENGTH = 4;
    wasmMutex = new Mutex();
    wasmModuleCache = /* @__PURE__ */ new Map();
    mutex$l = new Mutex();
    wasmCache$l = null;
    name$k = "argon2";
    data$k = "AGFzbQEAAAABKQVgAX8Bf2AAAX9gEH9/f39/f39/f39/f39/f38AYAR/f39/AGACf38AAwYFAAECAwQFBgEBAoCAAgYIAX8BQZCoBAsHQQQGbWVtb3J5AgASSGFzaF9TZXRNZW1vcnlTaXplAAAOSGFzaF9HZXRCdWZmZXIAAQ5IYXNoX0NhbGN1bGF0ZQAECvEyBVgBAn9BACEBAkAgAEEAKAKICCICRg0AAkAgACACayIAQRB2IABBgIB8cSAASWoiAEAAQX9HDQBB/wHADwtBACEBQQBBACkDiAggAEEQdK18NwOICAsgAcALcAECfwJAQQAoAoAIIgANAEEAPwBBEHQiADYCgAhBACgCiAgiAUGAgCBGDQACQEGAgCAgAWsiAEEQdiAAQYCAfHEgAElqIgBAAEF/Rw0AQQAPC0EAQQApA4gIIABBEHStfDcDiAhBACgCgAghAAsgAAvcDgECfiAAIAQpAwAiECAAKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAMIBAgDCkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgBCAQIAQpAwCFQiiJIhA3AwAgACAQIAApAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAwgECAMKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAEIBAgBCkDAIVCAYk3AwAgASAFKQMAIhAgASkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDSAQIA0pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAEgECABKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACANIBAgDSkDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAIgBikDACIQIAIpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIA4gECAOKQMAhUIgiSIQNwMAIAogECAKKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACACIBAgAikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDiAQIA4pAwCFQjCJIhA3AwAgCiAQIAopAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACADIAcpAwAiECADKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAPIBAgDykDAIVCIIkiEDcDACALIBAgCykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAyAQIAMpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA8gECAPKQMAhUIwiSIQNwMAIAsgECALKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgACAFKQMAIhAgACkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDyAQIA8pAwCFQiCJIhA3AwAgCiAQIAopAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAAgECAAKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAPIBAgDykDAIVCMIkiEDcDACAKIBAgCikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAEgBikDACIQIAEpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAwgECAMKQMAhUIgiSIQNwMAIAsgECALKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACABIBAgASkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDCAQIAwpAwCFQjCJIhA3AwAgCyAQIAspAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACACIAcpAwAiECACKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACANIBAgDSkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAiAQIAIpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA0gECANKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgAyAEKQMAIhAgAykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDiAQIA4pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAQgECAEKQMAhUIoiSIQNwMAIAMgECADKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAOIBAgDikDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBCAQIAQpAwCFQgGJNwMAC98aAQN/QQAhBEEAIAIpAwAgASkDAIU3A5AIQQAgAikDCCABKQMIhTcDmAhBACACKQMQIAEpAxCFNwOgCEEAIAIpAxggASkDGIU3A6gIQQAgAikDICABKQMghTcDsAhBACACKQMoIAEpAyiFNwO4CEEAIAIpAzAgASkDMIU3A8AIQQAgAikDOCABKQM4hTcDyAhBACACKQNAIAEpA0CFNwPQCEEAIAIpA0ggASkDSIU3A9gIQQAgAikDUCABKQNQhTcD4AhBACACKQNYIAEpA1iFNwPoCEEAIAIpA2AgASkDYIU3A/AIQQAgAikDaCABKQNohTcD+AhBACACKQNwIAEpA3CFNwOACUEAIAIpA3ggASkDeIU3A4gJQQAgAikDgAEgASkDgAGFNwOQCUEAIAIpA4gBIAEpA4gBhTcDmAlBACACKQOQASABKQOQAYU3A6AJQQAgAikDmAEgASkDmAGFNwOoCUEAIAIpA6ABIAEpA6ABhTcDsAlBACACKQOoASABKQOoAYU3A7gJQQAgAikDsAEgASkDsAGFNwPACUEAIAIpA7gBIAEpA7gBhTcDyAlBACACKQPAASABKQPAAYU3A9AJQQAgAikDyAEgASkD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";
    hash$k = "e4cdc523";
    wasmJson$k = {
      name: name$k,
      data: data$k,
      hash: hash$k
    };
    name$j = "blake2b";
    data$j = "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";
    hash$j = "c6f286e6";
    wasmJson$j = {
      name: name$j,
      data: data$j,
      hash: hash$j
    };
    mutex$k = new Mutex();
    wasmCache$k = null;
    uint32View = new DataView(new ArrayBuffer(4));
    validateOptions$3 = (options) => {
      var _a2;
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!options.password) {
        throw new Error("Password must be specified");
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
        throw new Error("Password must be specified");
      }
      if (!options.salt) {
        throw new Error("Salt must be specified");
      }
      options.salt = getUInt8Buffer(options.salt);
      if (options.salt.length < 8) {
        throw new Error("Salt should be at least 8 bytes long");
      }
      options.secret = getUInt8Buffer((_a2 = options.secret) !== null && _a2 !== void 0 ? _a2 : "");
      if (!Number.isInteger(options.iterations) || options.iterations < 1) {
        throw new Error("Iterations should be a positive number");
      }
      if (!Number.isInteger(options.parallelism) || options.parallelism < 1) {
        throw new Error("Parallelism should be a positive number");
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 4) {
        throw new Error("Hash length should be at least 4 bytes.");
      }
      if (!Number.isInteger(options.memorySize)) {
        throw new Error("Memory size should be specified.");
      }
      if (options.memorySize < 8 * options.parallelism) {
        throw new Error("Memory size should be at least 8 * parallelism.");
      }
      if (options.outputType === void 0) {
        options.outputType = "hex";
      }
      if (!["hex", "binary", "encoded"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
      }
    };
    getHashParameters = (password, encoded, secret) => {
      const regex = /^\$argon2(id|i|d)\$v=([0-9]+)\$((?:[mtp]=[0-9]+,){2}[mtp]=[0-9]+)\$([A-Za-z0-9+/]+)\$([A-Za-z0-9+/]+)$/;
      const match = encoded.match(regex);
      if (!match) {
        throw new Error("Invalid hash");
      }
      const [, hashType, version, parameters, salt, hash2] = match;
      if (version !== "19") {
        throw new Error(`Unsupported version: ${version}`);
      }
      const parsedParameters = {};
      const paramMap = { m: "memorySize", p: "parallelism", t: "iterations" };
      for (const x of parameters.split(",")) {
        const [n, v] = x.split("=");
        parsedParameters[paramMap[n]] = Number(v);
      }
      return Object.assign(Object.assign({}, parsedParameters), {
        password,
        secret,
        hashType,
        salt: decodeBase64(salt),
        hashLength: getDecodeBase64Length(hash2),
        outputType: "encoded"
      });
    };
    validateVerifyOptions$1 = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (options.hash === void 0 || typeof options.hash !== "string") {
        throw new Error("Hash should be specified");
      }
    };
    name$i = "blake2s";
    data$i = "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";
    hash$i = "5c0ff166";
    wasmJson$i = {
      name: name$i,
      data: data$i,
      hash: hash$i
    };
    mutex$j = new Mutex();
    wasmCache$j = null;
    name$h = "blake3";
    data$h = "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IQEgAkFAaiICQcAASw0ACwsCQEHAACAHQf8BcSIGayIFIAIgBSACSRsiCUUNACAJQQNxIQtBACEFAkAgCUEESQ0AIAAgBmohByAJQfwAcSEIQQAhBQNAIAcgBWoiAkEoaiABIAVqIgotAAA6AAAgAkEpaiAKQQFqLQAAOgAAIAJBKmogCkECai0AADoAACACQStqIApBA2otAAA6AAAgCCAFQQRqIgVHDQALCwJAIAtFDQAgASAFaiEBIAUgBmogAGpBKGohBQNAIAUgAS0AADoAACABQQFqIQEgBUEBaiEFIAtBf2oiCw0ACwsgAC0AaCEHCyAAIAcgCWo6AGggA0HAAGokAAveAwQFfwN+BX8GfiMAQdABayIBJAACQCAAe6ciAkEALQCQigEiA08NAEEALQCKigFBBHIhBCABQShqIQVBACkDmIkBIQBBACkDkIkBIQZBACkDiIkBIQdBACkDgIkBIQggAyEJA0AgASAANwMYIAEgBjcDECABIAc3AwggASAINwMAIAEgA0EFdCIDQdGJAWoiCikDADcDKCABIANB2YkBaiILKQMANwMwIAEgA0HhiQFqIgwpAwA3AzggASADQemJAWoiDSkDADcDQCABIANB8YkBaikDADcDSCABIANB+YkBaikDADcDUCABIANBgYoBaikDADcDWCADQYmKAWopAwAhDiABQcAAOgBoIAEgDjcDYCABQgA3AyAgASAEOgBpIAEgADcDiAEgASAGNwOAASABIAc3A3ggASAINwNwIAFBkAFqIAFB8ABqIAVBwABCACAEQf8BcRACIAEpA7ABIQ4gASkDkAEhDyABKQO4ASEQIAEpA5gBIREgASkDwAEhEiABKQOgASETIA0gASkDyAEgASkDqAGFNwMAIAwgEiAThTcDACALIBAgEYU3AwAgCiAOIA+FNwMAIAlBf2oiCUH/AXEiAyACSw0AC0EAIAk6AJCKAQsgAUHQAWokAAvHCQIKfwV+IwBB4AJrIgUkAAJAAkAgAUGACEsNACAFIAA2AvwBIAVB/AFqIAFBgAhGIgZBECACQQEgA0EBQQIgBBABIAZBCnQiByABTw0BIAVB4ABqIgZCADcDACAFQdgAaiIIQgA3AwAgBUHQAGoiCUIANwMAIAVByABqIgpCADcDACAFQcAAaiILQgA3AwAgBUE4aiIMQgA3AwAgBUEwaiINQgA3AwAgBSADOgBqIAVCADcDKCAFQQA7AWggBUEAKQOAiQE3AwAgBUEAKQOIiQE3AwggBUEAKQOQiQE3AxAgBUEAKQOYiQE3AxggBSABQYAIRiIOrSACfDcDICAFIAAgB2pBACABIA4bEAQgBUGIAWpBMGogDSkDADcDACAFQYgBakE4aiAMKQMANwMAIAUgBSkDACIPNwOIASAFIAUpAwgiEDcDkAEgBSAFKQMQIhE3A5gBIAUgBSkDGCISNwOgASAFIAUpAyg3A7ABIAUtAGohACAFLQBpIQcgBSkDICECIAUtAGghASAFQYgBakHAAGogCykDADcDACAFQYgBakHIAGogCikDADcDACAFQYgBakHQAGogCSkDADcDACAFQYgBakHYAGogCCkDADcDACAFQYgBakHgAGogBikDADcDACAFIAE6APABIAUgAjcDqAEgBSAAIAdFckECciIAOgDxASAFIBI3A5gCIAUgETcDkAIgBSAQNwOIAiAFIA83A4ACIAVBoAJqIAVBgAJqIAVBsAFqIAEgAiAAQf8BcRACIAUpA8ACIQIgBSkDoAIhDyAFKQPIAiEQIAUpA6gCIREgBSkD0AIhEiAFKQOwAiETIAQgDkEFdGoiASAFKQPYAiAFKQO4AoU3AxggASASIBOFNwMQIAEgECARhTcDCCABIAIgD4U3AwBBAkEBIA4bIQYMAQsgAEIBIAFBf2pBCnZBAXKteUI/hYYiD6dBCnQiDiACIAMgBRAGIQcgACAOaiABIA5rIA9C////AYMgAnwgAyAFQcAAQSAgDkGACEsbahAGIQECQCAHQQFHDQAgBCAFKQMANwMAIAQgBSkDCDcDCCAEIAUpAxA3AxAgBCAFKQMYNwMYIAQgBSkDIDcDICAEIAUpAyg3AyggBCAFKQMwNwMwIAQgBSkDODcDOEECIQYMAQtBACEGQQAhAAJAIAEgB2oiCUECSQ0AIAlBfmoiCkEBdkEBaiIGQQNxIQ5BACEHAkAgCkEGSQ0AIAZB/P///wdxIQhBACEHIAVBiAFqIQEgBSEAA0AgASAANgIAIAFBDGogAEHAAWo2AgAgAUEIaiAAQYABajYCACABQQRqIABBwABqNgIAIABBgAJqIQAgAUEQaiEBIAggB0EEaiIHRw0ACwsgCkF+cSEIAkAgDkUNACAFIAdBBnRqIQEgBUGIAWogB0ECdGohAANAIAAgATYCACABQcAAaiEBIABBBGohACAOQX9qIg4NAAsLIAhBAmohAAsgBUGIAWogBkEBQgBBACADQQRyQQBBACAEEAEgACAJTw0AIAQgBkEFdGoiASAFIAZBBnRqIgApAwA3AwAgASAAKQMINwMIIAEgACkDEDcDECABIAApAxg3AxggBkEBaiEGCyAFQeACaiQAIAYLrRAIAn8EfgF/AX4EfwR+BH8EfiMAQfABayIBJAACQCAARQ0AAkBBAC0AkIoBIgINACABQTBqQQApA9CJATcDACABQThqQQApA9iJATcDACABQQApA6CJASIDNwMAIAFBACkDqIkBIgQ3AwggAUEAKQOwiQEiBTcDECABQQApA7iJASIGNwMYIAFBACkDyIkBNwMoQQAtAIqKASECQQAtAImKASEHQQApA8CJASEIQQAtAIiKASEJIAFBwABqQQApA+CJATcDACABQcgAakEAKQPoiQE3AwAgAUHQAGpBACkD8IkBNwMAIAFB2ABqQQApA/iJATcDACABQeAAakEAKQOAigE3AwAgASAJOgBoIAEgCDcDICABIAIgB0VyIgJBAnI6AGkgAUEoaiEKQgAhCEGACSELIAJBCnJB/wFxIQwDQCABQbABaiABIAogCUH/AXEgCCAMEAIgASABKQPQASINIAEpA7ABhTcDcCABIAEpA9gBIg4gASkDuAGFNwN4IAEgASkD4AEiDyABKQPAAYU3A4ABIAEgASkD6AEiECAGhTcDqAEgASAPIAWFNwOgASABIA4gBIU3A5gBIAEgDSADhTcDkAEgASAQIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQAMAgsLAkACQAJAQQAtAImKASIHQQZ0QQBBAC0AiIoBIhFrRg0AIAEgEToAaCABQQApA4CKATcDYCABQQApA/iJATcDWCABQQApA/CJATcDUCABQQApA+iJATcDSCABQQApA+CJATcDQCABQQApA9iJATcDOCABQQApA9CJATcDMCABQQApA8iJATcDKCABQQApA8CJASIINwMgIAFBACkDuIkBIgM3AxggAUEAKQOwiQEiBDcDECABQQApA6iJASIFNwMIIAFBACkDoIkBIgY3AwAgAUEALQCKigEiEyAHRXJBAnIiCzoAaSATQQRyIRNBACkDmIkBIQ1BACkDkIkBIQ5BACkDiIkBIQ9BACkDgIkBIRAMAQtBwAAhESABQcAAOgBoQgAhCCABQgA3AyAgAUEAKQOYiQEiDTcDGCABQQApA5CJASIONwMQIAFBACkDiIkBIg83AwggAUEAKQOAiQEiEDcDACABQQAtAIqKAUEEciITOgBpIAEgAkF+aiICQQV0IgdByYoBaikDADcDYCABIAdBwYoBaikDADcDWCABIAdBuYoBaikDADcDUCABIAdBsYoBaikDADcDSCABIAdBqYoBaikDADcDQCABIAdBoYoBaikDADcDOCABIAdBmYoBaikDADcDMCABIAdBkYoBaikDADcDKCATIQsgECEGIA8hBSAOIQQgDSEDIAJFDQELIAJBf2oiB0EFdCIUQZGKAWopAwAhFSAUQZmKAWopAwAhFiAUQaGKAWopAwAhFyAUQamKAWopAwAhGCABIAM3A4gBIAEgBDcDgAEgASAFNwN4IAEgBjcDcCABQbABaiABQfAAaiABQShqIhQgESAIIAtB/wFxEAIgASATOgBpIAFBwAA6AGggASAYNwNAIAEgFzcDOCABIBY3AzAgASAVNwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggB0UNACACQQV0QemJAWohAiATQf8BcSERA0AgAkFoaikDACEIIAJBcGopAwAhAyACQXhqKQMAIQQgAikDACEFIAEgDTcDiAEgASAONwOAASABIA83A3ggASAQNwNwIAFBsAFqIAFB8ABqIBRBwABCACAREAIgASATOgBpIAFBwAA6AGggASAFNwNAIAEgBDcDOCABIAM3AzAgASAINwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggAkFgaiECIAdBf2oiBw0ACwsgAUEoaiEJQgAhCEGACSELIBNBCHJB/wFxIQoDQCABQbABaiABIAlBwAAgCCAKEAIgASABKQPQASIDIAEpA7ABhTcDcCABIAEpA9gBIgQgASkDuAGFNwN4IAEgASkD4AEiBSABKQPAAYU3A4ABIAEgDSABKQPoASIGhTcDqAEgASAOIAWFNwOgASABIA8gBIU3A5gBIAEgECADhTcDkAEgASAGIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQALCyABQfABaiQAC6MCAQR+AkACQCAAQSBGDQBCq7OP/JGjs/DbACEBQv+kuYjFkdqCm38hAkLy5rvjo6f9p6V/IQNC58yn0NbQ67O7fyEEQQAhAAwBC0EAKQOYCSEBQQApA5AJIQJBACkDiAkhA0EAKQOACSEEQRAhAAtBACAAOgCKigFBAEIANwOAigFBAEIANwP4iQFBAEIANwPwiQFBAEIANwPoiQFBAEIANwPgiQFBAEIANwPYiQFBAEIANwPQiQFBAEIANwPIiQFBAEIANwPAiQFBACABNwO4iQFBACACNwOwiQFBACADNwOoiQFBACAENwOgiQFBACABNwOYiQFBACACNwOQiQFBACADNwOIiQFBACAENwOAiQFBAEEAOgCQigFBAEEAOwGIigELBgAgABADCwYAIAAQBwsGAEGAiQELqwIBBH4CQAJAIAFBIEYNAEKrs4/8kaOz8NsAIQNC/6S5iMWR2oKbfyEEQvLmu+Ojp/2npX8hBULnzKfQ1tDrs7t/IQZBACEBDAELQQApA5gJIQNBACkDkAkhBEEAKQOICSEFQQApA4AJIQZBECEBC0EAIAE6AIqKAUEAQgA3A4CKAUEAQgA3A/iJAUEAQgA3A/CJAUEAQgA3A+iJAUEAQgA3A+CJAUEAQgA3A9iJAUEAQgA3A9CJAUEAQgA3A8iJAUEAQgA3A8CJAUEAIAM3A7iJAUEAIAQ3A7CJAUEAIAU3A6iJAUEAIAY3A6CJAUEAIAM3A5iJAUEAIAQ3A5CJAUEAIAU3A4iJAUEAIAY3A4CJAUEAQQA6AJCKAUEAQQA7AYiKASAAEAMgAhAHCwsLAQBBgAgLBHgHAAA=";
    hash$h = "215d875f";
    wasmJson$h = {
      name: name$h,
      data: data$h,
      hash: hash$h
    };
    mutex$i = new Mutex();
    wasmCache$i = null;
    name$g = "crc32";
    data$g = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQZDJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAgtIYXNoX1VwZGF0ZQADCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKkggHBQBBgAkLwwMBA39BgIkBIQFBACECA0AgAUEAQQBBAEEAQQBBAEEAQQAgAkEBcWsgAHEgAkEBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnM2AgAgAUEEaiEBIAJBAWoiAkGAAkcNAAtBACEAA0AgAEGEkQFqIABBhIkBaigCACICQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEmQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYShAWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhKkBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEsQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYS5AWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhMEBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzNgIAIABBBGoiAEH8B0cNAAsLJwACQEEAKAKAyQEgAEYNACAAEAFBACAANgKAyQELQQBBADYChMkBC4gDAQN/QQAoAoTJAUF/cyEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAJBBGooAgAiA0EOdkH8B3FBgJEBaigCACADQRZ2QfwHcUGAiQFqKAIAcyADQQZ2QfwHcUGAmQFqKAIAcyADQf8BcUECdEGAoQFqKAIAcyACKAIAIAFzIgFBFnZB/AdxQYCpAWooAgBzIAFBDnZB/AdxQYCxAWooAgBzIAFBBnZB/AdxQYC5AWooAgBzIAFB/wFxQQJ0QYDBAWooAgBzIQEgAkEIaiECIABBeGoiAEEHSw0ACwsCQCAARQ0AAkACQCAAQQFxDQAgACEDDAELIAFB/wFxIAItAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQFqIQIgAEF/aiEDCyAAQQFGDQADQCABQf8BcSACLQAAc0ECdEGAiQFqKAIAIAFBCHZzIgFB/wFxIAJBAWotAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQJqIQIgA0F+aiIDDQALC0EAIAFBf3M2AoTJAQsyAQF/QQBBACgChMkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgKACQsGAEGEyQELWQACQEEAKAKAyQEgAUYNACABEAFBACABNgKAyQELQQBBADYChMkBIAAQA0EAQQAoAoTJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAkLCwsBAEGACAsEBAAAAA==";
    hash$g = "d2eba587";
    wasmJson$g = {
      name: name$g,
      data: data$g,
      hash: hash$g
    };
    mutex$h = new Mutex();
    wasmCache$h = null;
    name$f = "crc64";
    data$f = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAQUEAQECAgYOAn8BQZCJBgt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEKgwgGBQBBgAkL9QMDAX4BfwJ+AkBBACkDgIkCQQApA4AJIgBRDQBBgIkBIQFCACECA0AgAUIAQgBCAEIAQgBCAEIAQgAgAkIBg30gAIMgAkIBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIU3AwAgAUEIaiEBIAJCAXwiAkKAAlINAAtBACEBA0AgAUGImQFqIAFBiIkBaikDACICp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiKkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiLkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiMkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiNkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiOkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiPkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhTcDACABQQhqIgFB+A9HDQALQQAgADcDgIkCC0EAQgA3A4iJAguUAwIBfgJ/QQApA4iJAkJ/hSEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAIpAwAgAYUiAUIwiKdB/wFxQQN0QYCZAWopAwAgAUI4iKdBA3RBgIkBaikDAIUgAUIoiKdB/wFxQQN0QYCpAWopAwCFIAFCIIinQf8BcUEDdEGAuQFqKQMAhSABpyIDQRV2QfgPcUGAyQFqKQMAhSADQQ12QfgPcUGA2QFqKQMAhSADQQV2QfgPcUGA6QFqKQMAhSADQf8BcUEDdEGA+QFqKQMAhSEBIAJBCGohAiAAQXhqIgBBB0sNAAsLAkAgAEUNAAJAAkAgAEEBcQ0AIAAhAwwBCyABQv8BgyACMQAAhadBA3RBgIkBaikDACABQgiIhSEBIAJBAWohAiAAQX9qIQMLIABBAUYNAANAIAFC/wGDIAIxAACFp0EDdEGAiQFqKQMAIAFCCIiFIgFC/wGDIAJBAWoxAACFp0EDdEGAiQFqKQMAIAFCCIiFIQEgAkECaiECIANBfmoiAw0ACwtBACABQn+FNwOIiQILZAEBfkEAQQApA4iJAiIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwOACQsGAEGIiQILAgALCwsBAEGACAsECAAAAA==";
    hash$f = "c5ac6c16";
    wasmJson$f = {
      name: name$f,
      data: data$f,
      hash: hash$f
    };
    mutex$g = new Mutex();
    wasmCache$g = null;
    polyBuffer = new Uint8Array(8);
    name$e = "md4";
    data$e = "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";
    hash$e = "bd8ce7c7";
    wasmJson$e = {
      name: name$e,
      data: data$e,
      hash: hash$e
    };
    mutex$f = new Mutex();
    wasmCache$f = null;
    name$d = "md5";
    data$d = "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";
    hash$d = "e6508e4b";
    wasmJson$d = {
      name: name$d,
      data: data$d,
      hash: hash$d
    };
    mutex$e = new Mutex();
    wasmCache$e = null;
    name$c = "sha1";
    data$c = "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";
    hash$c = "6b530c24";
    wasmJson$c = {
      name: name$c,
      data: data$c,
      hash: hash$c
    };
    mutex$d = new Mutex();
    wasmCache$d = null;
    name$b = "sha3";
    data$b = "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";
    hash$b = "fb24e536";
    wasmJson$b = {
      name: name$b,
      data: data$b,
      hash: hash$b
    };
    mutex$c = new Mutex();
    wasmCache$c = null;
    mutex$b = new Mutex();
    wasmCache$b = null;
    name$a = "sha256";
    data$a = "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c2pBx6KerX1qIhkgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAaaiICaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakHRxqk2aiIaIAIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGGoiA2oiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pB59KkoQFqIhggAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAUaiIBaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGFldy9AmoiFCABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBdqIgJqIhMgI2ogJiASaiAiIBFqICUgCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBuMLs8AJqIhcgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAZaiIDaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakH827HpBGoiGSADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBpqIgFqIhEgCSATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQZOa4JkFaiIaIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGGoiAmoiEiARIAlzcSAJc2ogEkEadyASQRV3cyASQQd3c2pB1OapqAZqIhggAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAUaiIDaiITaiAoIBJqICQgEWogJyAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakG7laizB2oiFCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBdqIgFqIgkgEyASc3EgEnNqIAlBGncgCUEVd3MgCUEHd3NqQa6Si454aiIXIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGWoiAmoiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pBhdnIk3lqIhkgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAaaiIDaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGh0f+VemoiGiADIAJz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";
    hash$a = "8c18dd94";
    wasmJson$a = {
      name: name$a,
      data: data$a,
      hash: hash$a
    };
    mutex$a = new Mutex();
    wasmCache$a = null;
    mutex$9 = new Mutex();
    wasmCache$9 = null;
    name$9 = "sha512";
    data$9 = "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";
    hash$9 = "f2e40eb1";
    wasmJson$9 = {
      name: name$9,
      data: data$9,
      hash: hash$9
    };
    mutex$8 = new Mutex();
    wasmCache$8 = null;
    mutex$7 = new Mutex();
    wasmCache$7 = null;
    name$8 = "xxhash32";
    data$8 = "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";
    hash$8 = "4bb12485";
    wasmJson$8 = {
      name: name$8,
      data: data$8,
      hash: hash$8
    };
    mutex$6 = new Mutex();
    wasmCache$6 = null;
    name$7 = "xxhash64";
    data$7 = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAQUEAQECAgYOAn8BQdCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEKmxEGBQBBgAkLYwEBfkEAQgA3A8iJAUEAQQApA4AJIgA3A5CJAUEAIABC+erQ0OfJoeThAHw3A5iJAUEAIABCz9bTvtLHq9lCfDcDiIkBQQAgAELW64Lu6v2J9eAAfDcDgIkBQQBBADYCwIkBC70IAwV/BH4CfwJAIABFDQBBAEEAKQPIiQEgAK18NwPIiQECQEEAKALAiQEiASAAakEfSw0AAkACQCAAQQNxIgINAEGACSEDIAAhAQwBCyAAQXxxIQFBgAkhAwNAQQBBACgCwIkBIgRBAWo2AsCJASAEQaCJAWogAy0AADoAACADQQFqIQMgAkF/aiICDQALCyAAQQRJDQEDQEEAQQAoAsCJASICQQFqNgLAiQEgAkGgiQFqIAMtAAA6AAAgA0EBai0AACECQQBBACgCwIkBIgRBAWo2AsCJASAEQaCJAWogAjoAACADQQJqLQAAIQJBAEEAKALAiQEiBEEBajYCwIkBIARBoIkBaiACOgAAIANBA2otAAAhAkEAQQAoAsCJASIEQQFqNgLAiQEgBEGgiQFqIAI6AAAgA0EEaiEDIAFBfGoiAQ0ADAILCyAAQeAIaiEFAkACQCABDQBBACkDmIkBIQZBACkDkIkBIQdBACkDiIkBIQhBACkDgIkBIQlBgAkhAwwBC0GACSEDAkAgAUEfSw0AQYAJIQMCQAJAQQAgAWtBA3EiBA0AIAEhAgwBCyABIQIDQCACQaCJAWogAy0AADoAACACQQFqIQIgA0EBaiEDIARBf2oiBA0ACwsgAUFjakEDSQ0AQSAgAmshCkEAIQQDQCACIARqIgFBoIkBaiADIARqIgstAAA6AAAgAUGhiQFqIAtBAWotAAA6AAAgAUGiiQFqIAtBAmotAAA6AAAgAUGjiQFqIAtBA2otAAA6AAAgCiAEQQRqIgRHDQALIAMgBGohAwtBAEEAKQOgiQFCz9bTvtLHq9lCfkEAKQOAiQF8Qh+JQoeVr6+Ytt6bnn9+Igk3A4CJAUEAQQApA6iJAULP1tO+0ser2UJ+QQApA4iJAXxCH4lCh5Wvr5i23puef34iCDcDiIkBQQBBACkDsIkBQs/W077Sx6vZQn5BACkDkIkBfEIfiUKHla+vmLbem55/fiIHNwOQiQFBAEEAKQO4iQFCz9bTvtLHq9lCfkEAKQOYiQF8Qh+JQoeVr6+Ytt6bnn9+IgY3A5iJAQsgAEGACWohAgJAIAMgBUsNAANAIAMpAwBCz9bTvtLHq9lCfiAJfEIfiUKHla+vmLbem55/fiEJIANBGGopAwBCz9bTvtLHq9lCfiAGfEIfiUKHla+vmLbem55/fiEGIANBEGopAwBCz9bTvtLHq9lCfiAHfEIfiUKHla+vmLbem55/fiEHIANBCGopAwBCz9bTvtLHq9lCfiAIfEIfiUKHla+vmLbem55/fiEIIANBIGoiAyAFTQ0ACwtBACAGNwOYiQFBACAHNwOQiQFBACAINwOIiQFBACAJNwOAiQFBACACIANrNgLAiQEgAiADRg0AQQAhAgNAIAJBoIkBaiADIAJqLQAAOgAAIAJBAWoiAkEAKALAiQFJDQALCwvlBwIFfgV/AkACQEEAKQPIiQEiAEIgVA0AQQApA4iJASIBQgeJQQApA4CJASICQgGJfEEAKQOQiQEiA0IMiXxBACkDmIkBIgRCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35C49zKlfzO8vWFf3wgAULP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCADQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+QuPcypX8zvL1hX98IARCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35C49zKlfzO8vWFf3whAQwBC0EAKQOQiQFCxc/ZsvHluuonfCEBCyABIAB8IQBBoIkBIQVBqIkBIQYCQEEAKALAiQEiB0GgiQFqIghBqIkBSQ0AQaCJASEFAkAgB0F4aiIJQQhxDQBBACkDoIkBQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef34gAIVCG4lCh5Wvr5i23puef35C49zKlfzO8vWFf3whAEGwiQEhBkGoiQEhBSAJQQhJDQELA0AgBikDAELP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+IAUpAwBCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/fiAAhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fIVCG4lCh5Wvr5i23puef35C49zKlfzO8vWFf3whACAGQQhqIQUgBkEQaiIGIAhNDQALIAZBeGohBQsCQAJAIAVBBGoiCSAITQ0AIAUhCQwBCyAFNQIAQoeVr6+Ytt6bnn9+IACFQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCEACwJAIAkgCEYNACAHQZ+JAWohBQJAAkAgByAJa0EBcQ0AIAkhBgwBCyAJQQFqIQYgCTEAAELFz9my8eW66id+IACFQguJQoeVr6+Ytt6bnn9+IQALIAUgCUYNAANAIAZBAWoxAABCxc/ZsvHluuonfiAGMQAAQsXP2bLx5brqJ34gAIVCC4lCh5Wvr5i23puef36FQguJQoeVr6+Ytt6bnn9+IQAgBkECaiIGIAhHDQALC0EAIABCIYggAIVCz9bTvtLHq9lCfiIAQh2IIACFQvnz3fGZ9pmrFn4iAEIgiCAAhSIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwOACQsGAEGAiQELAgALCwsBAEGACAsEUAAAAA==";
    hash$7 = "177fbfa3";
    wasmJson$7 = {
      name: name$7,
      data: data$7,
      hash: hash$7
    };
    mutex$5 = new Mutex();
    wasmCache$5 = null;
    seedBuffer$2 = new Uint8Array(8);
    name$6 = "xxhash3";
    data$6 = "AGFzbQEAAAABNAhgAAF/YAR/f39/AGAHf39/f39/fwBgBH9+fn4BfmAEf39/fgF+YAN/f34BfmAAAGABfwADDg0AAQIDBAUFBQYHBgAGBQQBAQICBg4CfwFBwI4FC38AQcAJCwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAAIC0hhc2hfVXBkYXRlAAkKSGFzaF9GaW5hbAAKDUhhc2hfR2V0U3RhdGUACw5IYXNoX0NhbGN1bGF0ZQAMClNUQVRFX1NJWkUDAQr6QQ0FAEGACgvkAwMPfgF/AX4CQCADRQ0AIAApAzAhBCAAKQM4IQUgACkDICEGIAApAyghByAAKQMQIQggACkDGCEJIAApAwAhCiAAKQMIIQsDQCAFIAFBMGopAwAiDHwgAkE4aikDACABQThqKQMAIg2FIgVCIIggBUL/////D4N+fCEFIAcgAUEgaikDACIOfCACQShqKQMAIAFBKGopAwAiD4UiB0IgiCAHQv////8Pg358IQcgCSABQRBqKQMAIhB8IAJBGGopAwAgAUEYaikDACIRhSIJQiCIIAlC/////w+DfnwhCSALIAEpAwAiEnwgAkEIaiITKQMAIAFBCGopAwAiFIUiC0IgiCALQv////8Pg358IQsgAkEwaikDACAMhSIMQiCIIAxC/////w+DfiAEfCANfCEEIAJBIGopAwAgDoUiDEIgiCAMQv////8Pg34gBnwgD3whBiACQRBqKQMAIBCFIgxCIIggDEL/////D4N+IAh8IBF8IQggAikDACAShSIMQiCIIAxC/////w+DfiAKfCAUfCEKIAFBwABqIQEgEyECIANBf2oiAw0ACyAAIAk3AxggACAKNwMAIAAgCzcDCCAAIAc3AyggACAINwMQIAAgBTcDOCAAIAY3AyAgACAENwMwCwveAgIBfwF+AkAgBCACIAEoAgAiB2siAkkNACAAIAMgBSAHQQN0aiACEAEgACAFIAZqIgcpAwAgACkDACIIQi+IhSAIhUKx893xCX43AwAgACAHKQMIIAApAwgiCEIviIUgCIVCsfPd8Ql+NwMIIAAgBykDECAAKQMQIghCL4iFIAiFQrHz3fEJfjcDECAAIAcpAxggACkDGCIIQi+IhSAIhUKx893xCX43AxggACAHKQMgIAApAyAiCEIviIUgCIVCsfPd8Ql+NwMgIAAgBykDKCAAKQMoIghCL4iFIAiFQrHz3fEJfjcDKCAAIAcpAzAgACkDMCIIQi+IhSAIhUKx893xCX43AzAgACAHKQM4IAApAzgiCEIviIUgCIVCsfPd8Ql+NwM4IAAgAyACQQZ0aiAFIAQgAmsiBxABIAEgBzYCAA8LIAAgAyAFIAdBA3RqIAQQASABIAcgBGo2AgALhQEBAX8gAiABhSADpyIEQRh0IARBgP4DcUEIdHIgBEEIdkGA/gNxIARBGHZycq1CIIYgA4V9QQA1AoCMAUIghiAAQfyLAWo1AgCEhSIDQjGJIANCGImFIAOFQqW+4/TRjIfZn39+IgNCI4ggAK18IAOFQqW+4/TRjIfZn39+IgNCHIggA4ULZwAgAiABc60gA3wiA0IhiEEALQCAjAFBEHQgAEEIdHIgAEEBdkGAjAFqLQAAQRh0ciAAQf+LAWotAAByrYUgA4VCz9bTvtLHq9lCfiIDQh2IIAOFQvnz3fGZ9pmrFn4iA0IgiCADhQuJAwEEfgJAIABBCUkNAEEAKQOAjAEgASkDICABKQMYhSACfIUiA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhCAArXwgAEH4iwFqKQMAIAEpAzAgASkDKIUgAn2FIgJ8IAJC/////w+DIgQgA0IgiCIFfiIGQv////8PgyACQiCIIgIgA0L/////D4MiA358IAQgA34iA0IgiHwiBEIghiADQv////8Pg4QgBkIgiCACIAV+fCAEQiCIfIV8IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFDwsCQCAAQQRJDQAgACABQQhqKQMAIAFBEGopAwAgAhADDwsCQCAARQ0AIAAgASgCACABQQRqKAIAIAIQBA8LIAEpAzggASkDQIUgAoUiA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC94IAQZ+IACtQoeVr6+Ytt6bnn9+IQMCQCAAQSFJDQACQCAAQcEASQ0AAkAgAEHhAEkNACABKQNoIAJ9QQApA7iMAYUiBEL/////D4MiBSABKQNgIAJ8QQApA7CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDeCACfSAAQciLAWopAwCFIgNC/////w+DIgQgASkDcCACfCAAQcCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQNIIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQNAIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDWCACfSAAQdiLAWopAwCFIgNC/////w+DIgQgASkDUCACfCAAQdCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMoIAJ9QQApA5iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA5CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDOCACfSAAQeiLAWopAwCFIgNC/////w+DIgQgASkDMCACfCAAQeCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMIIAJ9QQApA4iMAYUiBEL/////D4MiBSABKQMAIAJ8QQApA4CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDGCACfSAAQfiLAWopAwCFIgNC/////w+DIgQgASkDECACfCAAQfCLAWopAwCFIgJCIIgiBX4iBkL/////D4MgA0IgiCIDIAJC/////w+DIgJ+fCAEIAJ+IgJCIIh8IgRCIIYgAkL/////D4OEIAZCIIggAyAFfnwgBEIgiHyFfCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQv8CgQBfwV+An8BfkEAIQMgASkDeCACfUEAKQP4jAGFIgRC/////w+DIgUgASkDcCACfEEAKQPwjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpA2ggAn1BACkD6IwBhSIEQv////8PgyIFIAEpA2AgAnxBACkD4IwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQNYIAJ9QQApA9iMAYUiBEL/////D4MiBSABKQNQIAJ8QQApA9CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDSCACfUEAKQPIjAGFIgRC/////w+DIgUgASkDQCACfEEAKQPAjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAzggAn1BACkDuIwBhSIEQv////8PgyIFIAEpAzAgAnxBACkDsIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQMoIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDGCACfUEAKQOYjAGFIgRC/////w+DIgUgASkDECACfEEAKQOQjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAwggAn1BACkDiIwBhSIEQv////8PgyIFIAEpAwAgAnxBACkDgIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSAArUKHla+vmLbem55/fnx8fHx8fHx8IgRCJYggBIVC+fPd8ZnymasWfiIEQiCIIASFIQQCQCAAQZABSA0AIABBBHZBeGohCQNAIAEgA2oiCkELaikDACACfSADQYiNAWopAwCFIgVC/////w+DIgYgCkEDaikDACACfCADQYCNAWopAwCFIgdCIIgiCH4iC0L/////D4MgBUIgiCIFIAdC/////w+DIgd+fCAGIAd+IgZCIIh8IgdCIIYgBkL/////D4OEIAtCIIggBSAIfnwgB0IgiHyFIAR8IQQgA0EQaiEDIAlBf2oiCQ0ACwsgASkDfyACfSAAQfiLAWopAwCFIgVC/////w+DIgYgASkDdyACfCAAQfCLAWopAwCFIgJCIIgiB34iCEL/////D4MgBUIgiCIFIAJC/////w+DIgJ+fCAGIAJ+IgJCIIh8IgZCIIYgAkL/////D4OEIAhCIIggBSAHfnwgBkIgiHyFIAR8IgJCJYggAoVC+fPd8ZnymasWfiICQiCIIAKFC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAA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QQApA4CKATcDACACQQApA4iKATcDCCACQQApA5CKATcDECACQQApA5iKATcDGCACQQApA6CKATcDICACQQApA6iKATcDKCACQQApA7CKASIFNwMwIAJBACkDuIoBIgY3AzgCQAJAQQAoAoCOASIHQcAASQ0AIAJBACgCiI4BNgJAIAIgAkHAAGpBACgCmI4BQYCMASAHQX9qQQZ2IANBACgCnI4BIgAQAiADIABqIgBBeWopAwAhCCAAKQMJIQkgACkDGSEKIAApAykhCyAHQcCLAWopAwAhBSAAKQMBIQwgB0HIiwFqKQMAIQYgB0HQiwFqKQMAIQ0gACkDESEOIAdB2IsBaikDACEPIAdB4IsBaikDACEQIAApAyEhESAHQeiLAWopAwAhEiACKQMAIRMgAikDECEUIAIpAyAhFSACKQMwIRYgAikDCCEXIAIpAxghGCACKQMoIRkgAiACKQM4IAdB8IsBaikDACIafCAAKQMxIAdB+IsBaikDACIbhSIcQiCIIBxC/////w+Dfnw3AzggGSAQfCARIBKFIhFCIIggEUL/////D4N+fCERIBggDXwgDiAPhSIOQiCIIA5C/////w+DfnwhDiAXIAV8IAwgBoUiDEIgiCAMQv////8Pg358IQwgGyAWIAsgGoUiC0IgiCALQv////8Pg358fCELIBIgFSAKIBCFIhBCIIggEEL/////D4N+fHwhECAPIBQgCSANhSINQiCIIA1C/////w+Dfnx8IRIgBiATIAggBYUiBUIgiCAFQv////8Pg358fCEIDAELIAdBwI0BaiEdQcAAIAdrIR4gAkHAAGohAAJAAkACQCAHQThNDQAgHiEfDAELAkACQEE4IAdrQQN2QQFqQQdxIh8NACACQcAAaiEAIB4hHwwBCyACQcAAaiEAIB9BA3QiICEfA0AgACAdKQMANwMAIABBCGohACAdQQhqIR0gH0F4aiIfDQALQcAAIAcgIGprIR8LAkAgBw0AA0AgACAdKQMANwMAIABBCGogHUEIaikDADcDACAAQRBqIB1BEGopAwA3AwAgAEEYaiAdQRhqKQMANwMAIABBIGogHUEgaikDADcDACAAQShqIB1BKGopAwA3AwAgAEEwaiAdQTBqKQMANwMAIABBOGogHUE4aikDADcDACAAQcAAaiEAIB1BwABqIR0gH0FAaiIfQQdLDQALCyAfRQ0BCyAfQX9qISECQCAfQQdxIiBFDQAgH0F4cSEfA0AgACAdLQAAOgAAIABBAWohACAdQQFqIR0gIEF/aiIgDQALCyAhQQdJDQADQCAAIB0pAAA3AAAgAEEIaiEAIB1BCGohHSAfQXhqIh8NAAsLIAJBwABqIB5qIR1BgIwBIQACQAJAAkAgB0EISQ0AAkAgB0E4akEDdkEBakEHcSIfDQAMAgsgH0EDdCEgQYCMASEAA0AgHSAAKQMANwMAIB1BCGohHSAAQQhqIQAgH0F/aiIfDQALIAcgIGshBwsgB0UNAQJAAkAgB0EHcSIgDQAgByEfDAELIAdBeHEhHwNAIB0gAC0AADoAACAdQQFqIR0gAEEBaiEAICBBf2oiIA0ACwsgB0EISQ0BCwNAIB0gACkAADcAACAdQQhqIR0gAEEIaiEAIB9BeGoiHw0ACwsgA0EAKAKcjgFqIgBBeWopAwAhCiAAKQMJIRMgACkDGSEUIAApAykhCyAAKQMBIQwgACkDESEOIAApAyEhESACKQMAIRUgAikDECEWIAIpAyAhFyACKQMIIRggAikDQCENIAIpA0ghDyACKQMYIRkgAikDUCESIAIpA1ghCCACKQMoIRogAikDYCEQIAIpA2ghCSACIAYgAikDcCIbfCAAKQMxIAIpA3giBoUiHEIgiCAcQv////8Pg358NwM4IBogEHwgESAJhSIRQiCIIBFC/////w+DfnwhESAZIBJ8IA4gCIUiDkIgiCAOQv////8Pg358IQ4gGCANfCAMIA+FIgxCIIggDEL/////D4N+fCEMIAYgCyAbhSILQiCIIAtC/////w+DfiAFfHwhCyAJIBcgFCAQhSIFQiCIIAVC/////w+Dfnx8IRAgCCAWIBMgEoUiBUIgiCAFQv////8Pg358fCESIA8gFSAKIA2FIgVCIIggBUL/////D4N+fHwhCAsgAykDQyACKQM4hSIFQv////8PgyIGIAMpAzsgC4UiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDMyARhSIFQv////8PgyIGIAMpAysgEIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDIyAOhSIFQv////8PgyIGIAMpAxsgEoUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDEyAMhSIFQv////8PgyIGIAMpAwsgCIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgBEKHla+vmLbem55/fnx8fHwiBEIliCAEhUL5893xmfKZqxZ+IgRCIIggBIUhBAwBCyAEpyEAAkBBACkDoI4BIgRQDQACQCAAQRBLDQAgAEGACCAEEAUhBAwCCwJAIABBgAFLDQAgAEGACCAEEAYhBAwCCyAAQYAIIAQQByEEDAELAkAgAEEQSw0AIAAgA0IAEAUhBAwBCwJAIABBgAFLDQAgACADQgAQBiEEDAELIAAgA0IAEAchBAtBACAEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISENwOACiABJAALBgBBgIoBCwIACwvMAQEAQYAIC8QBuP5sOSOkS758AYEs9yGtHN7UbemDkJfbckCkpLezZx/LeeZOzMDleIJa0H3M/3IhuAhGdPdDJI7gNZDmgTomTDwoUruRwwDLiNBlixtTLqNxZEiXog35TjgZ70ap3qzYqPp2P+OcND/53LvHxwtPHYpR4EvNtFkxyJ9+ydl4c2TqxayDNNPrw8WBoP/6E2PrFw3dUbfw2knTFlUmKdRonisWvlh9R6H8j/i40XrQMc5FyzqPlRYEKK/X+8q7S0B+QAIAAA==";
    hash$6 = "5a2fbdbb";
    wasmJson$6 = {
      name: name$6,
      data: data$6,
      hash: hash$6
    };
    mutex$4 = new Mutex();
    wasmCache$4 = null;
    seedBuffer$1 = new Uint8Array(8);
    name$5 = "xxhash128";
    data$5 = "AGFzbQEAAAABKwdgAAF/YAR/f39/AGAHf39/f39/fwBgA39/fgF+YAR/f39+AGAAAGABfwADDQwAAQIDBAQEBQYFAAUFBAEBAgIGDgJ/AUHAjgULfwBBwAkLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAcLSGFzaF9VcGRhdGUACApIYXNoX0ZpbmFsAAkNSGFzaF9HZXRTdGF0ZQAKDkhhc2hfQ2FsY3VsYXRlAAsKU1RBVEVfU0laRQMBCqBNDAUAQYAKC+QDAw9+AX8BfgJAIANFDQAgACkDMCEEIAApAzghBSAAKQMgIQYgACkDKCEHIAApAxAhCCAAKQMYIQkgACkDACEKIAApAwghCwNAIAUgAUEwaikDACIMfCACQThqKQMAIAFBOGopAwAiDYUiBUIgiCAFQv////8Pg358IQUgByABQSBqKQMAIg58IAJBKGopAwAgAUEoaikDACIPhSIHQiCIIAdC/////w+DfnwhByAJIAFBEGopAwAiEHwgAkEYaikDACABQRhqKQMAIhGFIglCIIggCUL/////D4N+fCEJIAsgASkDACISfCACQQhqIhMpAwAgAUEIaikDACIUhSILQiCIIAtC/////w+DfnwhCyACQTBqKQMAIAyFIgxCIIggDEL/////D4N+IAR8IA18IQQgAkEgaikDACAOhSIMQiCIIAxC/////w+DfiAGfCAPfCEGIAJBEGopAwAgEIUiDEIgiCAMQv////8Pg34gCHwgEXwhCCACKQMAIBKFIgxCIIggDEL/////D4N+IAp8IBR8IQogAUHAAGohASATIQIgA0F/aiIDDQALIAAgCTcDGCAAIAo3AwAgACALNwMIIAAgBzcDKCAAIAg3AxAgACAFNwM4IAAgBjcDICAAIAQ3AzALC94CAgF/AX4CQCAEIAIgASgCACIHayICSQ0AIAAgAyAFIAdBA3RqIAIQASAAIAUgBmoiBykDACAAKQMAIghCL4iFIAiFQrHz3fEJfjcDACAAIAcpAwggACkDCCIIQi+IhSAIhUKx893xCX43AwggACAHKQMQIAApAxAiCEIviIUgCIVCsfPd8Ql+NwMQIAAgBykDGCAAKQMYIghCL4iFIAiFQrHz3fEJfjcDGCAAIAcpAyAgACkDICIIQi+IhSAIhUKx893xCX43AyAgACAHKQMoIAApAygiCEIviIUgCIVCsfPd8Ql+NwMoIAAgBykDMCAAKQMwIghCL4iFIAiFQrHz3fEJfjcDMCAAIAcpAzggACkDOCIIQi+IhSAIhUKx893xCX43AzggACADIAJBBnRqIAUgBCACayIHEAEgASAHNgIADwsgACADIAUgB0EDdGogBBABIAEgByAEajYCAAvtAwEFfiABKQM4IAApAziFIgNC/////w+DIgQgASkDMCAAKQMwhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMoIAApAyiFIgNC/////w+DIgQgASkDICAAKQMghSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMYIAApAxiFIgNC/////w+DIgQgASkDECAAKQMQhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMIIAApAwiFIgNC/////w+DIgQgASkDACAAKQMAhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSACfHx8fCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQu6CAIFfgN/AkAgAUEJSQ0AIAAgAUH4iwFqKQMAIgQgAikDOCACKQMwhSADfIUiBUL/////D4NC95Svrwh+IAVCgICAgHCDfEEAKQOAjAEgAikDKCACKQMghSADfYUgBIUiA0IgiCIEQrHz3fEJfnwgBEKHla+vCH4iBEIgiHwgBEL/////D4MgA0L/////D4MiA0Kx893xCX58IANCh5Wvrwh+IgRCIIh8IgVCIIh8IgNCOIYgA0KA/gODQiiGhCADQoCA/AeDQhiGIANCgICA+A+DQgiGhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA/gODIANCOIiEhIQgBEL/////D4MgAUF/aq1CNoaEIAVCIIZ8hSIEQiCIIgVCz9bTvgJ+IgZC/////w+DIARC/////w+DIgRCvdzKlQx+fCAEQs/W074CfiIEQiCIfCIHQiCGIghCJYggCCAEQv////8Pg4SFQvnz3fGZ8pmrFn4iBEIgiCAEhTcDACAAIAVCvdzKlQx+IANCz9bTvtLHq9lCfnwgBkIgiHwgB0IgiHwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4U3AwgPCwJAIAFBBEkNACAAIAIpAxggAikDEIUgA6ciAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnKtQiCGIAOFfCABQfyLAWo1AgBCIIZBADUCgIwBhIUiA0IgiCIEIAFBAnRBh5Wvr3hqrSIFfiIGQiCIIARCsfPd8Ql+fCAGQv////8PgyADQv////8PgyIDQrHz3fEJfnwgAyAFfiIDQiCIfCIEQiCIfCAEQiCGIANC/////w+DhCIEQgGGfCIDQiWIIAOFQvnz3fGZ8pmrFn4iBUIgiCAFhTcDCCAAIANCA4ggBIUiA0IjiCADhUKlvuP00YyH2Z9/fiIDQhyIIAOFNwMADwsCQCABRQ0AIAAgAigCBCACKAIAc60gA3wiBEIhiEEALQCAjAFBEHQgAUEIdHIiCSABQQF2QYCMAWotAABBGHRyIgogAUH/iwFqLQAAIgFyIguthSAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMAIAAgAigCDCACKAIIc60gA30iA0IhiCABQRh0IAtBgP4DcUEIdHIgCUEIdkGA/gNxIApBGHZyckENd62FIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwgPCyAAIAIpA1AgAikDWIUgA4UiBEIhiCAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMIIAAgAikDQCACKQNIhSADhSIDQiGIIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwALwwoBCn4gAa0iBEKHla+vmLbem55/fiEFAkACQCABQSFPDQBCACEGDAELQgAhBwJAIAFBwQBJDQBCACEHAkAgAUHhAEkNACACQfgAaikDACADfSABQciLAWopAwAiCIUiB0L/////D4MiCSACKQNwIAN8IAFBwIsBaikDACIKhSILQiCIIgx+Ig1CIIggB0IgiCIHIAx+fCANQv////8PgyAHIAtC/////w+DIgt+fCAJIAt+IgdCIIh8IglCIIh8QQApA7iMASILQQApA7CMASIMfIUgCUIghiAHQv////8Pg4SFIQcgAkHoAGopAwAgA30gC4UiCUL/////D4MiCyACKQNgIAN8IAyFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCALIAx+IgtCIIh8IgxCIIYgC0L/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAV8IAggCnyFIQULIAJB2ABqKQMAIAN9IAFB2IsBaikDACIIhSIJQv////8PgyIKIAIpA1AgA3wgAUHQiwFqKQMAIguFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCAKIAx+IgpCIIh8IgxCIIYgCkL/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAd8QQApA6iMASIJQQApA6CMASIKfIUhByACQcgAaikDACADfSAJhSIJQv////8PgyIMIAIpA0AgA3wgCoUiCkIgiCINfiIGQv////8PgyAJQiCIIgkgCkL/////D4MiCn58IAwgCn4iCkIgiHwiDEIghiAKQv////8Pg4QgBkIgiCAJIA1+fCAMQiCIfIUgBXwgCCALfIUhBQsgAkE4aikDACADfSABQeiLAWopAwAiCIUiCUL/////D4MiCiACKQMwIAN8IAFB4IsBaikDACILhSIMQiCIIg1+IgZC/////w+DIAlCIIgiCSAMQv////8PgyIMfnwgCiAMfiIKQiCIfCIMQiCGIApC/////w+DhCAGQiCIIAkgDX58IAxCIIh8hSAHfEEAKQOYjAEiB0EAKQOQjAEiCXyFIQYgAkEoaikDACADfSAHhSIHQv////8PgyIKIAIpAyAgA3wgCYUiCUIgiCIMfiINQv////8PgyAHQiCIIgcgCUL/////D4MiCX58IAogCX4iCUIgiHwiCkIghiAJQv////8Pg4QgDUIgiCAHIAx+fCAKQiCIfIUgBXwgCCALfIUhBQsgACACQRhqKQMAIAN9IAFB+IsBaikDACIHhSIIQv////8PgyIJIAIpAxAgA3wgAUHwiwFqKQMAIgqFIgtCIIgiDH4iDUL/////D4MgCEIgiCIIIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAZ8QQApA4iMASIIQQApA4CMASIJfIUiCyACQQhqKQMAIAN9IAiFIghC/////w+DIgwgAikDACADfCAJhSIJQiCIIg1+IgZC/////w+DIAhCIIgiCCAJQv////8PgyIJfnwgDCAJfiIJQiCIfCIMQiCGIAlC/////w+DhCAGQiCIIAggDX58IAxCIIh8hSAFfCAHIAp8hSIFfCIHQiWIIAeFQvnz3fGZ8pmrFn4iB0IgiCAHhTcDACAAQgAgBUKHla+vmLbem55/fiAEIAN9Qs/W077Sx6vZQn58IAtC49zKlfzO8vWFf358IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFfTcDCAuhDwMBfxR+An9BACEEIAJB+ABqKQMAIAN9QQApA/iMASIFhSIGQv////8PgyIHIAIpA3AgA3xBACkD8IwBIgiFIglCIIgiCn4iC0L/////D4MgBkIgiCIGIAlC/////w+DIgl+fCAHIAl+IgdCIIh8IglCIIYgB0L/////D4OEIAtCIIggBiAKfnwgCUIgiHyFIAJB2ABqKQMAIAN9QQApA9iMASIHhSIGQv////8PgyIJIAIpA1AgA3xBACkD0IwBIgqFIgtCIIgiDH4iDUL/////D4MgBkIgiCIGIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAJBOGopAwAgA31BACkDuIwBIgmFIgZC/////w+DIgsgAikDMCADfEEAKQOwjAEiDIUiDUIgiCIOfiIPQv////8PgyAGQiCIIgYgDUL/////D4MiDX58IAsgDX4iC0IgiHwiDUIghiALQv////8Pg4QgD0IgiCAGIA5+fCANQiCIfIUgAkEYaikDACADfUEAKQOYjAEiC4UiBkL/////D4MiDSACKQMQIAN8QQApA5CMASIOhSIPQiCIIhB+IhFC/////w+DIAZCIIgiBiAPQv////8PgyIPfnwgDSAPfiINQiCIfCIPQiCGIA1C/////w+DhCARQiCIIAYgEH58IA9CIIh8hUEAKQOIjAEiDUEAKQOAjAEiD3yFfEEAKQOojAEiEEEAKQOgjAEiEXyFfEEAKQPIjAEiEkEAKQPAjAEiE3yFfEEAKQPojAEiFEEAKQPgjAEiFXyFIgZCJYggBoVC+fPd8ZnymasWfiIGQiCIIAaFIQYgAkHoAGopAwAgA30gFIUiFEL/////D4MiFiACKQNgIAN8IBWFIhVCIIgiF34iGEL/////D4MgFEIgiCIUIBVC/////w+DIhV+fCAWIBV+IhVCIIh8IhZCIIYgFUL/////D4OEIBhCIIggFCAXfnwgFkIgiHyFIAJByABqKQMAIAN9IBKFIhJC/////w+DIhQgAikDQCADfCAThSITQiCIIhV+IhZC/////w+DIBJCIIgiEiATQv////8PgyITfnwgFCATfiITQiCIfCIUQiCGIBNC/////w+DhCAWQiCIIBIgFX58IBRCIIh8hSACQShqKQMAIAN9IBCFIhBC/////w+DIhIgAikDICADfCARhSIRQiCIIhN+IhRC/////w+DIBBCIIgiECARQv////8PgyIRfnwgEiARfiIRQiCIfCISQiCGIBFC/////w+DhCAUQiCIIBAgE358IBJCIIh8hSACQQhqKQMAIAN9IA2FIg1C/////w+DIhAgAikDACADfCAPhSIPQiCIIhF+IhJC/////w+DIA1CIIgiDSAPQv////8PgyIPfnwgECAPfiIPQiCIfCIQQiCGIA9C/////w+DhCASQiCIIA0gEX58IBBCIIh8hSABrSIPQoeVr6+Ytt6bnn9+fCALIA58hXwgCSAMfIV8IAcgCnyFfCAFIAh8hSIFQiWIIAWFQvnz3fGZ8pmrFn4iBUIgiCAFhSEFAkAgAUGgAUgNACABQQV2QXxqIRkDQCACIARqIhpBG2opAwAgA30gBEGYjQFqKQMAIgeFIghC/////w+DIgkgGkETaikDACADfCAEQZCNAWopAwAiCoUiC0IgiCIMfiINQv////8PgyAIQiCIIgggC0L/////D4MiC358IAkgC34iCUIgiHwiC0IghiAJQv////8Pg4QgDUIgiCAIIAx+fCALQiCIfIUgBnwgBEGIjQFqKQMAIgggBEGAjQFqKQMAIgl8hSEGIBpBC2opAwAgA30gCIUiCEL/////D4MiCyAaQQNqKQMAIAN8IAmFIglCIIgiDH4iDUL/////D4MgCEIgiCIIIAlC/////w+DIgl+fCALIAl+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAV8IAcgCnyFIQUgBEEgaiEEIBlBf2oiGQ0ACwsgACACQf8AaikDACADfCABQeiLAWopAwAiB4UiCEL/////D4MiCSACKQN3IAN9IAFB4IsBaikDACIKhSILQiCIIgx+Ig1C/////w+DIAhCIIgiCCALQv////8PgyILfnwgCSALfiIJQiCIfCILQiCGIAlC/////w+DhCANQiCIIAggDH58IAtCIIh8hSAGfCABQfiLAWopAwAiBiABQfCLAWopAwAiCHyFIgkgAkHvAGopAwAgA3wgBoUiBkL/////D4MiCyACKQNnIAN9IAiFIghCIIgiDH4iDUL/////D4MgBkIgiCIGIAhC/////w+DIgh+fCALIAh+IghCIIh8IgtCIIYgCEL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAV8IAcgCnyFIgZ8IgVCJYggBYVC+fPd8ZnymasWfiIFQiCIIAWFNwMAIABCACAGQoeVr6+Ytt6bnn9+IA8gA31Cz9bTvtLHq9lCfnwgCULj3MqV/M7y9YV/fnwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4V9NwMIC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAAfTcDqIsBQQAgAEKo9dv7s5ynmj98NwOgiwFBAEK4sry3lNW31lggAH03A5iLAUEAIABC8cihuqm0w/zOAHw3A5CLAUEAQoihl9u445SXo38gAH03A4iL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AkHAAGogDGohC0GAjAEhAAJAAkACQCAHQQhJDQACQCAHQThqQQN2QQFqQQdxIg0NAAwCCyANQQN0IQ5BgIwBIQADQCALIAApAwA3AwAgC0EIaiELIABBCGohACANQX9qIg0NAAsgByAOayEHCyAHRQ0BAkACQCAHQQdxIg4NACAHIQ0MAQsgB0F4cSENA0AgCyAALQAAOgAAIAtBAWohCyAAQQFqIQAgDkF/aiIODQALCyAHQQhJDQELA0AgCyAAKQAANwAAIAtBCGohCyAAQQhqIQAgDUF4aiINDQALCyACIAIpAwggAikDQCIIfCADQQAoApyOAWoiACkDASACKQNIIgmFIgpCIIggCkL/////D4N+fDcDCCACIAIpAxggAikDUCIKfCAAKQMRIAIpA1giEIUiEUIgiCARQv////8Pg358NwMYIAIgECAKIAApAwmFIgpCIIggCkL/////D4N+IAIpAxB8fDcDECACIAkgCCAAQXlqKQMAhSIIQiCIIAhC/////w+DfiACKQMAfHw3AwAgACkDGSEIIAIpAyAhCSACIAIpAyggAikDYCIKfCAAKQMhIAIpA2giEIUiEUIgiCARQv////8Pg358NwMoIAIgECAJIAggCoUiCEIgiCAIQv////8Pg358fDcDICACIAYgAikDcCIIfCAAKQMxIAIpA3giBoUiCUIgiCAJQv////8Pg358NwM4IAIgBiAIIAApAymFIghCIIggCEL/////D4N+IAV8fDcDMAsgAiACIANBC2ogBEKHla+vmLbem55/fhADNwNAIAIgAiADQQAoApyOAWpBdWogBELP1tO+0ser2UJ+Qn+FEAM3A0gMAQsgBKchAAJAQQApA6COASIEUA0AAkAgAEEQSw0AIAJBwABqIABBgAggBBAEDAILAkAgAEGAAUsNACACQcAAaiAAQYAIIAQQBQwCCyACQcAAaiAAQYAIIAQQBgwBCwJAIABBEEsNACACQcAAaiAAIANCABAEDAELAkAgAEGAAUsNACACQcAAaiAAIANCABAFDAELIAJBwABqIAAgA0IAEAYLQQAgAikDcDcDuApBACACKQNgNwOoCkEAIAIpA1A3A5gKQQAgAkH4AGopAwA3A8AKQQAgAkHoAGopAwA3A7AKQQAgAkHYAGopAwA3A6AKQQAgAikDSCIEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEIgQ3A4AKQQAgBDcDkApBACACKQNAIgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQ3A4gKIAEkAAsGAEGAigELAgALC8wBAQBBgAgLxAG4/mw5I6RLvnwBgSz3Ia0c3tRt6YOQl9tyQKSkt7NnH8t55k7MwOV4glrQfcz/ciG4CEZ090MkjuA1kOaBOiZMPChSu5HDAMuI0GWLG1Muo3FkSJeiDflOOBnvRqnerNio+nY/45w0P/ncu8fHC08dilHgS820WTHIn37J2XhzZOrFrIM00+vDxYGg//oTY+sXDd1Rt/DaSdMWVSYp1GieKxa+WH1HofyP+LjRetAxzkXLOo+VFgQor9f7yrtLQH5AAgAA";
    hash$5 = "b9ab74e2";
    wasmJson$5 = {
      name: name$5,
      data: data$5,
      hash: hash$5
    };
    mutex$3 = new Mutex();
    wasmCache$3 = null;
    seedBuffer = new Uint8Array(8);
    name$4 = "ripemd160";
    data$4 = "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";
    hash$4 = "6abbce74";
    wasmJson$4 = {
      name: name$4,
      data: data$4,
      hash: hash$4
    };
    mutex$2 = new Mutex();
    wasmCache$2 = null;
    validateOptions$2 = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!options.hashFunction || !options.hashFunction.then) {
        throw new Error('Invalid hash function is provided! Usage: pbkdf2("password", "salt", 1000, 32, createSHA1()).');
      }
      if (!Number.isInteger(options.iterations) || options.iterations < 1) {
        throw new Error("Iterations should be a positive number");
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 1) {
        throw new Error("Hash length should be a positive number");
      }
      if (options.outputType === void 0) {
        options.outputType = "hex";
      }
      if (!["hex", "binary"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);
      }
    };
    name$3 = "scrypt";
    data$3 = "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cyICajYCOCAAIAAoAjwgAiAKakESdyAGc2o2AjwLvxIDFX8Bfg5/AkAgAkUNACAAQQd0IgNBQGoiBEEAKAKACCIFIAMgAmwiBmogAyABbGoiByADaiIIaiEJIAAgAkEHdCIKIAFBB3RqIgtsIQwgACALQYABamwhDSAAQQV0IgtBASALQQFLGyILQWBxIQ4gC0EBcSEPIAdBeGohECAHQXBqIREgB0FoaiESIAdBYGohEyAHQVhqIRQgB0FQaiEVIAdBSGohFiAHQUBqIRcgAa1Cf3whGCAEIAdqIRkgByAAQQh0IhpqIRsgACAKQYABamwhHCALQQRJIR1BACEeQQAhHwNAQQAoAoAIIiAgAyAfbGohIQJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgByALaiIEICMgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AIAcgIkECdCILaiAhIAtqKAIANgIACwJAIAFFDQBBACElIBwhIyAGISYDQCAFISQgACEiAkACQCAADQAgGyAXKQMANwMAIBsgFikDADcDCCAbIBUpAwA3AxAgGyAUKQMANwMYIBsgEykDADcDICAbIBIpAwA3AyggGyARKQMANwMwIBsgECkDADcDOAwBCwNAICQgJmoiCyAkIAxqIgQpAwA3AwAgC0EIaiAEQQhqKQMANwMAIAtBEGogBEEQaikDADcDACALQRhqIARBGGopAwA3AwAgC0EgaiAEQSBqKQMANwMAIAtBKGogBEEoaikDADcDACALQTBqIARBMGopAwA3AwAgC0E4aiAEQThqKQMANwMAIAtBwABqIARBwABqKQMANwMAIAtByABqIARByABqKQMANwMAIAtB0ABqIARB0ABqKQMANwMAIAtB2ABqIARB2ABqKQMANwMAIAtB4ABqIARB4ABqKQMANwMAIAtB6ABqIARB6ABqKQMANwMAIAtB8ABqIARB8ABqKQMANwMAIAtB+ABqIARB+ABqKQMANwMAICRBgAFqISQgIkF/aiIiDQALIAcgCCAbIAAQAiAFISQgACEiA0AgJCAjaiILICQgDWoiBCkDADcDACALQQhqIARBCGopAwA3AwAgC0EQaiAEQRBqKQMANwMAIAtBGGogBEEYaikDADcDACALQSBqIARBIGopAwA3AwAgC0EoaiAEQShqKQMANwMAIAtBMGogBEEwaikDADcDACALQThqIARBOGopAwA3AwAgC0HAAGogBEHAAGopAwA3AwAgC0HIAGogBEHIAGopAwA3AwAgC0HQAGogBEHQAGopAwA3AwAgC0HYAGogBEHYAGopAwA3AwAgC0HgAGogBEHgAGopAwA3AwAgC0HoAGogBEHoAGopAwA3AwAgC0HwAGogBEHwAGopAwA3AwAgC0H4AGogBEH4AGopAwA3AwAgJEGAAWohJCAiQX9qIiINAAsLIAggByAbIAAQAiAjIBpqISMgJiAaaiEmICVBAmoiJSABSQ0AC0EAISUDQAJAAkAgAA0AIBsgFykDADcDACAbIBYpAwA3AwggGyAVKQMANwMQIBsgFCkDADcDGCAbIBMpAwA3AyAgGyASKQMANwMoIBsgESkDADcDMCAbIBApAwA3AzgMAQsgACAKIBkpAgAgGIOnQQd0amwhJiAFISQgACEiA0AgJCAMaiILIAspAwAgJCAmaiIEKQMAhTcDACALQQhqIiMgIykDACAEQQhqKQMAhTcDACALQRBqIiMgIykDACAEQRBqKQMAhTcDACALQRhqIiMgIykDACAEQRhqKQMAhTcDACALQSBqIiMgIykDACAEQSBqKQMAhTcDACALQShqIiMgIykDACAEQShqKQMAhTcDACALQTBqIiMgIykDACAEQTBqKQMAhTcDACALQThqIiMgIykDACAEQThqKQMAhTcDACALQcAAaiIjICMpAwAgBEHAAGopAwCFNwMAIAtByABqIiMgIykDACAEQcgAaikDAIU3AwAgC0HQAGoiIyAjKQMAIARB0ABqKQMAhTcDACALQdgAaiIjICMpAwAgBEHYAGopAwCFNwMAIAtB4ABqIiMgIykDACAEQeAAaikDAIU3AwAgC0HoAGoiIyAjKQMAIARB6ABqKQMAhTcDACALQfAAaiIjICMpAwAgBEHwAGopAwCFNwMAIAtB+ABqIgsgCykDACAEQfgAaikDAIU3AwAgJEGAAWohJCAiQX9qIiINAAsgByAIIBsgABACIAAgCiAJKQIAIBiDp0EHdGpsISYgBSEkIAAhIgNAICQgDWoiCyALKQMAICQgJmoiBCkDAIU3AwAgC0EIaiIjICMpAwAgBEEIaikDAIU3AwAgC0EQaiIjICMpAwAgBEEQaikDAIU3AwAgC0EYaiIjICMpAwAgBEEYaikDAIU3AwAgC0EgaiIjICMpAwAgBEEgaikDAIU3AwAgC0EoaiIjICMpAwAgBEEoaikDAIU3AwAgC0EwaiIjICMpAwAgBEEwaikDAIU3AwAgC0E4aiIjICMpAwAgBEE4aikDAIU3AwAgC0HAAGoiIyAjKQMAIARBwABqKQMAhTcDACALQcgAaiIjICMpAwAgBEHIAGopAwCFNwMAIAtB0ABqIiMgIykDACAEQdAAaikDAIU3AwAgC0HYAGoiIyAjKQMAIARB2ABqKQMAhTcDACALQeAAaiIjICMpAwAgBEHgAGopAwCFNwMAIAtB6ABqIiMgIykDACAEQegAaikDAIU3AwAgC0HwAGoiIyAjKQMAIARB8ABqKQMAhTcDACALQfgAaiILIAspAwAgBEH4AGopAwCFNwMAICRBgAFqISQgIkF/aiIiDQALCyAIIAcgGyAAEAIgJUECaiIlIAFJDQALCwJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgIyALaiIEIAcgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AICEgIkECdCILaiAHIAtqKAIANgIACyAeIANqIR4gH0EBaiIfIAJHDQALCws=";
    hash$3 = "b32721f8";
    wasmJson$3 = {
      name: name$3,
      data: data$3,
      hash: hash$3
    };
    isPowerOfTwo = (v) => v && !(v & v - 1);
    validateOptions$1 = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!Number.isInteger(options.blockSize) || options.blockSize < 1) {
        throw new Error("Block size should be a positive number");
      }
      if (!Number.isInteger(options.costFactor) || options.costFactor < 2 || !isPowerOfTwo(options.costFactor)) {
        throw new Error("Cost factor should be a power of 2, greater than 1");
      }
      if (!Number.isInteger(options.parallelism) || options.parallelism < 1) {
        throw new Error("Parallelism should be a positive number");
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 1) {
        throw new Error("Hash length should be a positive number.");
      }
      if (options.outputType === void 0) {
        options.outputType = "hex";
      }
      if (!["hex", "binary"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);
      }
    };
    name$2 = "bcrypt";
    data$2 = "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";
    hash$2 = "8bd8822d";
    wasmJson$2 = {
      name: name$2,
      data: data$2,
      hash: hash$2
    };
    validateOptions = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!Number.isInteger(options.costFactor) || options.costFactor < 4 || options.costFactor > 31) {
        throw new Error("Cost factor should be a number between 4 and 31");
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
        throw new Error("Password should be at least 1 byte long");
      }
      if (options.password.length > 72) {
        throw new Error("Password should be at most 72 bytes long");
      }
      options.salt = getUInt8Buffer(options.salt);
      if (options.salt.length !== 16) {
        throw new Error("Salt should be 16 bytes long");
      }
      if (options.outputType === void 0) {
        options.outputType = "encoded";
      }
      if (!["hex", "binary", "encoded"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
      }
    };
    validateHashCharacters = (hash2) => {
      if (!/^\$2[axyb]\$[0-3][0-9]\$[./A-Za-z0-9]{53}$/.test(hash2)) {
        return false;
      }
      if (hash2[4] === "0" && Number(hash2[5]) < 4) {
        return false;
      }
      if (hash2[4] === "3" && Number(hash2[5]) > 1) {
        return false;
      }
      return true;
    };
    validateVerifyOptions = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (options.hash === void 0 || typeof options.hash !== "string") {
        throw new Error("Hash should be specified");
      }
      if (options.hash.length !== 60) {
        throw new Error("Hash should be 60 bytes long");
      }
      if (!validateHashCharacters(options.hash)) {
        throw new Error("Invalid hash");
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
        throw new Error("Password should be at least 1 byte long");
      }
      if (options.password.length > 72) {
        throw new Error("Password should be at most 72 bytes long");
      }
    };
    name$1 = "whirlpool";
    data$1 = "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";
    hash$1 = "8d8f6035";
    wasmJson$1 = {
      name: name$1,
      data: data$1,
      hash: hash$1
    };
    mutex$1 = new Mutex();
    wasmCache$1 = null;
    name = "sm3";
    data = "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";
    hash = "b6fb4b8e";
    wasmJson = {
      name,
      data,
      hash
    };
    mutex = new Mutex();
    wasmCache = null;
  }
});

// ../../node_modules/@cosmjs/crypto/build/libsodium.js
var require_libsodium = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/libsodium.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Xchacha20poly1305Ietf = exports$1.xchacha20NonceLength = exports$1.Ed25519 = exports$1.Ed25519Keypair = exports$1.Argon2id = void 0;
    exports$1.isArgon2idOptions = isArgon2idOptions;
    var utils_1 = require_build3();
    var chacha_js_1 = require_chacha();
    var ed25519_js_1 = require_ed25519();
    var hash_wasm_1 = (init_index_esm(), __toCommonJS(index_esm_exports));
    function isArgon2idOptions(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.outputLength !== "number")
        return false;
      if (typeof thing.opsLimit !== "number")
        return false;
      if (typeof thing.memLimitKib !== "number")
        return false;
      return true;
    }
    var Argon2id = class {
      static async execute(password, salt, options) {
        const opts = {
          password,
          salt,
          outputType: "binary",
          iterations: options.opsLimit,
          memorySize: options.memLimitKib,
          parallelism: 1,
          // no parallelism allowed, just like libsodium
          hashLength: options.outputLength
        };
        if (salt.length !== 16) {
          throw new Error(`Got invalid salt length ${salt.length}. Must be 16.`);
        }
        const hash2 = await (0, hash_wasm_1.argon2id)(opts);
        (0, utils_1.assert)(typeof hash2 !== "string");
        return hash2;
      }
    };
    exports$1.Argon2id = Argon2id;
    var Ed25519Keypair = class _Ed25519Keypair {
      // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
      static fromLibsodiumPrivkey(libsodiumPrivkey) {
        if (libsodiumPrivkey.length !== 64) {
          throw new Error(`Unexpected key length ${libsodiumPrivkey.length}. Must be 64.`);
        }
        return new _Ed25519Keypair(libsodiumPrivkey.slice(0, 32), libsodiumPrivkey.slice(32, 64));
      }
      privkey;
      pubkey;
      constructor(privkey, pubkey) {
        this.privkey = privkey;
        this.pubkey = pubkey;
      }
      toLibsodiumPrivkey() {
        return new Uint8Array([...this.privkey, ...this.pubkey]);
      }
    };
    exports$1.Ed25519Keypair = Ed25519Keypair;
    var Ed25519 = class {
      /**
       * Generates a keypair deterministically from a given 32 bytes seed.
       *
       * This seed equals the Ed25519 private key.
       * For implementation details see crypto_sign_seed_keypair in
       * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
       * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */
      static async makeKeypair(privKey) {
        const pubKey = ed25519_js_1.ed25519.getPublicKey(privKey);
        return new Ed25519Keypair(privKey, pubKey);
      }
      static async createSignature(message, keyPair) {
        return ed25519_js_1.ed25519.sign(message, keyPair.privkey);
      }
      static async verifySignature(signature, message, pubkey) {
        return ed25519_js_1.ed25519.verify(signature, message, pubkey);
      }
    };
    exports$1.Ed25519 = Ed25519;
    exports$1.xchacha20NonceLength = 24;
    var Xchacha20poly1305Ietf = class {
      static async encrypt(message, key, nonce) {
        const additionalAuthenticatedData = void 0;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.encrypt(message);
      }
      static async decrypt(ciphertext, key, nonce) {
        const additionalAuthenticatedData = void 0;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.decrypt(ciphertext);
      }
    };
    exports$1.Xchacha20poly1305Ietf = Xchacha20poly1305Ietf;
  }
});

// ../../node_modules/@cosmjs/crypto/build/random.js
var require_random = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/random.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Random = void 0;
    var Random = class {
      /**
       * Returns `count` cryptographically secure random bytes
       */
      static getBytes(count) {
        const out = new Uint8Array(count);
        globalThis.crypto.getRandomValues(out);
        return out;
      }
    };
    exports$1.Random = Random;
  }
});

// ../../node_modules/@noble/hashes/legacy.js
var require_legacy = __commonJS({
  "../../node_modules/@noble/hashes/legacy.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ripemd160 = exports$1.RIPEMD160 = exports$1.md5 = exports$1.MD5 = exports$1.sha1 = exports$1.SHA1 = void 0;
    var _md_ts_1 = require_md();
    var utils_ts_1 = require_utils();
    var SHA1_IV = /* @__PURE__ */ Uint32Array.from([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
    var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
    var SHA1 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
      }
      get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
      }
      set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
          SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
          let F, K2;
          if (i < 20) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            K2 = 1518500249;
          } else if (i < 40) {
            F = B ^ C ^ D;
            K2 = 1859775393;
          } else if (i < 60) {
            F = (0, _md_ts_1.Maj)(B, C, D);
            K2 = 2400959708;
          } else {
            F = B ^ C ^ D;
            K2 = 3395469782;
          }
          const T = (0, utils_ts_1.rotl)(A, 5) + F + E + K2 + SHA1_W[i] | 0;
          E = D;
          D = C;
          C = (0, utils_ts_1.rotl)(B, 30);
          B = A;
          A = T;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports$1.SHA1 = SHA1;
    exports$1.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
    var p32 = /* @__PURE__ */ Math.pow(2, 32);
    var K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
    var MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
    var MD5_W = /* @__PURE__ */ new Uint32Array(16);
    var MD5 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
      }
      get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
      }
      set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          MD5_W[i] = view.getUint32(offset, true);
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
          let F, g, s;
          if (i < 16) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            g = i;
            s = [7, 12, 17, 22];
          } else if (i < 32) {
            F = (0, _md_ts_1.Chi)(D, B, C);
            g = (5 * i + 1) % 16;
            s = [5, 9, 14, 20];
          } else if (i < 48) {
            F = B ^ C ^ D;
            g = (3 * i + 5) % 16;
            s = [4, 11, 16, 23];
          } else {
            F = C ^ (B | ~D);
            g = 7 * i % 16;
            s = [6, 10, 15, 21];
          }
          F = F + A + K[i] + MD5_W[g];
          A = D;
          D = C;
          C = B;
          B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        this.set(A, B, C, D);
      }
      roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
      }
      destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports$1.MD5 = MD5;
    exports$1.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
    var Rho160 = /* @__PURE__ */ Uint8Array.from([
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8
    ]);
    var Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
    var Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
    var idxLR = /* @__PURE__ */ (() => {
      const L = [Id160];
      const R = [Pi160];
      const res = [L, R];
      for (let i = 0; i < 4; i++)
        for (let j of res)
          j.push(j[i].map((k) => Rho160[k]));
      return res;
    })();
    var idxL = /* @__PURE__ */ (() => idxLR[0])();
    var idxR = /* @__PURE__ */ (() => idxLR[1])();
    var shifts160 = /* @__PURE__ */ [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => Uint8Array.from(i));
    var shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
    var shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
    var Kl160 = /* @__PURE__ */ Uint32Array.from([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr160 = /* @__PURE__ */ Uint32Array.from([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function ripemd_f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      if (group === 1)
        return x & y | ~x & z;
      if (group === 2)
        return (x | ~y) ^ z;
      if (group === 3)
        return x & z | y & ~z;
      return x ^ (y | ~z);
    }
    var BUF_160 = /* @__PURE__ */ new Uint32Array(16);
    var RIPEMD160 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF_160[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl160[group], hbr = Kr160[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL160[group], sr = shiftsR160[group];
          for (let i = 0; i < 16; i++) {
            const tl = (0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = (0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports$1.RIPEMD160 = RIPEMD160;
    exports$1.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());
  }
});

// ../../node_modules/@cosmjs/crypto/build/ripemd.js
var require_ripemd = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/ripemd.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Ripemd160 = void 0;
    exports$1.ripemd160 = ripemd1602;
    var legacy_1 = require_legacy();
    var utils_1 = require_utils2();
    var Ripemd160 = class {
      blockSize = 512 / 8;
      impl = legacy_1.ripemd160.create();
      constructor(firstData) {
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports$1.Ripemd160 = Ripemd160;
    function ripemd1602(data2) {
      return new Ripemd160(data2).digest();
    }
  }
});

// ../../node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "../../node_modules/@noble/curves/abstract/weierstrass.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DER = exports$1.DERErr = void 0;
    exports$1._splitEndoScalar = _splitEndoScalar;
    exports$1._normFnElement = _normFnElement;
    exports$1.weierstrassN = weierstrassN;
    exports$1.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports$1.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    exports$1.ecdh = ecdh;
    exports$1.ecdsa = ecdsa;
    exports$1.weierstrassPoints = weierstrassPoints;
    exports$1._legacyHelperEquat = _legacyHelperEquat;
    exports$1.weierstrass = weierstrass;
    var hmac_js_1 = require_hmac();
    var utils_1 = require_utils();
    var utils_ts_1 = require_utils4();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
    function _splitEndoScalar(k, basis, n) {
      const [[a1, b1], [a2, b2]] = basis;
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = k - c1 * a1 - c2 * a2;
      let k2 = -c1 * b1 - c2 * b2;
      const k1neg = k1 < _0n;
      const k2neg = k2 < _0n;
      if (k1neg)
        k1 = -k1;
      if (k2neg)
        k2 = -k2;
      const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n;
      if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
        throw new Error("splitScalar (endomorphism): failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
    function validateSigFormat(format) {
      if (!["compact", "recovered", "der"].includes(format))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
      return format;
    }
    function validateSigOpts(opts, def) {
      const optsn = {};
      for (let optName of Object.keys(def)) {
        optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
      }
      (0, utils_ts_1._abool2)(optsn.lowS, "lowS");
      (0, utils_ts_1._abool2)(optsn.prehash, "prehash");
      if (optsn.format !== void 0)
        validateSigFormat(optsn.format);
      return optsn;
    }
    var DERErr = class extends Error {
      constructor(m = "") {
        super(m);
      }
    };
    exports$1.DERErr = DERErr;
    exports$1.DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data2) => {
          const { Err: E } = exports$1.DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data2.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data2.length / 2;
          const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : "";
          const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
          return t + lenLen + len + data2;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data2) {
          const { Err: E } = exports$1.DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data2.length < 2 || data2[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data2[pos++];
          const isLong2 = !!(first & 128);
          let length = 0;
          if (!isLong2)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data2.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes)
              length = length << 8 | b;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data2.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data2.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E } = exports$1.DER;
          if (num < _0n)
            throw new E("integer: negative integers are not allowed");
          let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
          if (Number.parseInt(hex[0], 16) & 8)
            hex = "00" + hex;
          if (hex.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data2) {
          const { Err: E } = exports$1.DER;
          if (data2[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data2[0] === 0 && !(data2[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return (0, utils_ts_1.bytesToNumberBE)(data2);
        }
      },
      toSig(hex) {
        const { Err: E, _int: int2, _tlv: tlv } = exports$1.DER;
        const data2 = (0, utils_ts_1.ensureBytes)("signature", hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data2);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int2.decode(rBytes), s: int2.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int2 } = exports$1.DER;
        const rs = tlv.encode(2, int2.encode(sig.r));
        const ss = tlv.encode(2, int2.encode(sig.s));
        const seq2 = rs + ss;
        return tlv.encode(48, seq2);
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function _normFnElement(Fn, key) {
      const { BYTES: expected } = Fn;
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else {
        let bytes = (0, utils_ts_1.ensureBytes)("private key", key);
        try {
          num = Fn.fromBytes(bytes);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (!Fn.isValidNot0(num))
        throw new Error("invalid private key: out of range [1..N-1]");
      return num;
    }
    function weierstrassN(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)("weierstrass", params, extraOpts);
      const { Fp, Fn } = validated;
      let CURVE = validated.CURVE;
      const { h: cofactor, n: CURVE_ORDER } = CURVE;
      (0, utils_ts_1._validateObject)(extraOpts, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
      });
      const { endo } = extraOpts;
      if (endo) {
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
          throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
      }
      const lengths = getWLengths(Fp, Fn);
      function assertCompressionIsSupported() {
        if (!Fp.isOdd)
          throw new Error("compression is not supported: Field does not have .isOdd()");
      }
      function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
        if (isCompressed) {
          assertCompressionIsSupported();
          const hasEvenY = !Fp.isOdd(y);
          return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        } else {
          return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp.toBytes(y));
        }
      }
      function pointFromBytes(bytes) {
        (0, utils_ts_1._abytes2)(bytes, void 0, "Point");
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        if (length === comp && (head === 2 || head === 3)) {
          const x = Fp.fromBytes(tail);
          if (!Fp.isValid(x))
            throw new Error("bad point: is not on curve, wrong x");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp.sqrt(y2);
          } catch (sqrtError) {
            const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("bad point: is not on curve, sqrt error" + err);
          }
          assertCompressionIsSupported();
          const isYOdd = Fp.isOdd(y);
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp.neg(y);
          return { x, y };
        } else if (length === uncomp && head === 4) {
          const L = Fp.BYTES;
          const x = Fp.fromBytes(tail.subarray(0, L));
          const y = Fp.fromBytes(tail.subarray(L, L * 2));
          if (!isValidXY(x, y))
            throw new Error("bad point: is not on curve");
          return { x, y };
        } else {
          throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
        }
      }
      const encodePoint = extraOpts.toBytes || pointToBytes;
      const decodePoint = extraOpts.fromBytes || pointFromBytes;
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
      }
      function isValidXY(x, y) {
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        return Fp.eql(left, right);
      }
      if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
      const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
      if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error("bad curve params: a or b");
      function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || banZero && Fp.is0(n))
          throw new Error(`bad point coordinate ${title}`);
        return n;
      }
      function aprjpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      function splitEndoScalarN(k) {
        if (!endo || !endo.basises)
          throw new Error("no endo");
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p3, iz) => {
        const { X, Y, Z } = p3;
        if (Fp.eql(Z, Fp.ONE))
          return { x: X, y: Y };
        const is0 = p3.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p3) => {
        if (p3.is0()) {
          if (extraOpts.allowInfinityPoint && !Fp.is0(p3.Y))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = p3.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not field elements");
        if (!isValidXY(x, y))
          throw new Error("bad point: equation left != right");
        if (!p3.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
      }
      class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
          this.X = acoord("x", X);
          this.Y = acoord("y", Y, true);
          this.Z = acoord("z", Z);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p3) {
          const { x, y } = p3 || {};
          if (!p3 || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p3 instanceof Point)
            throw new Error("projective point not allowed");
          if (Fp.is0(x) && Fp.is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
          const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, void 0, "point")));
          P.assertValidity();
          return P;
        }
        static fromHex(hex) {
          return Point.fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex));
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_3n);
          return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (!Fp.isOdd)
            throw new Error("Field doesn't support isOdd");
          return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
          return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo: endo2 } = extraOpts;
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: out of range");
          let point, fake;
          const mul = (n) => wnaf.cached(this, n, (p3) => (0, curve_ts_1.normalizeZ)(Point, p3));
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
            const { p: k1p, f: k1f } = mul(k1);
            const { p: k2p, f: k2f } = mul(k2);
            fake = k1f.add(k2f);
            point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
          } else {
            const { p: p3, f } = mul(scalar);
            point = p3;
            fake = f;
          }
          return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
          const { endo: endo2 } = extraOpts;
          const p3 = this;
          if (!Fn.isValid(sc))
            throw new Error("invalid scalar: out of range");
          if (sc === _0n || p3.is0())
            return Point.ZERO;
          if (sc === _1n)
            return p3;
          if (wnaf.hasCache(this))
            return this.multiply(sc);
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
            const { p1, p2: p22 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p3, k1, k2);
            return finishEndo(endo2.beta, p1, p22, k1neg, k2neg);
          } else {
            return wnaf.unsafe(p3, sc);
          }
        }
        multiplyAndAddUnsafe(Q, a, b) {
          const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
          return sum.is0() ? void 0 : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
          const { isTorsionFree } = extraOpts;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
          const { clearCofactor } = extraOpts;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
          (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
          this.assertValidity();
          return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
          return this.X;
        }
        get py() {
          return this.X;
        }
        get pz() {
          return this.Z;
        }
        toRawBytes(isCompressed = true) {
          return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      Point.Fp = Fp;
      Point.Fn = Fn;
      const bits = Fn.BITS;
      const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
      Point.BASE.precompute(8);
      return Point;
    }
    function pprefix(hasEvenY) {
      return Uint8Array.of(hasEvenY ? 2 : 3);
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      (0, modular_ts_1.validateField)(Fp);
      const { A, B, Z } = opts;
      if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
      if (!Fp.isOdd)
        throw new Error("Field does not have .isOdd()");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, B);
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv);
        return { x, y };
      };
    }
    function getWLengths(Fp, Fn) {
      return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES
      };
    }
    function ecdh(Point, ecdhOpts = {}) {
      const { Fn } = Point;
      const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
      const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });
      function isValidSecretKey(secretKey) {
        try {
          return !!_normFnElement(Fn, secretKey);
        } catch (error) {
          return false;
        }
      }
      function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
          const l = publicKey.length;
          if (isCompressed === true && l !== comp)
            return false;
          if (isCompressed === false && l !== publicKeyUncompressed)
            return false;
          return !!Point.fromBytes(publicKey);
        } catch (error) {
          return false;
        }
      }
      function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, "seed"), Fn.ORDER);
      }
      function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
      }
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      function isProbPub(item) {
        if (typeof item === "bigint")
          return false;
        if (item instanceof Point)
          return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey)
          return void 0;
        const l = (0, utils_ts_1.ensureBytes)("key", item).length;
        return l === publicKey || l === publicKeyUncompressed;
      }
      function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
          throw new Error("first arg must be private key");
        if (isProbPub(publicKeyB) === false)
          throw new Error("second arg must be public key");
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB);
        return b.multiply(s).toBytes(isCompressed);
      }
      const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
    }
    function ecdsa(Point, hash2, ecdsaOpts = {}) {
      (0, utils_1.ahash)(hash2);
      (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
      });
      const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
      const hmac = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(hash2, key, (0, utils_ts_1.concatBytes)(...msgs)));
      const { Fp, Fn } = Point;
      const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
      const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
      const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
        format: void 0,
        //'compact' as ECDSASigFormat,
        extraEntropy: false
      };
      const defaultSigOpts_format = "compact";
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function validateRS(title, num) {
        if (!Fn.isValidNot0(num))
          throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
      }
      function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
      }
      class Signature {
        constructor(r, s, recovery) {
          this.r = validateRS("r", r);
          this.s = validateRS("s", s);
          if (recovery != null)
            this.recovery = recovery;
          Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
          validateSigLength(bytes, format);
          let recid;
          if (format === "der") {
            const { r: r2, s: s2 } = exports$1.DER.toSig((0, utils_ts_1._abytes2)(bytes));
            return new Signature(r2, s2);
          }
          if (format === "recovered") {
            recid = bytes[0];
            format = "compact";
            bytes = bytes.subarray(1);
          }
          const L = Fn.BYTES;
          const r = bytes.subarray(0, L);
          const s = bytes.subarray(L, L * 2);
          return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
          return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
          const FIELD_ORDER = Fp.ORDER;
          const { r, s, recovery: rec } = this;
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
          if (hasCofactor && rec > 1)
            throw new Error("recovery id is ambiguous for h>1 curve");
          const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
          if (!Fp.isValid(radj))
            throw new Error("recovery id 2 or 3 invalid");
          const x = Fp.toBytes(radj);
          const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
          const ir = Fn.inv(radj);
          const h = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", messageHash));
          const u1 = Fn.create(-h * ir);
          const u2 = Fn.create(s * ir);
          const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
          if (Q.is0())
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
          validateSigFormat(format);
          if (format === "der")
            return (0, utils_ts_1.hexToBytes)(exports$1.DER.hexFromSig(this));
          const r = Fn.toBytes(this.r);
          const s = Fn.toBytes(this.s);
          if (format === "recovered") {
            if (this.recovery == null)
              throw new Error("recovery bit must be present");
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
          }
          return (0, utils_ts_1.concatBytes)(r, s);
        }
        toHex(format) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() {
        }
        static fromCompact(hex) {
          return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "compact");
        }
        static fromDER(hex) {
          return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "der");
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
          return this.toBytes("der");
        }
        toDERHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
        }
        toCompactRawBytes() {
          return this.toBytes("compact");
        }
        toCompactHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
        }
      }
      const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
        if (bytes.length > 8192)
          throw new Error("input is too large");
        const num = (0, utils_ts_1.bytesToNumberBE)(bytes);
        const delta = bytes.length * 8 - fnBits;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
        return Fn.create(bits2int(bytes));
      };
      const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
      function int2octets(num) {
        (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
      }
      function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, void 0, "message");
        return prehash ? (0, utils_ts_1._abytes2)(hash2(message), void 0, "prehashed message") : message;
      }
      function prepSig(message, privateKey, opts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (extraEntropy != null && extraEntropy !== false) {
          const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
          seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!Fn.isValidNot0(k))
            return;
          const ik = Fn.inv(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = Fn.create(q.x);
          if (r === _0n)
            return;
          const s = Fn.create(ik * Fn.create(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = Fn.neg(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      function sign(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)("message", message);
        const { seed, k2sig } = prepSig(message, secretKey, opts);
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash2.outputLen, Fn.BYTES, hmac);
        const sig = drbg(seed, k2sig);
        return sig;
      }
      function tryParsingSig(sg) {
        let sig = void 0;
        const isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
        if (!isHex && !isObj)
          throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (isObj) {
          sig = new Signature(sg.r, sg.s);
        } else if (isHex) {
          try {
            sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "der");
          } catch (derError) {
            if (!(derError instanceof exports$1.DER.Err))
              throw derError;
          }
          if (!sig) {
            try {
              sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "compact");
            } catch (error) {
              return false;
            }
          }
        }
        if (!sig)
          return false;
        return sig;
      }
      function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey);
        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)("message", message), prehash);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", signature), format);
        if (sig === false)
          return false;
        try {
          const P = Point.fromBytes(publicKey);
          if (lowS && sig.hasHighS())
            return false;
          const { r, s } = sig;
          const h = bits2int_modN(message);
          const is = Fn.inv(s);
          const u1 = Fn.create(h * is);
          const u2 = Fn.create(r * is);
          const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
          if (R.is0())
            return false;
          const v = Fn.create(R.x);
          return v === r;
        } catch (e) {
          return false;
        }
      }
      function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
      }
      return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils,
        lengths,
        Point,
        sign,
        verify,
        recoverPublicKey,
        Signature,
        hash: hash2
      });
    }
    function weierstrassPoints(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      return _weierstrass_new_output_to_legacy(c, Point);
    }
    function _weierstrass_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp = c.Fp;
      let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
      const Fn = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths,
        modFromBytes: c.wrapPrivateKey
      });
      const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes
      };
      return { CURVE, curveOpts };
    }
    function _ecdsa_legacy_opts_to_new(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN
      };
      return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
    }
    function _legacyHelperEquat(Fp, a, b) {
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      return weierstrassEquation;
    }
    function _weierstrass_new_output_to_legacy(c, Point) {
      const { Fp, Fn } = Point;
      function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
      }
      const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
      return Object.assign({}, {
        CURVE: c,
        Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        weierstrassEquation,
        isWithinCurveOrder
      });
    }
    function _ecdsa_new_output_to_legacy(c, _ecdsa) {
      const Point = _ecdsa.Point;
      return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS))
      });
    }
    function weierstrass(c) {
      const { CURVE, curveOpts, hash: hash2, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      const signs = ecdsa(Point, hash2, ecdsaOpts);
      return _ecdsa_new_output_to_legacy(c, signs);
    }
  }
});

// ../../node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "../../node_modules/@noble/curves/_shortw_utils.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getHash = getHash;
    exports$1.createCurve = createCurve;
    var weierstrass_ts_1 = require_weierstrass();
    function getHash(hash2) {
      return { hash: hash2 };
    }
    function createCurve(curveDef, defHash) {
      const create2 = (hash2) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash2 });
      return { ...create2(defHash), create: create2 };
    }
  }
});

// ../../node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "../../node_modules/@noble/curves/secp256k1.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.encodeToCurve = exports$1.hashToCurve = exports$1.secp256k1_hasher = exports$1.schnorr = exports$1.secp256k1 = void 0;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var _shortw_utils_ts_1 = require_shortw_utils();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var weierstrass_ts_1 = require_weierstrass();
    var utils_ts_1 = require_utils4();
    var secp256k1_CURVE = {
      p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    };
    var secp256k1_ENDO = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      basises: [
        [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
        [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
      ]
    };
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    function sqrtMod(y) {
      const P = secp256k1_CURVE.p;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_ts_1.pow2)(t2, _2n, P);
      if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
    exports$1.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toBytes(true).slice(1);
    var Pointk1 = /* @__PURE__ */ (() => exports$1.secp256k1.Point)();
    var hasEven = (y) => y % _2n === _0n;
    function schnorrGetExtPubKey(priv) {
      const { Fn, BASE } = Pointk1;
      const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
      const p3 = BASE.multiply(d_);
      const scalar = hasEven(p3.y) ? d_ : Fn.neg(d_);
      return { scalar, bytes: pointToBytes(p3) };
    }
    function lift_x(x) {
      const Fp = Fpk1;
      if (!Fp.isValidNot0(x))
        throw new Error("invalid x: Fail if x \u2265 p");
      const xx = Fp.create(x * x);
      const c = Fp.create(xx * x + BigInt(7));
      let y = Fp.sqrt(c);
      if (!hasEven(y))
        y = Fp.neg(y);
      const p3 = Pointk1.fromAffine({ x, y });
      p3.assertValidity();
      return p3;
    }
    var num = utils_ts_1.bytesToNumberBE;
    function challenge(...args) {
      return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(secretKey) {
      return schnorrGetExtPubKey(secretKey).bytes;
    }
    function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
      const { Fn } = Pointk1;
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
      const a = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
      const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const { Fn, BASE } = Pointk1;
      const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x(num(pub));
        const r = num(sig.subarray(0, 32));
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
          return false;
        const s = num(sig.subarray(32, 64));
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
          return false;
        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
        const { x, y } = R.toAffine();
        if (R.is0() || !hasEven(y) || x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports$1.schnorr = (() => {
      const size = 32;
      const seedLength = 48;
      const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
      };
      exports$1.secp256k1.utils.randomSecretKey;
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
      }
      return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
          randomSecretKey,
          randomPrivateKey: randomSecretKey,
          taggedHash,
          // TODO: remove
          lift_x,
          pointToBytes,
          numberToBytesBE: utils_ts_1.numberToBytesBE,
          bytesToNumberBE: utils_ts_1.bytesToNumberBE,
          mod: modular_ts_1.mod
        },
        lengths: {
          secretKey: size,
          publicKey: size,
          publicKeyHasPrefix: false,
          signature: size * 2,
          seed: seedLength
        }
      };
    })();
    var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    exports$1.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports$1.secp256k1.Point, (scalars) => {
      const { x, y } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha256
    }))();
    exports$1.hashToCurve = (() => exports$1.secp256k1_hasher.hashToCurve)();
    exports$1.encodeToCurve = (() => exports$1.secp256k1_hasher.encodeToCurve)();
  }
});

// ../../node_modules/@cosmjs/crypto/build/secp256k1signature.js
var require_secp256k1signature = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/secp256k1signature.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ExtendedSecp256k1Signature = exports$1.Secp256k1Signature = void 0;
    function trimLeadingNullBytes(inData) {
      let numberOfLeadingNullBytes = 0;
      for (const byte of inData) {
        if (byte === 0) {
          numberOfLeadingNullBytes++;
        } else {
          break;
        }
      }
      return inData.slice(numberOfLeadingNullBytes);
    }
    var derTagInteger = 2;
    var Secp256k1Signature = class _Secp256k1Signature {
      /**
       * Takes the pair of integers (r, s) as 2x32 byte of binary data.
       *
       * Note: This is the format Cosmos SDK uses natively.
       *
       * @param data a 64 byte value containing integers r and s.
       */
      static fromFixedLength(data2) {
        if (data2.length !== 64) {
          throw new Error(`Got invalid data length: ${data2.length}. Expected 2x 32 bytes for the pair (r, s)`);
        }
        return new _Secp256k1Signature(trimLeadingNullBytes(data2.slice(0, 32)), trimLeadingNullBytes(data2.slice(32, 64)));
      }
      static fromDer(data2) {
        let pos = 0;
        if (data2[pos++] !== 48) {
          throw new Error("Prefix 0x30 expected");
        }
        const bodyLength = data2[pos++];
        if (data2.length - pos !== bodyLength) {
          throw new Error("Data length mismatch detected");
        }
        const rTag = data2[pos++];
        if (rTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const rLength = data2[pos++];
        if (rLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const rData = data2.slice(pos, pos + rLength);
        pos += rLength;
        const sTag = data2[pos++];
        if (sTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const sLength = data2[pos++];
        if (sLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const sData = data2.slice(pos, pos + sLength);
        pos += sLength;
        return new _Secp256k1Signature(
          // r/s data can contain leading 0 bytes to express integers being non-negative in DER
          trimLeadingNullBytes(rData),
          trimLeadingNullBytes(sData)
        );
      }
      data;
      constructor(r, s) {
        if (r.length > 32 || r.length === 0 || r[0] === 0) {
          throw new Error("Unsigned integer r must be encoded as unpadded big endian.");
        }
        if (s.length > 32 || s.length === 0 || s[0] === 0) {
          throw new Error("Unsigned integer s must be encoded as unpadded big endian.");
        }
        this.data = {
          r,
          s
        };
      }
      r(length) {
        if (length === void 0) {
          return this.data.r;
        } else {
          const paddingLength = length - this.data.r.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter r");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.r]);
        }
      }
      s(length) {
        if (length === void 0) {
          return this.data.s;
        } else {
          const paddingLength = length - this.data.s.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter s");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.s]);
        }
      }
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32)]);
      }
      toDer() {
        const rEncoded = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r;
        const sEncoded = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s;
        const rLength = rEncoded.length;
        const sLength = sEncoded.length;
        const data2 = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);
        return new Uint8Array([48, data2.length, ...data2]);
      }
    };
    exports$1.Secp256k1Signature = Secp256k1Signature;
    var ExtendedSecp256k1Signature = class _ExtendedSecp256k1Signature extends Secp256k1Signature {
      /**
       * Decode extended signature from the simple fixed length encoding
       * described in toFixedLength().
       */
      static fromFixedLength(data2) {
        if (data2.length !== 65) {
          throw new Error(`Got invalid data length ${data2.length}. Expected 32 + 32 + 1`);
        }
        return new _ExtendedSecp256k1Signature(trimLeadingNullBytes(data2.slice(0, 32)), trimLeadingNullBytes(data2.slice(32, 64)), data2[64]);
      }
      recovery;
      constructor(r, s, recovery) {
        super(r, s);
        if (!Number.isInteger(recovery)) {
          throw new Error("The recovery parameter must be an integer.");
        }
        if (recovery < 0 || recovery > 4) {
          throw new Error("The recovery parameter must be one of 0, 1, 2, 3.");
        }
        this.recovery = recovery;
      }
      /**
       * A simple custom encoding that encodes the extended signature as
       * r (32 bytes) | s (32 bytes) | recovery param (1 byte)
       * where | denotes concatenation of bonary data.
       */
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);
      }
    };
    exports$1.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;
  }
});

// ../../node_modules/@cosmjs/crypto/build/secp256k1.js
var require_secp256k12 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/secp256k1.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Secp256k1 = void 0;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var secp256k1_1 = require_secp256k1();
    var secp256k1signature_1 = require_secp256k1signature();
    function unsignedBigIntToBytes(a) {
      (0, utils_1.assert)(a >= 0n);
      let hex = a.toString(16);
      if (hex.length % 2)
        hex = "0" + hex;
      return (0, encoding_1.fromHex)(hex);
    }
    function bytesToUnsignedBigInt(a) {
      return BigInt("0x" + (0, encoding_1.toHex)(a));
    }
    var Secp256k1 = class {
      /**
       * Takes a 32 byte private key and returns a privkey/pubkey pair.
       *
       * The resulting pubkey is uncompressed. For the use in Cosmos it should
       * be compressed first using `Secp256k1.compressPubkey`.
       */
      static async makeKeypair(privkey) {
        if (privkey.length !== 32) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(privkey)) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const out = {
          privkey,
          // encodes uncompressed as
          // - 1-byte prefix "04"
          // - 32-byte x coordinate
          // - 32-byte y coordinate
          pubkey: secp256k1_1.secp256k1.getPublicKey(privkey, false)
        };
        return out;
      }
      /**
       * Creates a signature that is
       * - deterministic (RFC 6979)
       * - lowS signature
       * - DER encoded
       */
      static async createSignature(messageHash, privkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const { recovery, r, s } = secp256k1_1.secp256k1.sign(messageHash, privkey, {
          lowS: true
        });
        if (typeof recovery !== "number")
          throw new Error("Recovery param missing");
        return new secp256k1signature_1.ExtendedSecp256k1Signature(unsignedBigIntToBytes(r), unsignedBigIntToBytes(s), recovery);
      }
      static async verifySignature(signature, messageHash, pubkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const encodedSig = secp256k1_1.secp256k1.Signature.fromDER(signature.toDer());
        return secp256k1_1.secp256k1.verify(encodedSig, messageHash, pubkey, { lowS: false });
      }
      static recoverPubkey(signature, messageHash) {
        const pk = new secp256k1_1.secp256k1.Signature(bytesToUnsignedBigInt(signature.r()), bytesToUnsignedBigInt(signature.s()), signature.recovery).recoverPublicKey(messageHash);
        return pk.toBytes(false);
      }
      /**
       * Takes a compressed or uncompressed pubkey and return a compressed one.
       *
       * This function is idempotent.
       */
      static compressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return pubkey;
          case 65:
            return secp256k1_1.secp256k1.Point.fromBytes(pubkey).toBytes(true);
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      /**
       * Takes a compressed or uncompressed pubkey and returns an uncompressed one.
       *
       * This function is idempotent.
       */
      static uncompressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return secp256k1_1.secp256k1.Point.fromBytes(pubkey).toBytes(false);
          case 65:
            return pubkey;
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      static trimRecoveryByte(signature) {
        switch (signature.length) {
          case 64:
            return signature;
          case 65:
            return signature.slice(0, 64);
          default:
            throw new Error("Invalid signature length");
        }
      }
    };
    exports$1.Secp256k1 = Secp256k1;
  }
});

// ../../node_modules/@cosmjs/crypto/build/slip10.js
var require_slip10 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/slip10.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Slip10 = exports$1.Slip10RawIndex = exports$1.Slip10Curve = void 0;
    exports$1.slip10CurveFromString = slip10CurveFromString;
    exports$1.pathToString = pathToString;
    exports$1.stringToPath = stringToPath;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var utils_1 = require_build3();
    var secp256k1_1 = require_secp256k1();
    var hmac_1 = require_hmac2();
    var sha_1 = require_sha();
    var Slip10Curve;
    (function(Slip10Curve2) {
      Slip10Curve2["Secp256k1"] = "Bitcoin seed";
      Slip10Curve2["Ed25519"] = "ed25519 seed";
    })(Slip10Curve || (exports$1.Slip10Curve = Slip10Curve = {}));
    function bytesToUnsignedBigInt(a) {
      return BigInt("0x" + (0, encoding_1.toHex)(a));
    }
    function intTo32be(n) {
      (0, utils_1.assert)(n >= 0n);
      (0, utils_1.assert)(n < 2n ** (32n * 8n));
      const hex = n.toString(16).padStart(64, "0");
      return (0, encoding_1.fromHex)(hex);
    }
    function slip10CurveFromString(curveString) {
      switch (curveString) {
        case Slip10Curve.Ed25519:
          return Slip10Curve.Ed25519;
        case Slip10Curve.Secp256k1:
          return Slip10Curve.Secp256k1;
        default:
          throw new Error(`Unknown curve string: '${curveString}'`);
      }
    }
    var Slip10RawIndex = class _Slip10RawIndex extends math_1.Uint32 {
      static hardened(hardenedIndex) {
        return new _Slip10RawIndex(hardenedIndex + 2 ** 31);
      }
      static normal(normalIndex) {
        return new _Slip10RawIndex(normalIndex);
      }
      isHardened() {
        return this.data >= 2 ** 31;
      }
    };
    exports$1.Slip10RawIndex = Slip10RawIndex;
    var Slip10 = class _Slip10 {
      static derivePath(curve, seed, path) {
        let result2 = this.master(curve, seed);
        for (const rawIndex of path) {
          result2 = this.child(curve, result2.privkey, result2.chainCode, rawIndex);
        }
        return result2;
      }
      static master(curve, seed) {
        const i = new hmac_1.Hmac(sha_1.Sha512, (0, encoding_1.toAscii)(curve)).update(seed).digest();
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        if (curve !== Slip10Curve.Ed25519 && (this.isZero(il) || this.isGteN(curve, il))) {
          return this.master(curve, i);
        }
        return {
          chainCode: ir,
          privkey: il
        };
      }
      static child(curve, parentPrivkey, parentChainCode, rawIndex) {
        let i;
        if (rawIndex.isHardened()) {
          const payload = new Uint8Array([0, ...parentPrivkey, ...rawIndex.toBytesBigEndian()]);
          i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(payload).digest();
        } else {
          if (curve === Slip10Curve.Ed25519) {
            throw new Error("Normal keys are not allowed with ed25519");
          } else {
            const data2 = new Uint8Array([
              ..._Slip10.serializedPoint(curve, bytesToUnsignedBigInt(parentPrivkey)),
              ...rawIndex.toBytesBigEndian()
            ]);
            i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(data2).digest();
          }
        }
        return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i);
      }
      /**
       * Implementation of ser_P(point(k_par)) from BIP-0032
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
       */
      static serializedPoint(curve, p3) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return secp256k1_1.secp256k1.Point.BASE.multiply(p3).toBytes(true);
          default:
            throw new Error("curve not supported");
        }
      }
      static childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i) {
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        const returnChainCode = ir;
        if (curve === Slip10Curve.Ed25519) {
          return {
            chainCode: returnChainCode,
            privkey: il
          };
        }
        const n = this.n(curve);
        const returnChildKeyAsNumber = (bytesToUnsignedBigInt(il) + bytesToUnsignedBigInt(parentPrivkey)) % n;
        const returnChildKey = intTo32be(returnChildKeyAsNumber);
        if (this.isGteN(curve, il) || this.isZero(returnChildKey)) {
          const newI = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(new Uint8Array([1, ...ir, ...rawIndex.toBytesBigEndian()])).digest();
          return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, newI);
        }
        return {
          chainCode: returnChainCode,
          privkey: returnChildKey
        };
      }
      static isZero(privkey) {
        return privkey.every((byte) => byte === 0);
      }
      static isGteN(curve, privkey) {
        const keyAsNumber = bytesToUnsignedBigInt(privkey);
        return keyAsNumber >= this.n(curve);
      }
      static n(curve) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
          default:
            throw new Error("curve not supported");
        }
      }
    };
    exports$1.Slip10 = Slip10;
    function pathToString(path) {
      return path.reduce((current, component) => {
        const componentString = component.isHardened() ? `${component.toNumber() - 2 ** 31}'` : component.toString();
        return current + "/" + componentString;
      }, "m");
    }
    function stringToPath(input) {
      if (!input.startsWith("m"))
        throw new Error("Path string must start with 'm'");
      let rest = input.slice(1);
      const out = new Array();
      while (rest) {
        const match = rest.match(/^\/([0-9]+)('?)/);
        if (!match)
          throw new Error("Syntax error while reading path component");
        const [fullMatch, numberString, apostrophe] = match;
        const value = math_1.Uint53.fromString(numberString).toNumber();
        if (value >= 2 ** 31)
          throw new Error("Component value too high. Must not exceed 2**31-1.");
        if (apostrophe)
          out.push(Slip10RawIndex.hardened(value));
        else
          out.push(Slip10RawIndex.normal(value));
        rest = rest.slice(fullMatch.length);
      }
      return out;
    }
  }
});

// ../../node_modules/@cosmjs/crypto/build/index.js
var require_build4 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.stringToPath = exports$1.Slip10RawIndex = exports$1.slip10CurveFromString = exports$1.Slip10Curve = exports$1.Slip10 = exports$1.pathToString = exports$1.sha512 = exports$1.Sha512 = exports$1.sha256 = exports$1.Sha256 = exports$1.Secp256k1Signature = exports$1.ExtendedSecp256k1Signature = exports$1.Secp256k1 = exports$1.ripemd160 = exports$1.Ripemd160 = exports$1.Random = exports$1.Xchacha20poly1305Ietf = exports$1.xchacha20NonceLength = exports$1.isArgon2idOptions = exports$1.Ed25519Keypair = exports$1.Ed25519 = exports$1.Argon2id = exports$1.keccak256 = exports$1.Keccak256 = exports$1.Hmac = exports$1.EnglishMnemonic = exports$1.Bip39 = void 0;
    var bip39_1 = require_bip39();
    Object.defineProperty(exports$1, "Bip39", { enumerable: true, get: function() {
      return bip39_1.Bip39;
    } });
    Object.defineProperty(exports$1, "EnglishMnemonic", { enumerable: true, get: function() {
      return bip39_1.EnglishMnemonic;
    } });
    var hmac_1 = require_hmac2();
    Object.defineProperty(exports$1, "Hmac", { enumerable: true, get: function() {
      return hmac_1.Hmac;
    } });
    var keccak_1 = require_keccak();
    Object.defineProperty(exports$1, "Keccak256", { enumerable: true, get: function() {
      return keccak_1.Keccak256;
    } });
    Object.defineProperty(exports$1, "keccak256", { enumerable: true, get: function() {
      return keccak_1.keccak256;
    } });
    var libsodium_1 = require_libsodium();
    Object.defineProperty(exports$1, "Argon2id", { enumerable: true, get: function() {
      return libsodium_1.Argon2id;
    } });
    Object.defineProperty(exports$1, "Ed25519", { enumerable: true, get: function() {
      return libsodium_1.Ed25519;
    } });
    Object.defineProperty(exports$1, "Ed25519Keypair", { enumerable: true, get: function() {
      return libsodium_1.Ed25519Keypair;
    } });
    Object.defineProperty(exports$1, "isArgon2idOptions", { enumerable: true, get: function() {
      return libsodium_1.isArgon2idOptions;
    } });
    Object.defineProperty(exports$1, "xchacha20NonceLength", { enumerable: true, get: function() {
      return libsodium_1.xchacha20NonceLength;
    } });
    Object.defineProperty(exports$1, "Xchacha20poly1305Ietf", { enumerable: true, get: function() {
      return libsodium_1.Xchacha20poly1305Ietf;
    } });
    var random_1 = require_random();
    Object.defineProperty(exports$1, "Random", { enumerable: true, get: function() {
      return random_1.Random;
    } });
    var ripemd_1 = require_ripemd();
    Object.defineProperty(exports$1, "Ripemd160", { enumerable: true, get: function() {
      return ripemd_1.Ripemd160;
    } });
    Object.defineProperty(exports$1, "ripemd160", { enumerable: true, get: function() {
      return ripemd_1.ripemd160;
    } });
    var secp256k1_1 = require_secp256k12();
    Object.defineProperty(exports$1, "Secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.Secp256k1;
    } });
    var secp256k1signature_1 = require_secp256k1signature();
    Object.defineProperty(exports$1, "ExtendedSecp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.ExtendedSecp256k1Signature;
    } });
    Object.defineProperty(exports$1, "Secp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.Secp256k1Signature;
    } });
    var sha_1 = require_sha();
    Object.defineProperty(exports$1, "Sha256", { enumerable: true, get: function() {
      return sha_1.Sha256;
    } });
    Object.defineProperty(exports$1, "sha256", { enumerable: true, get: function() {
      return sha_1.sha256;
    } });
    Object.defineProperty(exports$1, "Sha512", { enumerable: true, get: function() {
      return sha_1.Sha512;
    } });
    Object.defineProperty(exports$1, "sha512", { enumerable: true, get: function() {
      return sha_1.sha512;
    } });
    var slip10_1 = require_slip10();
    Object.defineProperty(exports$1, "pathToString", { enumerable: true, get: function() {
      return slip10_1.pathToString;
    } });
    Object.defineProperty(exports$1, "Slip10", { enumerable: true, get: function() {
      return slip10_1.Slip10;
    } });
    Object.defineProperty(exports$1, "Slip10Curve", { enumerable: true, get: function() {
      return slip10_1.Slip10Curve;
    } });
    Object.defineProperty(exports$1, "slip10CurveFromString", { enumerable: true, get: function() {
      return slip10_1.slip10CurveFromString;
    } });
    Object.defineProperty(exports$1, "Slip10RawIndex", { enumerable: true, get: function() {
      return slip10_1.Slip10RawIndex;
    } });
    Object.defineProperty(exports$1, "stringToPath", { enumerable: true, get: function() {
      return slip10_1.stringToPath;
    } });
  }
});

// ../../node_modules/@cosmjs/amino/build/pubkeys.js
var require_pubkeys = __commonJS({
  "../../node_modules/@cosmjs/amino/build/pubkeys.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.pubkeyType = void 0;
    exports$1.isEd25519Pubkey = isEd25519Pubkey;
    exports$1.isSecp256k1Pubkey = isSecp256k1Pubkey;
    exports$1.isSinglePubkey = isSinglePubkey;
    exports$1.isMultisigThresholdPubkey = isMultisigThresholdPubkey;
    function isEd25519Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyEd25519";
    }
    function isSecp256k1Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeySecp256k1";
    }
    exports$1.pubkeyType = {
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
      secp256k1: "tendermint/PubKeySecp256k1",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
      ed25519: "tendermint/PubKeyEd25519",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
      sr25519: "tendermint/PubKeySr25519",
      multisigThreshold: "tendermint/PubKeyMultisigThreshold"
    };
    function isSinglePubkey(pubkey) {
      const singPubkeyTypes = [exports$1.pubkeyType.ed25519, exports$1.pubkeyType.secp256k1, exports$1.pubkeyType.sr25519];
      return singPubkeyTypes.includes(pubkey.type);
    }
    function isMultisigThresholdPubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyMultisigThreshold";
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/encoding.js
var require_encoding = __commonJS({
  "../../node_modules/@cosmjs/amino/build/encoding.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
    exports$1.encodeEd25519Pubkey = encodeEd25519Pubkey;
    exports$1.decodeAminoPubkey = decodeAminoPubkey;
    exports$1.decodeBech32Pubkey = decodeBech32Pubkey;
    exports$1.encodeAminoPubkey = encodeAminoPubkey;
    exports$1.encodeBech32Pubkey = encodeBech32Pubkey;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var utils_1 = require_build3();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Pubkey(pubkey) {
      if (pubkey.length !== 33 || pubkey[0] !== 2 && pubkey[0] !== 3) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
      }
      return {
        type: pubkeys_1.pubkeyType.secp256k1,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    function encodeEd25519Pubkey(pubkey) {
      if (pubkey.length !== 32) {
        throw new Error("Ed25519 public key must be 32 bytes long");
      }
      return {
        type: pubkeys_1.pubkeyType.ed25519,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    var pubkeyAminoPrefixSecp256k1 = (0, encoding_1.fromHex)(
      "eb5ae98721"
      /* fixed length */
    );
    var pubkeyAminoPrefixEd25519 = (0, encoding_1.fromHex)(
      "1624de6420"
      /* fixed length */
    );
    var pubkeyAminoPrefixSr25519 = (0, encoding_1.fromHex)(
      "0dfb100520"
      /* fixed length */
    );
    var pubkeyAminoPrefixMultisigThreshold = (0, encoding_1.fromHex)(
      "22c1f7e2"
      /* variable length not included */
    );
    function decodeAminoPubkey(data2) {
      if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixSecp256k1)) {
        const rest = data2.slice(pubkeyAminoPrefixSecp256k1.length);
        if (rest.length !== 33) {
          throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.secp256k1,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixEd25519)) {
        const rest = data2.slice(pubkeyAminoPrefixEd25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.ed25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixSr25519)) {
        const rest = data2.slice(pubkeyAminoPrefixSr25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.sr25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixMultisigThreshold)) {
        return decodeMultisigPubkey(data2);
      } else {
        throw new Error("Unsupported public key type. Amino data starts with: " + (0, encoding_1.toHex)(data2.slice(0, 5)));
      }
    }
    function decodeBech32Pubkey(bechEncoded) {
      const { data: data2 } = (0, encoding_1.fromBech32)(bechEncoded);
      return decodeAminoPubkey(data2);
    }
    function decodeUvarint(reader) {
      if (reader.length < 1) {
        throw new Error("Can't decode varint. EOF");
      }
      if (reader[0] > 127) {
        throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
      }
      return [reader[0], 1];
    }
    function decodeMultisigPubkey(data2) {
      const reader = Array.from(data2);
      const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);
      if (!(0, utils_1.arrayContentStartsWith)(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {
        throw new Error("Invalid multisig prefix.");
      }
      if (reader.shift() != 8) {
        throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
      }
      const [threshold, thresholdBytesLength] = decodeUvarint(reader);
      reader.splice(0, thresholdBytesLength);
      const pubkeys = [];
      while (reader.length > 0) {
        if (reader.shift() != 18) {
          throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
        }
        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);
        reader.splice(0, pubkeyLengthBytesSize);
        if (reader.length < pubkeyLength) {
          throw new Error("Invalid multisig data length.");
        }
        const encodedPubkey = reader.splice(0, pubkeyLength);
        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));
        pubkeys.push(pubkey);
      }
      return {
        type: pubkeys_1.pubkeyType.multisigThreshold,
        value: {
          threshold: threshold.toString(),
          pubkeys
        }
      };
    }
    function encodeUvarint(value) {
      const checked = math_1.Uint53.fromString(value.toString()).toNumber();
      if (checked > 127) {
        throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
      }
      return [checked];
    }
    function encodeAminoPubkey(pubkey) {
      if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);
        out.push(8);
        out.push(...encodeUvarint(pubkey.value.threshold));
        for (const pubkeyData of pubkey.value.pubkeys.map((p3) => encodeAminoPubkey(p3))) {
          out.push(18);
          out.push(...encodeUvarint(pubkeyData.length));
          out.push(...pubkeyData);
        }
        return new Uint8Array(out);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixEd25519, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else {
        throw new Error("Unsupported pubkey type");
      }
    }
    function encodeBech32Pubkey(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, encodeAminoPubkey(pubkey));
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/addresses.js
var require_addresses = __commonJS({
  "../../node_modules/@cosmjs/amino/build/addresses.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    exports$1.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    exports$1.pubkeyToRawAddress = pubkeyToRawAddress;
    exports$1.pubkeyToAddress = pubkeyToAddress;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    function pubkeyToRawAddress(pubkey) {
      if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawSecp256k1PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawEd25519PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);
        return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
      } else {
        throw new Error("Unsupported public key type");
      }
    }
    function pubkeyToAddress(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/coins.js
var require_coins = __commonJS({
  "../../node_modules/@cosmjs/amino/build/coins.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.coin = coin;
    exports$1.coins = coins;
    exports$1.parseCoins = parseCoins;
    exports$1.addCoins = addCoins;
    var math_1 = require_build();
    function coin(amount, denom) {
      let outAmount;
      if (typeof amount === "number") {
        try {
          outAmount = new math_1.Uint53(amount).toString();
        } catch (_err) {
          throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
        }
      } else {
        if (!amount.match(/^[0-9]+$/)) {
          throw new Error("Invalid unsigned integer string format");
        }
        outAmount = amount.replace(/^0*/, "") || "0";
      }
      return {
        amount: outAmount,
        denom
      };
    }
    function coins(amount, denom) {
      return [coin(amount, denom)];
    }
    function parseCoins(input) {
      return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
        const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/:._-]{2,127})$/);
        if (!match)
          throw new Error("Got an invalid coin string");
        return {
          amount: match[1].replace(/^0+/, "") || "0",
          denom: match[2]
        };
      });
    }
    function addCoins(lhs, rhs) {
      if (lhs.denom !== rhs.denom)
        throw new Error("Trying to add two coins with different denoms");
      return {
        amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,
        denom: lhs.denom
      };
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/multisig.js
var require_multisig2 = __commonJS({
  "../../node_modules/@cosmjs/amino/build/multisig.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.compareArrays = compareArrays;
    exports$1.createMultisigThresholdPubkey = createMultisigThresholdPubkey;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var addresses_1 = require_addresses();
    function compareArrays(a, b) {
      const aHex = (0, encoding_1.toHex)(a);
      const bHex = (0, encoding_1.toHex)(b);
      return aHex === bHex ? 0 : aHex < bHex ? -1 : 1;
    }
    function createMultisigThresholdPubkey(pubkeys, threshold, nosort = false) {
      const uintThreshold = new math_1.Uint53(threshold);
      if (uintThreshold.toNumber() > pubkeys.length) {
        throw new Error(`Threshold k = ${uintThreshold.toNumber()} exceeds number of keys n = ${pubkeys.length}`);
      }
      const outPubkeys = nosort ? pubkeys : Array.from(pubkeys).sort((lhs, rhs) => {
        const addressLhs = (0, addresses_1.pubkeyToRawAddress)(lhs);
        const addressRhs = (0, addresses_1.pubkeyToRawAddress)(rhs);
        return compareArrays(addressLhs, addressRhs);
      });
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: uintThreshold.toString(),
          pubkeys: outPubkeys
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/omitdefault.js
var require_omitdefault = __commonJS({
  "../../node_modules/@cosmjs/amino/build/omitdefault.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.omitDefault = omitDefault;
    function omitDefault(input) {
      switch (typeof input) {
        case "string":
          return input === "" ? void 0 : input;
        case "number":
          return input === 0 ? void 0 : input;
        case "bigint":
          return input === BigInt(0) ? void 0 : input;
        case "boolean":
          return !input ? void 0 : input;
        default:
          throw new Error(`Got unsupported type '${typeof input}'`);
      }
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/paths.js
var require_paths = __commonJS({
  "../../node_modules/@cosmjs/amino/build/paths.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.makeCosmoshubPath = makeCosmoshubPath;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/signature.js
var require_signature = __commonJS({
  "../../node_modules/@cosmjs/amino/build/signature.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.encodeSecp256k1Signature = encodeSecp256k1Signature;
    exports$1.decodeSignature = decodeSignature;
    var encoding_1 = require_build2();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Signature(pubkey, signature) {
      if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
      }
      return {
        pub_key: (0, encoding_2.encodeSecp256k1Pubkey)(pubkey),
        signature: (0, encoding_1.toBase64)(signature)
      };
    }
    function decodeSignature(signature) {
      switch (signature.pub_key.type) {
        // Note: please don't add cases here without writing additional unit tests
        case pubkeys_1.pubkeyType.secp256k1:
          return {
            pubkey: (0, encoding_1.fromBase64)(signature.pub_key.value),
            signature: (0, encoding_1.fromBase64)(signature.signature)
          };
        default:
          throw new Error("Unsupported pubkey type");
      }
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/signdoc.js
var require_signdoc = __commonJS({
  "../../node_modules/@cosmjs/amino/build/signdoc.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.sortedJsonStringify = sortedJsonStringify;
    exports$1.makeSignDoc = makeSignDoc;
    exports$1.escapeCharacters = escapeCharacters;
    exports$1.serializeSignDoc = serializeSignDoc;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    function sortedObject(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(sortedObject);
      }
      const sortedKeys = Object.keys(obj).sort();
      const result2 = {};
      sortedKeys.forEach((key) => {
        result2[key] = sortedObject(obj[key]);
      });
      return result2;
    }
    function sortedJsonStringify(obj) {
      return JSON.stringify(sortedObject(obj));
    }
    function makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence, timeout_height) {
      return {
        chain_id: chainId,
        account_number: math_1.Uint53.fromString(accountNumber.toString()).toString(),
        sequence: math_1.Uint53.fromString(sequence.toString()).toString(),
        fee,
        msgs,
        memo: memo || "",
        ...timeout_height && { timeout_height: timeout_height.toString() }
      };
    }
    function escapeCharacters(input) {
      const amp = /&/g;
      const lt = /</g;
      const gt = />/g;
      return input.replace(amp, "\\u0026").replace(lt, "\\u003c").replace(gt, "\\u003e");
    }
    function serializeSignDoc(signDoc) {
      const serialized = escapeCharacters(sortedJsonStringify(signDoc));
      return (0, encoding_1.toUtf8)(serialized);
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/wallet.js
var require_wallet = __commonJS({
  "../../node_modules/@cosmjs/amino/build/wallet.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.supportedAlgorithms = exports$1.cosmjsSalt = void 0;
    exports$1.executeKdf = executeKdf;
    exports$1.encrypt = encrypt;
    exports$1.decrypt = decrypt;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    exports$1.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          const screamTest = (0, utils_1.sleep)(options.opsLimit * 250);
          const result2 = await crypto_1.Argon2id.execute(password, exports$1.cosmjsSalt, options);
          await screamTest;
          return result2;
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports$1.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports$1.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports$1.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/secp256k1hdwallet.js
var require_secp256k1hdwallet = __commonJS({
  "../../node_modules/@cosmjs/amino/build/secp256k1hdwallet.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Secp256k1HdWallet = void 0;
    exports$1.extractKdfConfiguration = extractKdfConfiguration;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var addresses_1 = require_addresses();
    var paths_1 = require_paths();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var wallet_1 = require_wallet();
    var serializationTypeV1 = "secp256k1wallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    var defaultOptions2 = {
      hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var Secp256k1HdWallet2 = class _Secp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _Secp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _Secp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _Secp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      /** Base secret */
      secret;
      /** BIP39 seed */
      seed;
      /** Derivation instruction */
      accounts;
      constructor(mnemonic, options) {
        const hdPaths = options.hdPaths ?? defaultOptions2.hdPaths;
        const prefix = options.prefix ?? defaultOptions2.prefix;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signAmino(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));
        const signature = await crypto_1.Secp256k1.createSignature(message, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports$1.Secp256k1HdWallet = Secp256k1HdWallet2;
  }
});

// ../../node_modules/@cosmjs/amino/build/secp256k1wallet.js
var require_secp256k1wallet = __commonJS({
  "../../node_modules/@cosmjs/amino/build/secp256k1wallet.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Secp256k1Wallet = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var addresses_1 = require_addresses();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var Secp256k1Wallet = class _Secp256k1Wallet {
      /**
       * Creates a Secp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _Secp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      pubkey;
      privkey;
      prefix;
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signAmino(signerAddress, signDoc) {
        if (signerAddress !== this.address) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const message = new crypto_1.Sha256((0, signdoc_1.serializeSignDoc)(signDoc)).digest();
        const signature = await crypto_1.Secp256k1.createSignature(message, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes)
        };
      }
    };
    exports$1.Secp256k1Wallet = Secp256k1Wallet;
  }
});

// ../../node_modules/@cosmjs/amino/build/stdtx.js
var require_stdtx = __commonJS({
  "../../node_modules/@cosmjs/amino/build/stdtx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isStdTx = isStdTx;
    exports$1.makeStdTx = makeStdTx;
    function isStdTx(txValue) {
      const { memo, msg, fee, signatures } = txValue;
      return typeof memo === "string" && Array.isArray(msg) && typeof fee === "object" && Array.isArray(signatures);
    }
    function makeStdTx(content, signatures) {
      return {
        msg: content.msgs,
        fee: content.fee,
        memo: content.memo,
        signatures: Array.isArray(signatures) ? signatures : [signatures]
      };
    }
  }
});

// ../../node_modules/@cosmjs/amino/build/index.js
var require_build5 = __commonJS({
  "../../node_modules/@cosmjs/amino/build/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.executeKdf = exports$1.makeStdTx = exports$1.isStdTx = exports$1.serializeSignDoc = exports$1.makeSignDoc = exports$1.encodeSecp256k1Signature = exports$1.decodeSignature = exports$1.Secp256k1Wallet = exports$1.Secp256k1HdWallet = exports$1.extractKdfConfiguration = exports$1.pubkeyType = exports$1.isSinglePubkey = exports$1.isSecp256k1Pubkey = exports$1.isMultisigThresholdPubkey = exports$1.isEd25519Pubkey = exports$1.makeCosmoshubPath = exports$1.omitDefault = exports$1.createMultisigThresholdPubkey = exports$1.encodeSecp256k1Pubkey = exports$1.encodeEd25519Pubkey = exports$1.encodeBech32Pubkey = exports$1.encodeAminoPubkey = exports$1.decodeBech32Pubkey = exports$1.decodeAminoPubkey = exports$1.parseCoins = exports$1.coins = exports$1.coin = exports$1.addCoins = exports$1.rawSecp256k1PubkeyToRawAddress = exports$1.rawEd25519PubkeyToRawAddress = exports$1.pubkeyToRawAddress = exports$1.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports$1, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports$1, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports$1, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports$1, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var coins_1 = require_coins();
    Object.defineProperty(exports$1, "addCoins", { enumerable: true, get: function() {
      return coins_1.addCoins;
    } });
    Object.defineProperty(exports$1, "coin", { enumerable: true, get: function() {
      return coins_1.coin;
    } });
    Object.defineProperty(exports$1, "coins", { enumerable: true, get: function() {
      return coins_1.coins;
    } });
    Object.defineProperty(exports$1, "parseCoins", { enumerable: true, get: function() {
      return coins_1.parseCoins;
    } });
    var encoding_1 = require_encoding();
    Object.defineProperty(exports$1, "decodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.decodeAminoPubkey;
    } });
    Object.defineProperty(exports$1, "decodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.decodeBech32Pubkey;
    } });
    Object.defineProperty(exports$1, "encodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.encodeAminoPubkey;
    } });
    Object.defineProperty(exports$1, "encodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeBech32Pubkey;
    } });
    Object.defineProperty(exports$1, "encodeEd25519Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeEd25519Pubkey;
    } });
    Object.defineProperty(exports$1, "encodeSecp256k1Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeSecp256k1Pubkey;
    } });
    var multisig_1 = require_multisig2();
    Object.defineProperty(exports$1, "createMultisigThresholdPubkey", { enumerable: true, get: function() {
      return multisig_1.createMultisigThresholdPubkey;
    } });
    var omitdefault_1 = require_omitdefault();
    Object.defineProperty(exports$1, "omitDefault", { enumerable: true, get: function() {
      return omitdefault_1.omitDefault;
    } });
    var paths_1 = require_paths();
    Object.defineProperty(exports$1, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkeys_1 = require_pubkeys();
    Object.defineProperty(exports$1, "isEd25519Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isEd25519Pubkey;
    } });
    Object.defineProperty(exports$1, "isMultisigThresholdPubkey", { enumerable: true, get: function() {
      return pubkeys_1.isMultisigThresholdPubkey;
    } });
    Object.defineProperty(exports$1, "isSecp256k1Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSecp256k1Pubkey;
    } });
    Object.defineProperty(exports$1, "isSinglePubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSinglePubkey;
    } });
    Object.defineProperty(exports$1, "pubkeyType", { enumerable: true, get: function() {
      return pubkeys_1.pubkeyType;
    } });
    var secp256k1hdwallet_1 = require_secp256k1hdwallet();
    Object.defineProperty(exports$1, "extractKdfConfiguration", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.extractKdfConfiguration;
    } });
    Object.defineProperty(exports$1, "Secp256k1HdWallet", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.Secp256k1HdWallet;
    } });
    var secp256k1wallet_1 = require_secp256k1wallet();
    Object.defineProperty(exports$1, "Secp256k1Wallet", { enumerable: true, get: function() {
      return secp256k1wallet_1.Secp256k1Wallet;
    } });
    var signature_1 = require_signature();
    Object.defineProperty(exports$1, "decodeSignature", { enumerable: true, get: function() {
      return signature_1.decodeSignature;
    } });
    Object.defineProperty(exports$1, "encodeSecp256k1Signature", { enumerable: true, get: function() {
      return signature_1.encodeSecp256k1Signature;
    } });
    var signdoc_1 = require_signdoc();
    Object.defineProperty(exports$1, "makeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.makeSignDoc;
    } });
    Object.defineProperty(exports$1, "serializeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.serializeSignDoc;
    } });
    var stdtx_1 = require_stdtx();
    Object.defineProperty(exports$1, "isStdTx", { enumerable: true, get: function() {
      return stdtx_1.isStdTx;
    } });
    Object.defineProperty(exports$1, "makeStdTx", { enumerable: true, get: function() {
      return stdtx_1.makeStdTx;
    } });
    var wallet_1 = require_wallet();
    Object.defineProperty(exports$1, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/signing.js
var require_signing2 = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/signing.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.makeAuthInfoBytes = makeAuthInfoBytes;
    exports$1.makeSignDoc = makeSignDoc;
    exports$1.makeSignBytes = makeSignBytes;
    var utils_1 = require_build3();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    function makeSignerInfos(signers, signMode) {
      return signers.map(({ pubkey, sequence }) => ({
        publicKey: pubkey,
        modeInfo: {
          single: { mode: signMode }
        },
        sequence: BigInt(sequence)
      }));
    }
    function makeAuthInfoBytes(signers, feeAmount, gasLimit, feeGranter, feePayer, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
      (0, utils_1.assert)(feeGranter === void 0 || typeof feeGranter === "string", "feeGranter must be undefined or string");
      (0, utils_1.assert)(feePayer === void 0 || typeof feePayer === "string", "feePayer must be undefined or string");
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
          amount: [...feeAmount],
          gasLimit: BigInt(gasLimit),
          granter: feeGranter,
          payer: feePayer
        }
      });
      return tx_1.AuthInfo.encode(authInfo).finish();
    }
    function makeSignDoc(bodyBytes, authInfoBytes, chainId, accountNumber) {
      return {
        bodyBytes,
        authInfoBytes,
        chainId,
        accountNumber: BigInt(accountNumber)
      };
    }
    function makeSignBytes({ accountNumber, authInfoBytes, bodyBytes, chainId }) {
      const signDoc = tx_1.SignDoc.fromPartial({
        accountNumber,
        authInfoBytes,
        bodyBytes,
        chainId
      });
      return tx_1.SignDoc.encode(signDoc).finish();
    }
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/wallet.js
var require_wallet2 = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/wallet.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.supportedAlgorithms = exports$1.cosmjsSalt = void 0;
    exports$1.executeKdf = executeKdf;
    exports$1.encrypt = encrypt;
    exports$1.decrypt = decrypt;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    exports$1.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          const screamTest = (0, utils_1.sleep)(options.opsLimit * 250);
          const result2 = await crypto_1.Argon2id.execute(password, exports$1.cosmjsSalt, options);
          await screamTest;
          return result2;
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports$1.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports$1.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports$1.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js
var require_directsecp256k1hdwallet = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DirectSecp256k1HdWallet = void 0;
    exports$1.extractKdfConfiguration = extractKdfConfiguration;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var signing_1 = require_signing2();
    var wallet_1 = require_wallet2();
    var serializationTypeV1 = "directsecp256k1hdwallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    var defaultOptions2 = {
      hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var DirectSecp256k1HdWallet2 = class _DirectSecp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _DirectSecp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      /** Base secret */
      secret;
      /** BIP39 seed */
      seed;
      /** Derivation instructions */
      accounts;
      constructor(mnemonic, options) {
        const prefix = options.prefix ?? defaultOptions2.prefix;
        const hdPaths = options.hdPaths ?? defaultOptions2.hdPaths;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signDirect(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       *
       * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports$1.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet2;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js
var require_directsecp256k1wallet = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DirectSecp256k1Wallet = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var signing_1 = require_signing2();
    var DirectSecp256k1Wallet = class _DirectSecp256k1Wallet {
      /**
       * Creates a DirectSecp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _DirectSecp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      pubkey;
      privkey;
      prefix;
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signDirect(address, signDoc) {
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        if (address !== this.address) {
          throw new Error(`Address ${address} not found in wallet`);
        }
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
    };
    exports$1.DirectSecp256k1Wallet = DirectSecp256k1Wallet;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/paths.js
var require_paths2 = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/paths.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.makeCosmoshubPath = makeCosmoshubPath;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js
var require_keys = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.PrivKey = exports$1.PubKey = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.crypto.ed25519";
    function createBasePubKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports$1.PubKey = {
      typeUrl: "/cosmos.crypto.ed25519.PubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports$1.PrivKey = {
      typeUrl: "/cosmos.crypto.ed25519.PrivKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js
var require_keys2 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.LegacyAminoPubKey = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.crypto.multisig";
    function createBaseLegacyAminoPubKey() {
      return {
        threshold: 0,
        publicKeys: []
      };
    }
    exports$1.LegacyAminoPubKey = {
      typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== 0) {
          writer.uint32(8).uint32(message.threshold);
        }
        for (const v of message.publicKeys) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLegacyAminoPubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.threshold = reader.uint32();
              break;
            case 2:
              message.publicKeys.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLegacyAminoPubKey();
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = Number(object.threshold);
        if (Array.isArray(object?.publicKeys))
          obj.publicKeys = object.publicKeys.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.threshold !== void 0 && (obj.threshold = Math.round(message.threshold));
        if (message.publicKeys) {
          obj.publicKeys = message.publicKeys.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.publicKeys = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLegacyAminoPubKey();
        message.threshold = object.threshold ?? 0;
        message.publicKeys = object.publicKeys?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js
var require_keys3 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.PrivKey = exports$1.PubKey = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.crypto.secp256k1";
    function createBasePubKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports$1.PubKey = {
      typeUrl: "/cosmos.crypto.secp256k1.PubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports$1.PrivKey = {
      typeUrl: "/cosmos.crypto.secp256k1.PrivKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/pubkey.js
var require_pubkey = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/pubkey.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.encodePubkey = encodePubkey;
    exports$1.anyToSinglePubkey = anyToSinglePubkey;
    exports$1.decodePubkey = decodePubkey;
    exports$1.decodeOptionalPubkey = decodeOptionalPubkey;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var keys_1 = require_keys();
    var keys_2 = require_keys2();
    var keys_3 = require_keys3();
    var any_1 = require_any();
    function encodePubkey(pubkey) {
      if ((0, amino_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyProto = keys_3.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.secp256k1.PubKey",
          value: Uint8Array.from(keys_3.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyProto = keys_1.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.ed25519.PubKey",
          value: Uint8Array.from(keys_1.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyProto = keys_2.LegacyAminoPubKey.fromPartial({
          threshold: math_1.Uint53.fromString(pubkey.value.threshold).toNumber(),
          publicKeys: pubkey.value.pubkeys.map(encodePubkey)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
          value: Uint8Array.from(keys_2.LegacyAminoPubKey.encode(pubkeyProto).finish())
        });
      } else {
        throw new Error(`Pubkey type ${pubkey.type} not recognized`);
      }
    }
    function anyToSinglePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey": {
          const { key } = keys_3.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeSecp256k1Pubkey)(key);
        }
        case "/cosmos.crypto.ed25519.PubKey": {
          const { key } = keys_1.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeEd25519Pubkey)(key);
        }
        default:
          throw new Error(`Pubkey type_url ${pubkey.typeUrl} not recognized as single public key type`);
      }
    }
    function decodePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey":
        case "/cosmos.crypto.ed25519.PubKey": {
          return anyToSinglePubkey(pubkey);
        }
        case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
          const { threshold, publicKeys } = keys_2.LegacyAminoPubKey.decode(pubkey.value);
          const out = {
            type: "tendermint/PubKeyMultisigThreshold",
            value: {
              threshold: threshold.toString(),
              pubkeys: publicKeys.map(anyToSinglePubkey)
            }
          };
          return out;
        }
        default:
          throw new Error(`Pubkey type URL '${pubkey.typeUrl}' not recognized`);
      }
    }
    function decodeOptionalPubkey(pubkey) {
      if (!pubkey)
        return null;
      if (pubkey.typeUrl) {
        if (pubkey.value.length) {
          return decodePubkey(pubkey);
        } else {
          throw new Error(`Pubkey is an Any with type URL '${pubkey.typeUrl}' but an empty value`);
        }
      } else {
        if (pubkey.value.length) {
          throw new Error(`Pubkey is an Any with an empty type URL but a value set`);
        } else {
          return null;
        }
      }
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js
var require_bank = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Metadata = exports$1.DenomUnit = exports$1.Supply = exports$1.Output = exports$1.Input = exports$1.SendEnabled = exports$1.Params = exports$1.protobufPackage = void 0;
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseParams15() {
      return {
        sendEnabled: [],
        defaultSendEnabled: false
      };
    }
    exports$1.Params = {
      typeUrl: "/cosmos.bank.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.sendEnabled) {
          exports$1.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.defaultSendEnabled === true) {
          writer.uint32(16).bool(message.defaultSendEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled.push(exports$1.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 2:
              message.defaultSendEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if (Array.isArray(object?.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => exports$1.SendEnabled.fromJSON(e));
        if ((0, helpers_1.isSet)(object.defaultSendEnabled))
          obj.defaultSendEnabled = Boolean(object.defaultSendEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? exports$1.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        message.defaultSendEnabled !== void 0 && (obj.defaultSendEnabled = message.defaultSendEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        message.sendEnabled = object.sendEnabled?.map((e) => exports$1.SendEnabled.fromPartial(e)) || [];
        message.defaultSendEnabled = object.defaultSendEnabled ?? false;
        return message;
      }
    };
    function createBaseSendEnabled2() {
      return {
        denom: "",
        enabled: false
      };
    }
    exports$1.SendEnabled = {
      typeUrl: "/cosmos.bank.v1beta1.SendEnabled",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.enabled === true) {
          writer.uint32(16).bool(message.enabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendEnabled2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.enabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSendEnabled2();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.enabled))
          obj.enabled = Boolean(object.enabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.enabled !== void 0 && (obj.enabled = message.enabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSendEnabled2();
        message.denom = object.denom ?? "";
        message.enabled = object.enabled ?? false;
        return message;
      }
    };
    function createBaseInput2() {
      return {
        address: "",
        coins: []
      };
    }
    exports$1.Input = {
      typeUrl: "/cosmos.bank.v1beta1.Input",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInput2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInput2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if (Array.isArray(object?.coins))
          obj.coins = object.coins.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseInput2();
        message.address = object.address ?? "";
        message.coins = object.coins?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseOutput2() {
      return {
        address: "",
        coins: []
      };
    }
    exports$1.Output = {
      typeUrl: "/cosmos.bank.v1beta1.Output",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseOutput2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseOutput2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if (Array.isArray(object?.coins))
          obj.coins = object.coins.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseOutput2();
        message.address = object.address ?? "";
        message.coins = object.coins?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSupply() {
      return {
        total: []
      };
    }
    exports$1.Supply = {
      typeUrl: "/cosmos.bank.v1beta1.Supply",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.total) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSupply();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSupply();
        if (Array.isArray(object?.total))
          obj.total = object.total.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSupply();
        message.total = object.total?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDenomUnit2() {
      return {
        denom: "",
        exponent: 0,
        aliases: []
      };
    }
    exports$1.DenomUnit = {
      typeUrl: "/cosmos.bank.v1beta1.DenomUnit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.exponent !== 0) {
          writer.uint32(16).uint32(message.exponent);
        }
        for (const v of message.aliases) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomUnit2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.exponent = reader.uint32();
              break;
            case 3:
              message.aliases.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomUnit2();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.exponent))
          obj.exponent = Number(object.exponent);
        if (Array.isArray(object?.aliases))
          obj.aliases = object.aliases.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.exponent !== void 0 && (obj.exponent = Math.round(message.exponent));
        if (message.aliases) {
          obj.aliases = message.aliases.map((e) => e);
        } else {
          obj.aliases = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDenomUnit2();
        message.denom = object.denom ?? "";
        message.exponent = object.exponent ?? 0;
        message.aliases = object.aliases?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMetadata2() {
      return {
        description: "",
        denomUnits: [],
        base: "",
        display: "",
        name: "",
        symbol: "",
        uri: "",
        uriHash: ""
      };
    }
    exports$1.Metadata = {
      typeUrl: "/cosmos.bank.v1beta1.Metadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== "") {
          writer.uint32(10).string(message.description);
        }
        for (const v of message.denomUnits) {
          exports$1.DenomUnit.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.base !== "") {
          writer.uint32(26).string(message.base);
        }
        if (message.display !== "") {
          writer.uint32(34).string(message.display);
        }
        if (message.name !== "") {
          writer.uint32(42).string(message.name);
        }
        if (message.symbol !== "") {
          writer.uint32(50).string(message.symbol);
        }
        if (message.uri !== "") {
          writer.uint32(58).string(message.uri);
        }
        if (message.uriHash !== "") {
          writer.uint32(66).string(message.uriHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMetadata2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = reader.string();
              break;
            case 2:
              message.denomUnits.push(exports$1.DenomUnit.decode(reader, reader.uint32()));
              break;
            case 3:
              message.base = reader.string();
              break;
            case 4:
              message.display = reader.string();
              break;
            case 5:
              message.name = reader.string();
              break;
            case 6:
              message.symbol = reader.string();
              break;
            case 7:
              message.uri = reader.string();
              break;
            case 8:
              message.uriHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMetadata2();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if (Array.isArray(object?.denomUnits))
          obj.denomUnits = object.denomUnits.map((e) => exports$1.DenomUnit.fromJSON(e));
        if ((0, helpers_1.isSet)(object.base))
          obj.base = String(object.base);
        if ((0, helpers_1.isSet)(object.display))
          obj.display = String(object.display);
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.symbol))
          obj.symbol = String(object.symbol);
        if ((0, helpers_1.isSet)(object.uri))
          obj.uri = String(object.uri);
        if ((0, helpers_1.isSet)(object.uriHash))
          obj.uriHash = String(object.uriHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description);
        if (message.denomUnits) {
          obj.denomUnits = message.denomUnits.map((e) => e ? exports$1.DenomUnit.toJSON(e) : void 0);
        } else {
          obj.denomUnits = [];
        }
        message.base !== void 0 && (obj.base = message.base);
        message.display !== void 0 && (obj.display = message.display);
        message.name !== void 0 && (obj.name = message.name);
        message.symbol !== void 0 && (obj.symbol = message.symbol);
        message.uri !== void 0 && (obj.uri = message.uri);
        message.uriHash !== void 0 && (obj.uriHash = message.uriHash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMetadata2();
        message.description = object.description ?? "";
        message.denomUnits = object.denomUnits?.map((e) => exports$1.DenomUnit.fromPartial(e)) || [];
        message.base = object.base ?? "";
        message.display = object.display ?? "";
        message.name = object.name ?? "";
        message.symbol = object.symbol ?? "";
        message.uri = object.uri ?? "";
        message.uriHash = object.uriHash ?? "";
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js
var require_tx2 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgSetSendEnabledResponse = exports$1.MsgSetSendEnabled = exports$1.MsgUpdateParamsResponse = exports$1.MsgUpdateParams = exports$1.MsgMultiSendResponse = exports$1.MsgMultiSend = exports$1.MsgSendResponse = exports$1.MsgSend = exports$1.protobufPackage = void 0;
    var coin_1 = require_coin();
    var bank_1 = require_bank();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseMsgSend3() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: []
      };
    }
    exports$1.MsgSend = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSend3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSend3();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSend3();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgSendResponse3() {
      return {};
    }
    exports$1.MsgSendResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSendResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSendResponse3();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSendResponse3();
        return message;
      }
    };
    function createBaseMsgMultiSend2() {
      return {
        inputs: [],
        outputs: []
      };
    }
    exports$1.MsgMultiSend = {
      typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.inputs) {
          bank_1.Input.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.outputs) {
          bank_1.Output.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSend2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));
              break;
            case 2:
              message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgMultiSend2();
        if (Array.isArray(object?.inputs))
          obj.inputs = object.inputs.map((e) => bank_1.Input.fromJSON(e));
        if (Array.isArray(object?.outputs))
          obj.outputs = object.outputs.map((e) => bank_1.Output.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.inputs) {
          obj.inputs = message.inputs.map((e) => e ? bank_1.Input.toJSON(e) : void 0);
        } else {
          obj.inputs = [];
        }
        if (message.outputs) {
          obj.outputs = message.outputs.map((e) => e ? bank_1.Output.toJSON(e) : void 0);
        } else {
          obj.outputs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgMultiSend2();
        message.inputs = object.inputs?.map((e) => bank_1.Input.fromPartial(e)) || [];
        message.outputs = object.outputs?.map((e) => bank_1.Output.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgMultiSendResponse2() {
      return {};
    }
    exports$1.MsgMultiSendResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSendResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgMultiSendResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgMultiSendResponse2();
        return message;
      }
    };
    function createBaseMsgUpdateParams17() {
      return {
        authority: "",
        params: bank_1.Params.fromPartial({})
      };
    }
    exports$1.MsgUpdateParams = {
      typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          bank_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = bank_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams17();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = bank_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams17();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = bank_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse17() {
      return {};
    }
    exports$1.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse17();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse17();
        return message;
      }
    };
    function createBaseMsgSetSendEnabled2() {
      return {
        authority: "",
        sendEnabled: [],
        useDefaultFor: []
      };
    }
    exports$1.MsgSetSendEnabled = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        for (const v of message.sendEnabled) {
          bank_1.SendEnabled.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.useDefaultFor) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabled2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 3:
              message.useDefaultFor.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSetSendEnabled2();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if (Array.isArray(object?.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e));
        if (Array.isArray(object?.useDefaultFor))
          obj.useDefaultFor = object.useDefaultFor.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? bank_1.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        if (message.useDefaultFor) {
          obj.useDefaultFor = message.useDefaultFor.map((e) => e);
        } else {
          obj.useDefaultFor = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSetSendEnabled2();
        message.authority = object.authority ?? "";
        message.sendEnabled = object.sendEnabled?.map((e) => bank_1.SendEnabled.fromPartial(e)) || [];
        message.useDefaultFor = object.useDefaultFor?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMsgSetSendEnabledResponse2() {
      return {};
    }
    exports$1.MsgSetSendEnabledResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabledResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSetSendEnabledResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetSendEnabledResponse2();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Send = this.Send.bind(this);
        this.MultiSend = this.MultiSend.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.SetSendEnabled = this.SetSendEnabled.bind(this);
      }
      Send(request) {
        const data2 = exports$1.MsgSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", data2);
        return promise.then((data3) => exports$1.MsgSendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      MultiSend(request) {
        const data2 = exports$1.MsgMultiSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", data2);
        return promise.then((data3) => exports$1.MsgMultiSendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports$1.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports$1.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SetSendEnabled(request) {
        const data2 = exports$1.MsgSetSendEnabled.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", data2);
        return promise.then((data3) => exports$1.MsgSetSendEnabledResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/registry.js
var require_registry = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/registry.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Registry = void 0;
    exports$1.isTelescopeGeneratedType = isTelescopeGeneratedType;
    exports$1.isTsProtoGeneratedType = isTsProtoGeneratedType;
    exports$1.isPbjsGeneratedType = isPbjsGeneratedType;
    exports$1.isTxBodyEncodeObject = isTxBodyEncodeObject;
    var tx_1 = require_tx2();
    var coin_1 = require_coin();
    var tx_2 = require_tx();
    var any_1 = require_any();
    function isTelescopeGeneratedType(type2) {
      const casted = type2;
      return typeof casted.fromPartial === "function" && typeof casted.typeUrl == "string";
    }
    function isTsProtoGeneratedType(type2) {
      return typeof type2.fromPartial === "function";
    }
    function isPbjsGeneratedType(type2) {
      return !isTsProtoGeneratedType(type2);
    }
    var defaultTypeUrls = {
      cosmosCoin: "/cosmos.base.v1beta1.Coin",
      cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
      cosmosTxBody: "/cosmos.tx.v1beta1.TxBody"};
    function isTxBodyEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.tx.v1beta1.TxBody";
    }
    var Registry2 = class {
      types;
      /**
       * Creates a new Registry for mapping protobuf type identifiers/type URLs to
       * actual implementations. Those implementations are typically generated with ts-proto
       * but we also support protobuf.js as a type generator.
       *
       * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
       * for historic reasons. Those can be overridden by customTypes.
       *
       * There are currently two methods for adding new types:
       * 1. Passing types to the constructor.
       * 2. Using the `register()` method
       */
      constructor(customTypes) {
        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;
        this.types = customTypes ? new Map([...customTypes]) : /* @__PURE__ */ new Map([
          [cosmosCoin, coin_1.Coin],
          [cosmosMsgSend, tx_1.MsgSend]
        ]);
      }
      register(typeUrl, type2) {
        this.types.set(typeUrl, type2);
      }
      /**
       * Looks up a type that was previously added to the registry.
       *
       * The generator information (ts-proto or pbjs) gets lost along the way.
       * If you need to work with the result type in TypeScript, you can use:
       *
       * ```
       * import { assert } from "@cosmjs/utils";
       *
       * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
       * assert(Coin); // Ensures not unset
       * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
       *
       * // Coin is typed TsProtoGeneratedType now.
       * ```
       */
      lookupType(typeUrl) {
        return this.types.get(typeUrl);
      }
      lookupTypeWithError(typeUrl) {
        const type2 = this.lookupType(typeUrl);
        if (!type2) {
          throw new Error(`Unregistered type url: ${typeUrl}`);
        }
        return type2;
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to protobuf if
       * the given type was previously registered.
       *
       * If the value has to be wrapped in an Any, this needs to be done
       * manually after this call. Or use `encodeAsAny` instead.
       */
      encode(encodeObject) {
        const { value, typeUrl } = encodeObject;
        if (isTxBodyEncodeObject(encodeObject)) {
          return this.encodeTxBody(value);
        }
        const type2 = this.lookupTypeWithError(typeUrl);
        const instance3 = isTelescopeGeneratedType(type2) || isTsProtoGeneratedType(type2) ? type2.fromPartial(value) : type2.create(value);
        return type2.encode(instance3).finish();
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to an Any if
       * the given type was previously registered.
       */
      encodeAsAny(encodeObject) {
        const binaryValue = this.encode(encodeObject);
        return any_1.Any.fromPartial({
          typeUrl: encodeObject.typeUrl,
          value: binaryValue
        });
      }
      encodeTxBody(txBodyFields) {
        const wrappedMessages = txBodyFields.messages.map((message) => this.encodeAsAny(message));
        const txBody = tx_2.TxBody.fromPartial({
          ...txBodyFields,
          timeoutHeight: BigInt(txBodyFields.timeoutHeight?.toString() ?? "0"),
          messages: wrappedMessages
        });
        return tx_2.TxBody.encode(txBody).finish();
      }
      decode({ typeUrl, value }) {
        if (typeUrl === defaultTypeUrls.cosmosTxBody) {
          return this.decodeTxBody(value);
        }
        const type2 = this.lookupTypeWithError(typeUrl);
        const decoded = type2.decode(value);
        Object.entries(decoded).forEach(([key, val]) => {
          if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined" && Buffer.isBuffer(val)) {
            decoded[key] = Uint8Array.from(val);
          }
        });
        return decoded;
      }
      decodeTxBody(txBody) {
        const decodedTxBody = tx_2.TxBody.decode(txBody);
        return {
          ...decodedTxBody,
          messages: decodedTxBody.messages.map(({ typeUrl, value }) => {
            if (!typeUrl) {
              throw new Error("Missing type_url in Any");
            }
            if (!value) {
              throw new Error("Missing value in Any");
            }
            return this.decode({ typeUrl, value });
          })
        };
      }
    };
    exports$1.Registry = Registry2;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/signer.js
var require_signer = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/signer.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isOfflineDirectSigner = isOfflineDirectSigner;
    function isOfflineDirectSigner(signer) {
      return signer.signDirect !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/index.js
var require_build6 = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.parseCoins = exports$1.coins = exports$1.coin = exports$1.executeKdf = exports$1.makeSignDoc = exports$1.makeSignBytes = exports$1.makeAuthInfoBytes = exports$1.isOfflineDirectSigner = exports$1.Registry = exports$1.isTxBodyEncodeObject = exports$1.isTsProtoGeneratedType = exports$1.isPbjsGeneratedType = exports$1.encodePubkey = exports$1.decodePubkey = exports$1.decodeOptionalPubkey = exports$1.anyToSinglePubkey = exports$1.makeCosmoshubPath = exports$1.DirectSecp256k1Wallet = exports$1.extractKdfConfiguration = exports$1.DirectSecp256k1HdWallet = exports$1.decodeTxRaw = void 0;
    var decode_1 = require_decode();
    Object.defineProperty(exports$1, "decodeTxRaw", { enumerable: true, get: function() {
      return decode_1.decodeTxRaw;
    } });
    var directsecp256k1hdwallet_1 = require_directsecp256k1hdwallet();
    Object.defineProperty(exports$1, "DirectSecp256k1HdWallet", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.DirectSecp256k1HdWallet;
    } });
    Object.defineProperty(exports$1, "extractKdfConfiguration", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.extractKdfConfiguration;
    } });
    var directsecp256k1wallet_1 = require_directsecp256k1wallet();
    Object.defineProperty(exports$1, "DirectSecp256k1Wallet", { enumerable: true, get: function() {
      return directsecp256k1wallet_1.DirectSecp256k1Wallet;
    } });
    var paths_1 = require_paths2();
    Object.defineProperty(exports$1, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkey_1 = require_pubkey();
    Object.defineProperty(exports$1, "anyToSinglePubkey", { enumerable: true, get: function() {
      return pubkey_1.anyToSinglePubkey;
    } });
    Object.defineProperty(exports$1, "decodeOptionalPubkey", { enumerable: true, get: function() {
      return pubkey_1.decodeOptionalPubkey;
    } });
    Object.defineProperty(exports$1, "decodePubkey", { enumerable: true, get: function() {
      return pubkey_1.decodePubkey;
    } });
    Object.defineProperty(exports$1, "encodePubkey", { enumerable: true, get: function() {
      return pubkey_1.encodePubkey;
    } });
    var registry_1 = require_registry();
    Object.defineProperty(exports$1, "isPbjsGeneratedType", { enumerable: true, get: function() {
      return registry_1.isPbjsGeneratedType;
    } });
    Object.defineProperty(exports$1, "isTsProtoGeneratedType", { enumerable: true, get: function() {
      return registry_1.isTsProtoGeneratedType;
    } });
    Object.defineProperty(exports$1, "isTxBodyEncodeObject", { enumerable: true, get: function() {
      return registry_1.isTxBodyEncodeObject;
    } });
    Object.defineProperty(exports$1, "Registry", { enumerable: true, get: function() {
      return registry_1.Registry;
    } });
    var signer_1 = require_signer();
    Object.defineProperty(exports$1, "isOfflineDirectSigner", { enumerable: true, get: function() {
      return signer_1.isOfflineDirectSigner;
    } });
    var signing_1 = require_signing2();
    Object.defineProperty(exports$1, "makeAuthInfoBytes", { enumerable: true, get: function() {
      return signing_1.makeAuthInfoBytes;
    } });
    Object.defineProperty(exports$1, "makeSignBytes", { enumerable: true, get: function() {
      return signing_1.makeSignBytes;
    } });
    Object.defineProperty(exports$1, "makeSignDoc", { enumerable: true, get: function() {
      return signing_1.makeSignDoc;
    } });
    var wallet_1 = require_wallet2();
    Object.defineProperty(exports$1, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
    var amino_1 = require_build5();
    Object.defineProperty(exports$1, "coin", { enumerable: true, get: function() {
      return amino_1.coin;
    } });
    Object.defineProperty(exports$1, "coins", { enumerable: true, get: function() {
      return amino_1.coins;
    } });
    Object.defineProperty(exports$1, "parseCoins", { enumerable: true, get: function() {
      return amino_1.parseCoins;
    } });
  }
});

// ../../node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js
var require_auth = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = exports$1.ModuleCredential = exports$1.ModuleAccount = exports$1.BaseAccount = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseBaseAccount2() {
      return {
        address: "",
        pubKey: void 0,
        accountNumber: BigInt(0),
        sequence: BigInt(0)
      };
    }
    exports$1.BaseAccount = {
      typeUrl: "/cosmos.auth.v1beta1.BaseAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pubKey !== void 0) {
          any_1.Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.accountNumber);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(32).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseAccount2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pubKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.accountNumber = reader.uint64();
              break;
            case 4:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBaseAccount2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = any_1.Any.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? any_1.Any.toJSON(message.pubKey) : void 0);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBaseAccount2();
        message.address = object.address ?? "";
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = any_1.Any.fromPartial(object.pubKey);
        }
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseModuleAccount() {
      return {
        baseAccount: void 0,
        name: "",
        permissions: []
      };
    }
    exports$1.ModuleAccount = {
      typeUrl: "/cosmos.auth.v1beta1.ModuleAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== void 0) {
          exports$1.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        for (const v of message.permissions) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = exports$1.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.permissions.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleAccount();
        if ((0, helpers_1.isSet)(object.baseAccount))
          obj.baseAccount = exports$1.BaseAccount.fromJSON(object.baseAccount);
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if (Array.isArray(object?.permissions))
          obj.permissions = object.permissions.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? exports$1.BaseAccount.toJSON(message.baseAccount) : void 0);
        message.name !== void 0 && (obj.name = message.name);
        if (message.permissions) {
          obj.permissions = message.permissions.map((e) => e);
        } else {
          obj.permissions = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModuleAccount();
        if (object.baseAccount !== void 0 && object.baseAccount !== null) {
          message.baseAccount = exports$1.BaseAccount.fromPartial(object.baseAccount);
        }
        message.name = object.name ?? "";
        message.permissions = object.permissions?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseModuleCredential() {
      return {
        moduleName: "",
        derivationKeys: []
      };
    }
    exports$1.ModuleCredential = {
      typeUrl: "/cosmos.auth.v1beta1.ModuleCredential",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.moduleName !== "") {
          writer.uint32(10).string(message.moduleName);
        }
        for (const v of message.derivationKeys) {
          writer.uint32(18).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleCredential();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moduleName = reader.string();
              break;
            case 2:
              message.derivationKeys.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleCredential();
        if ((0, helpers_1.isSet)(object.moduleName))
          obj.moduleName = String(object.moduleName);
        if (Array.isArray(object?.derivationKeys))
          obj.derivationKeys = object.derivationKeys.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.moduleName !== void 0 && (obj.moduleName = message.moduleName);
        if (message.derivationKeys) {
          obj.derivationKeys = message.derivationKeys.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.derivationKeys = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModuleCredential();
        message.moduleName = object.moduleName ?? "";
        message.derivationKeys = object.derivationKeys?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseParams15() {
      return {
        maxMemoCharacters: BigInt(0),
        txSigLimit: BigInt(0),
        txSizeCostPerByte: BigInt(0),
        sigVerifyCostEd25519: BigInt(0),
        sigVerifyCostSecp256k1: BigInt(0)
      };
    }
    exports$1.Params = {
      typeUrl: "/cosmos.auth.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxMemoCharacters !== BigInt(0)) {
          writer.uint32(8).uint64(message.maxMemoCharacters);
        }
        if (message.txSigLimit !== BigInt(0)) {
          writer.uint32(16).uint64(message.txSigLimit);
        }
        if (message.txSizeCostPerByte !== BigInt(0)) {
          writer.uint32(24).uint64(message.txSizeCostPerByte);
        }
        if (message.sigVerifyCostEd25519 !== BigInt(0)) {
          writer.uint32(32).uint64(message.sigVerifyCostEd25519);
        }
        if (message.sigVerifyCostSecp256k1 !== BigInt(0)) {
          writer.uint32(40).uint64(message.sigVerifyCostSecp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxMemoCharacters = reader.uint64();
              break;
            case 2:
              message.txSigLimit = reader.uint64();
              break;
            case 3:
              message.txSizeCostPerByte = reader.uint64();
              break;
            case 4:
              message.sigVerifyCostEd25519 = reader.uint64();
              break;
            case 5:
              message.sigVerifyCostSecp256k1 = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if ((0, helpers_1.isSet)(object.maxMemoCharacters))
          obj.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        if ((0, helpers_1.isSet)(object.txSigLimit))
          obj.txSigLimit = BigInt(object.txSigLimit.toString());
        if ((0, helpers_1.isSet)(object.txSizeCostPerByte))
          obj.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostEd25519))
          obj.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostSecp256k1))
          obj.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxMemoCharacters !== void 0 && (obj.maxMemoCharacters = (message.maxMemoCharacters || BigInt(0)).toString());
        message.txSigLimit !== void 0 && (obj.txSigLimit = (message.txSigLimit || BigInt(0)).toString());
        message.txSizeCostPerByte !== void 0 && (obj.txSizeCostPerByte = (message.txSizeCostPerByte || BigInt(0)).toString());
        message.sigVerifyCostEd25519 !== void 0 && (obj.sigVerifyCostEd25519 = (message.sigVerifyCostEd25519 || BigInt(0)).toString());
        message.sigVerifyCostSecp256k1 !== void 0 && (obj.sigVerifyCostSecp256k1 = (message.sigVerifyCostSecp256k1 || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        if (object.maxMemoCharacters !== void 0 && object.maxMemoCharacters !== null) {
          message.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        }
        if (object.txSigLimit !== void 0 && object.txSigLimit !== null) {
          message.txSigLimit = BigInt(object.txSigLimit.toString());
        }
        if (object.txSizeCostPerByte !== void 0 && object.txSizeCostPerByte !== null) {
          message.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        }
        if (object.sigVerifyCostEd25519 !== void 0 && object.sigVerifyCostEd25519 !== null) {
          message.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        }
        if (object.sigVerifyCostSecp256k1 !== void 0 && object.sigVerifyCostSecp256k1 !== null) {
          message.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js
var require_vesting = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.PermanentLockedAccount = exports$1.PeriodicVestingAccount = exports$1.Period = exports$1.DelayedVestingAccount = exports$1.ContinuousVestingAccount = exports$1.BaseVestingAccount = exports$1.protobufPackage = void 0;
    var auth_1 = require_auth();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseBaseVestingAccount() {
      return {
        baseAccount: void 0,
        originalVesting: [],
        delegatedFree: [],
        delegatedVesting: [],
        endTime: BigInt(0)
      };
    }
    exports$1.BaseVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.BaseVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== void 0) {
          auth_1.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.originalVesting) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.delegatedFree) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.delegatedVesting) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.endTime !== BigInt(0)) {
          writer.uint32(40).int64(message.endTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.originalVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.delegatedFree.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.delegatedVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.endTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBaseVestingAccount();
        if ((0, helpers_1.isSet)(object.baseAccount))
          obj.baseAccount = auth_1.BaseAccount.fromJSON(object.baseAccount);
        if (Array.isArray(object?.originalVesting))
          obj.originalVesting = object.originalVesting.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object?.delegatedFree))
          obj.delegatedFree = object.delegatedFree.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object?.delegatedVesting))
          obj.delegatedVesting = object.delegatedVesting.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime))
          obj.endTime = BigInt(object.endTime.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? auth_1.BaseAccount.toJSON(message.baseAccount) : void 0);
        if (message.originalVesting) {
          obj.originalVesting = message.originalVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.originalVesting = [];
        }
        if (message.delegatedFree) {
          obj.delegatedFree = message.delegatedFree.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedFree = [];
        }
        if (message.delegatedVesting) {
          obj.delegatedVesting = message.delegatedVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedVesting = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBaseVestingAccount();
        if (object.baseAccount !== void 0 && object.baseAccount !== null) {
          message.baseAccount = auth_1.BaseAccount.fromPartial(object.baseAccount);
        }
        message.originalVesting = object.originalVesting?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.delegatedFree = object.delegatedFree?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.delegatedVesting = object.delegatedVesting?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.endTime !== void 0 && object.endTime !== null) {
          message.endTime = BigInt(object.endTime.toString());
        }
        return message;
      }
    };
    function createBaseContinuousVestingAccount() {
      return {
        baseVestingAccount: void 0,
        startTime: BigInt(0)
      };
    }
    exports$1.ContinuousVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.ContinuousVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports$1.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(16).int64(message.startTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContinuousVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports$1.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseContinuousVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports$1.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports$1.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseContinuousVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports$1.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        return message;
      }
    };
    function createBaseDelayedVestingAccount() {
      return {
        baseVestingAccount: void 0
      };
    }
    exports$1.DelayedVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.DelayedVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports$1.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelayedVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports$1.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelayedVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports$1.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports$1.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelayedVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports$1.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        return message;
      }
    };
    function createBasePeriod2() {
      return {
        length: BigInt(0),
        amount: []
      };
    }
    exports$1.Period = {
      typeUrl: "/cosmos.vesting.v1beta1.Period",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.length !== BigInt(0)) {
          writer.uint32(8).int64(message.length);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriod2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.length = reader.int64();
              break;
            case 2:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriod2();
        if ((0, helpers_1.isSet)(object.length))
          obj.length = BigInt(object.length.toString());
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.length !== void 0 && (obj.length = (message.length || BigInt(0)).toString());
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBasePeriod2();
        if (object.length !== void 0 && object.length !== null) {
          message.length = BigInt(object.length.toString());
        }
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBasePeriodicVestingAccount() {
      return {
        baseVestingAccount: void 0,
        startTime: BigInt(0),
        vestingPeriods: []
      };
    }
    exports$1.PeriodicVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.PeriodicVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports$1.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(16).int64(message.startTime);
        }
        for (const v of message.vestingPeriods) {
          exports$1.Period.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports$1.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            case 3:
              message.vestingPeriods.push(exports$1.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriodicVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports$1.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object?.vestingPeriods))
          obj.vestingPeriods = object.vestingPeriods.map((e) => exports$1.Period.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports$1.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? exports$1.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBasePeriodicVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports$1.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        message.vestingPeriods = object.vestingPeriods?.map((e) => exports$1.Period.fromPartial(e)) || [];
        return message;
      }
    };
    function createBasePermanentLockedAccount() {
      return {
        baseVestingAccount: void 0
      };
    }
    exports$1.PermanentLockedAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.PermanentLockedAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports$1.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePermanentLockedAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports$1.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePermanentLockedAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports$1.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports$1.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePermanentLockedAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports$1.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        return message;
      }
    };
  }
});

// ../../node_modules/@cosmjs/stargate/build/accounts.js
var require_accounts = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/accounts.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.accountFromAny = accountFromAny;
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    var auth_1 = require_auth();
    var vesting_1 = require_vesting();
    function uint64FromProto(input) {
      return math_1.Uint64.fromString(input.toString());
    }
    function accountFromBaseAccount(input) {
      const { address, pubKey, accountNumber, sequence } = input;
      const pubkey = (0, proto_signing_1.decodeOptionalPubkey)(pubKey);
      return {
        address,
        pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
      };
    }
    function accountFromAny(input) {
      const { typeUrl, value } = input;
      switch (typeUrl) {
        // auth
        case "/cosmos.auth.v1beta1.BaseAccount":
          return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount": {
          const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        // vesting
        case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
          const baseAccount = vesting_1.BaseVestingAccount.decode(value)?.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
          const baseAccount = vesting_1.ContinuousVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
          const baseAccount = vesting_1.DelayedVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
          const baseAccount = vesting_1.PeriodicVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        default:
          throw new Error(`Unsupported type: '${typeUrl}'`);
      }
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/aminotypes.js
var require_aminotypes = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/aminotypes.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.AminoTypes = void 0;
    var AminoTypes = class {
      // The map type here ensures uniqueness of the protobuf type URL in the key.
      // There is no uniqueness guarantee of the Amino type identifier in the type
      // system or constructor. Instead it's the user's responsibility to ensure
      // there is no overlap when fromAmino is called.
      register;
      constructor(types) {
        this.register = types;
      }
      toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (!converter) {
          throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
        }
        return {
          type: converter.aminoType,
          value: converter.toAmino(value)
        };
      }
      fromAmino({ type: type2, value }) {
        const matches = Object.entries(this.register).filter(([_typeUrl, { aminoType }]) => aminoType === type2);
        switch (matches.length) {
          case 0: {
            throw new Error(`Amino type identifier '${type2}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
          }
          case 1: {
            const [typeUrl, converter] = matches[0];
            return {
              typeUrl,
              value: converter.fromAmino(value)
            };
          }
          default:
            throw new Error(`Multiple types are registered with Amino type identifier '${type2}': '` + matches.map(([key, _value]) => key).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
        }
      }
    };
    exports$1.AminoTypes = AminoTypes;
  }
});

// ../../node_modules/@cosmjs/stargate/build/events.js
var require_events = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/events.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.fromTendermintEvent = fromTendermintEvent;
    var encoding_1 = require_build2();
    function fromTendermintEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes.map((attr) => ({
          key: typeof attr.key == "string" ? attr.key : (0, encoding_1.fromUtf8)(attr.key, true),
          value: typeof attr.value == "string" ? attr.value : (0, encoding_1.fromUtf8)(attr.value, true)
        }))
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/fee.js
var require_fee = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/fee.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.GasPrice = void 0;
    exports$1.calculateFee = calculateFee2;
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    function checkDenom(denom) {
      if (denom.length < 3 || denom.length > 128) {
        throw new Error("Denom must be between 3 and 128 characters");
      }
    }
    var GasPrice2 = class _GasPrice {
      amount;
      denom;
      constructor(amount, denom) {
        if (!denom) {
          throw new Error("denom must not be empty");
        }
        this.amount = amount;
        this.denom = denom;
      }
      /**
       * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
       *
       * The denom must match the Cosmos SDK 0.53 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/types/coin.go#L846).
       * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
       *
       * Separators are not yet supported.
       */
      static fromString(gasPrice) {
        const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
        if (!matchResult) {
          throw new Error("Invalid gas price string");
        }
        const [_, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new _GasPrice(decimalAmount, denom);
      }
      /**
       * Returns a string representation of this gas price, e.g. "0.025uatom".
       * This can be used as an input to `GasPrice.fromString`.
       */
      toString() {
        return this.amount.toString() + this.denom;
      }
    };
    exports$1.GasPrice = GasPrice2;
    function calculateFee2(gasLimit, gasPrice) {
      const processedGasPrice = typeof gasPrice === "string" ? GasPrice2.fromString(gasPrice) : gasPrice;
      const { denom, amount: gasPriceAmount } = processedGasPrice;
      const amount = gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).ceil().toString();
      return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/logs.js
var require_logs = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/logs.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.parseAttribute = parseAttribute;
    exports$1.parseEvent = parseEvent;
    exports$1.parseLog = parseLog;
    exports$1.parseLogs = parseLogs;
    exports$1.parseRawLog = parseRawLog;
    exports$1.findAttribute = findAttribute;
    var utils_1 = require_build3();
    function parseAttribute(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Attribute must be a non-null object");
      const { key, value } = input;
      if (typeof key !== "string" || !key)
        throw new Error("Attribute's key must be a non-empty string");
      if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
      }
      return {
        key,
        value: value || ""
      };
    }
    function parseEvent(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Event must be a non-null object");
      const { type: type2, attributes } = input;
      if (typeof type2 !== "string" || type2 === "") {
        throw new Error(`Event type must be a non-empty string`);
      }
      if (!Array.isArray(attributes))
        throw new Error("Event's attributes must be an array");
      return {
        type: type2,
        attributes: attributes.map(parseAttribute)
      };
    }
    function parseLog(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Log must be a non-null object");
      const { msg_index, log, events } = input;
      if (typeof msg_index !== "number")
        throw new Error("Log's msg_index must be a number");
      if (typeof log !== "string")
        throw new Error("Log's log must be a string");
      if (!Array.isArray(events))
        throw new Error("Log's events must be an array");
      return {
        msg_index,
        log,
        events: events.map(parseEvent)
      };
    }
    function parseLogs(input) {
      if (!Array.isArray(input))
        throw new Error("Logs must be an array");
      return input.map(parseLog);
    }
    function parseRawLog(input) {
      if (!input)
        return [];
      const logsToParse = JSON.parse(input).map(({ events }, i) => ({
        msg_index: i,
        events,
        log: ""
      }));
      return parseLogs(logsToParse);
    }
    function findAttribute(logs, eventType, attrKey) {
      const firstLogs = logs.find(() => true);
      const out = firstLogs?.events.find((event) => event.type === eventType)?.attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js
var require_pagination = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.PageResponse = exports$1.PageRequest = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.base.query.v1beta1";
    function createBasePageRequest2() {
      return {
        key: new Uint8Array(),
        offset: BigInt(0),
        limit: BigInt(0),
        countTotal: false,
        reverse: false
      };
    }
    exports$1.PageRequest = {
      typeUrl: "/cosmos.base.query.v1beta1.PageRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.offset !== BigInt(0)) {
          writer.uint32(16).uint64(message.offset);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(24).uint64(message.limit);
        }
        if (message.countTotal === true) {
          writer.uint32(32).bool(message.countTotal);
        }
        if (message.reverse === true) {
          writer.uint32(40).bool(message.reverse);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePageRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.offset = reader.uint64();
              break;
            case 3:
              message.limit = reader.uint64();
              break;
            case 4:
              message.countTotal = reader.bool();
              break;
            case 5:
              message.reverse = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePageRequest2();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.offset))
          obj.offset = BigInt(object.offset.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.countTotal))
          obj.countTotal = Boolean(object.countTotal);
        if ((0, helpers_1.isSet)(object.reverse))
          obj.reverse = Boolean(object.reverse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.offset !== void 0 && (obj.offset = (message.offset || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        message.countTotal !== void 0 && (obj.countTotal = message.countTotal);
        message.reverse !== void 0 && (obj.reverse = message.reverse);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePageRequest2();
        message.key = object.key ?? new Uint8Array();
        if (object.offset !== void 0 && object.offset !== null) {
          message.offset = BigInt(object.offset.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.countTotal = object.countTotal ?? false;
        message.reverse = object.reverse ?? false;
        return message;
      }
    };
    function createBasePageResponse2() {
      return {
        nextKey: new Uint8Array(),
        total: BigInt(0)
      };
    }
    exports$1.PageResponse = {
      typeUrl: "/cosmos.base.query.v1beta1.PageResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextKey.length !== 0) {
          writer.uint32(10).bytes(message.nextKey);
        }
        if (message.total !== BigInt(0)) {
          writer.uint32(16).uint64(message.total);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePageResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextKey = reader.bytes();
              break;
            case 2:
              message.total = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePageResponse2();
        if ((0, helpers_1.isSet)(object.nextKey))
          obj.nextKey = (0, helpers_1.bytesFromBase64)(object.nextKey);
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextKey !== void 0 && (obj.nextKey = (0, helpers_1.base64FromBytes)(message.nextKey !== void 0 ? message.nextKey : new Uint8Array()));
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePageResponse2();
        message.nextKey = object.nextKey ?? new Uint8Array();
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js
var require_query = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryAccountInfoResponse = exports$1.QueryAccountInfoRequest = exports$1.QueryAccountAddressByIDResponse = exports$1.QueryAccountAddressByIDRequest = exports$1.AddressStringToBytesResponse = exports$1.AddressStringToBytesRequest = exports$1.AddressBytesToStringResponse = exports$1.AddressBytesToStringRequest = exports$1.Bech32PrefixResponse = exports$1.Bech32PrefixRequest = exports$1.QueryModuleAccountByNameResponse = exports$1.QueryModuleAccountByNameRequest = exports$1.QueryModuleAccountsResponse = exports$1.QueryModuleAccountsRequest = exports$1.QueryParamsResponse = exports$1.QueryParamsRequest = exports$1.QueryAccountResponse = exports$1.QueryAccountRequest = exports$1.QueryAccountsResponse = exports$1.QueryAccountsRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    var auth_1 = require_auth();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseQueryAccountsRequest4() {
      return {
        pagination: void 0
      };
    }
    exports$1.QueryAccountsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsRequest4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountsRequest4();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountsRequest4();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAccountsResponse3() {
      return {
        accounts: [],
        pagination: void 0
      };
    }
    exports$1.QueryAccountsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.accounts) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountsResponse3();
        if (Array.isArray(object?.accounts))
          obj.accounts = object.accounts.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountsResponse3();
        message.accounts = object.accounts?.map((e) => any_1.Any.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAccountRequest3() {
      return {
        address: ""
      };
    }
    exports$1.QueryAccountRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountRequest3();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountRequest3();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryAccountResponse2() {
      return {
        account: void 0
      };
    }
    exports$1.QueryAccountResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountResponse2();
        if ((0, helpers_1.isSet)(object.account))
          obj.account = any_1.Any.fromJSON(object.account);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountResponse2();
        if (object.account !== void 0 && object.account !== null) {
          message.account = any_1.Any.fromPartial(object.account);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest18() {
      return {};
    }
    exports$1.QueryParamsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest18();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest18();
        return message;
      }
    };
    function createBaseQueryParamsResponse18() {
      return {
        params: auth_1.Params.fromPartial({})
      };
    }
    exports$1.QueryParamsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          auth_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = auth_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse18();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = auth_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? auth_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse18();
        if (object.params !== void 0 && object.params !== null) {
          message.params = auth_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryModuleAccountsRequest2() {
      return {};
    }
    exports$1.QueryModuleAccountsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryModuleAccountsRequest2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryModuleAccountsRequest2();
        return message;
      }
    };
    function createBaseQueryModuleAccountsResponse2() {
      return {
        accounts: []
      };
    }
    exports$1.QueryModuleAccountsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.accounts) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountsResponse2();
        if (Array.isArray(object?.accounts))
          obj.accounts = object.accounts.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountsResponse2();
        message.accounts = object.accounts?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseQueryModuleAccountByNameRequest2() {
      return {
        name: ""
      };
    }
    exports$1.QueryModuleAccountByNameRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountByNameRequest2();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountByNameRequest2();
        message.name = object.name ?? "";
        return message;
      }
    };
    function createBaseQueryModuleAccountByNameResponse2() {
      return {
        account: void 0
      };
    }
    exports$1.QueryModuleAccountByNameResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountByNameResponse2();
        if ((0, helpers_1.isSet)(object.account))
          obj.account = any_1.Any.fromJSON(object.account);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountByNameResponse2();
        if (object.account !== void 0 && object.account !== null) {
          message.account = any_1.Any.fromPartial(object.account);
        }
        return message;
      }
    };
    function createBaseBech32PrefixRequest2() {
      return {};
    }
    exports$1.Bech32PrefixRequest = {
      typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseBech32PrefixRequest2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseBech32PrefixRequest2();
        return message;
      }
    };
    function createBaseBech32PrefixResponse2() {
      return {
        bech32Prefix: ""
      };
    }
    exports$1.Bech32PrefixResponse = {
      typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bech32Prefix !== "") {
          writer.uint32(10).string(message.bech32Prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bech32Prefix = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBech32PrefixResponse2();
        if ((0, helpers_1.isSet)(object.bech32Prefix))
          obj.bech32Prefix = String(object.bech32Prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bech32Prefix !== void 0 && (obj.bech32Prefix = message.bech32Prefix);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBech32PrefixResponse2();
        message.bech32Prefix = object.bech32Prefix ?? "";
        return message;
      }
    };
    function createBaseAddressBytesToStringRequest2() {
      return {
        addressBytes: new Uint8Array()
      };
    }
    exports$1.AddressBytesToStringRequest = {
      typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) {
          writer.uint32(10).bytes(message.addressBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressBytesToStringRequest2();
        if ((0, helpers_1.isSet)(object.addressBytes))
          obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressBytes !== void 0 && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== void 0 ? message.addressBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressBytesToStringRequest2();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseAddressBytesToStringResponse2() {
      return {
        addressString: ""
      };
    }
    exports$1.AddressBytesToStringResponse = {
      typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") {
          writer.uint32(10).string(message.addressString);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressString = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressBytesToStringResponse2();
        if ((0, helpers_1.isSet)(object.addressString))
          obj.addressString = String(object.addressString);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressString !== void 0 && (obj.addressString = message.addressString);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressBytesToStringResponse2();
        message.addressString = object.addressString ?? "";
        return message;
      }
    };
    function createBaseAddressStringToBytesRequest2() {
      return {
        addressString: ""
      };
    }
    exports$1.AddressStringToBytesRequest = {
      typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") {
          writer.uint32(10).string(message.addressString);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressString = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressStringToBytesRequest2();
        if ((0, helpers_1.isSet)(object.addressString))
          obj.addressString = String(object.addressString);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressString !== void 0 && (obj.addressString = message.addressString);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressStringToBytesRequest2();
        message.addressString = object.addressString ?? "";
        return message;
      }
    };
    function createBaseAddressStringToBytesResponse2() {
      return {
        addressBytes: new Uint8Array()
      };
    }
    exports$1.AddressStringToBytesResponse = {
      typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) {
          writer.uint32(10).bytes(message.addressBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressStringToBytesResponse2();
        if ((0, helpers_1.isSet)(object.addressBytes))
          obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressBytes !== void 0 && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== void 0 ? message.addressBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressStringToBytesResponse2();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryAccountAddressByIDRequest2() {
      return {
        id: BigInt(0),
        accountId: BigInt(0)
      };
    }
    exports$1.QueryAccountAddressByIDRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).int64(message.id);
        }
        if (message.accountId !== BigInt(0)) {
          writer.uint32(16).uint64(message.accountId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.int64();
              break;
            case 2:
              message.accountId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountAddressByIDRequest2();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.accountId))
          obj.accountId = BigInt(object.accountId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.accountId !== void 0 && (obj.accountId = (message.accountId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountAddressByIDRequest2();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        if (object.accountId !== void 0 && object.accountId !== null) {
          message.accountId = BigInt(object.accountId.toString());
        }
        return message;
      }
    };
    function createBaseQueryAccountAddressByIDResponse2() {
      return {
        accountAddress: ""
      };
    }
    exports$1.QueryAccountAddressByIDResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.accountAddress !== "") {
          writer.uint32(10).string(message.accountAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accountAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountAddressByIDResponse2();
        if ((0, helpers_1.isSet)(object.accountAddress))
          obj.accountAddress = String(object.accountAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.accountAddress !== void 0 && (obj.accountAddress = message.accountAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountAddressByIDResponse2();
        message.accountAddress = object.accountAddress ?? "";
        return message;
      }
    };
    function createBaseQueryAccountInfoRequest2() {
      return {
        address: ""
      };
    }
    exports$1.QueryAccountInfoRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountInfoRequest2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountInfoRequest2();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryAccountInfoResponse2() {
      return {
        info: void 0
      };
    }
    exports$1.QueryAccountInfoResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.info !== void 0) {
          auth_1.BaseAccount.encode(message.info, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountInfoResponse2();
        if ((0, helpers_1.isSet)(object.info))
          obj.info = auth_1.BaseAccount.fromJSON(object.info);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.info !== void 0 && (obj.info = message.info ? auth_1.BaseAccount.toJSON(message.info) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountInfoResponse2();
        if (object.info !== void 0 && object.info !== null) {
          message.info = auth_1.BaseAccount.fromPartial(object.info);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Accounts = this.Accounts.bind(this);
        this.Account = this.Account.bind(this);
        this.AccountAddressByID = this.AccountAddressByID.bind(this);
        this.Params = this.Params.bind(this);
        this.ModuleAccounts = this.ModuleAccounts.bind(this);
        this.ModuleAccountByName = this.ModuleAccountByName.bind(this);
        this.Bech32Prefix = this.Bech32Prefix.bind(this);
        this.AddressBytesToString = this.AddressBytesToString.bind(this);
        this.AddressStringToBytes = this.AddressStringToBytes.bind(this);
        this.AccountInfo = this.AccountInfo.bind(this);
      }
      Accounts(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports$1.QueryAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data2);
        return promise.then((data3) => exports$1.QueryAccountsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Account(request) {
        const data2 = exports$1.QueryAccountRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Account", data2);
        return promise.then((data3) => exports$1.QueryAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AccountAddressByID(request) {
        const data2 = exports$1.QueryAccountAddressByIDRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", data2);
        return promise.then((data3) => exports$1.QueryAccountAddressByIDResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports$1.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports$1.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ModuleAccounts(request = {}) {
        const data2 = exports$1.QueryModuleAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", data2);
        return promise.then((data3) => exports$1.QueryModuleAccountsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ModuleAccountByName(request) {
        const data2 = exports$1.QueryModuleAccountByNameRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", data2);
        return promise.then((data3) => exports$1.QueryModuleAccountByNameResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Bech32Prefix(request = {}) {
        const data2 = exports$1.Bech32PrefixRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", data2);
        return promise.then((data3) => exports$1.Bech32PrefixResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AddressBytesToString(request) {
        const data2 = exports$1.AddressBytesToStringRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", data2);
        return promise.then((data3) => exports$1.AddressBytesToStringResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AddressStringToBytes(request) {
        const data2 = exports$1.AddressStringToBytesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", data2);
        return promise.then((data3) => exports$1.AddressStringToBytesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AccountInfo(request) {
        const data2 = exports$1.QueryAccountInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", data2);
        return promise.then((data3) => exports$1.QueryAccountInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/queryclient/queryclient.js
var require_queryclient = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/queryclient/queryclient.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClient = void 0;
    var utils_1 = require_build3();
    var QueryClient = class _QueryClient {
      static withExtensions(cometClient, ...extensionSetups) {
        const client = new _QueryClient(cometClient);
        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));
        for (const extension of extensions) {
          (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
          for (const [moduleKey, moduleValue] of Object.entries(extension)) {
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
            const current = client[moduleKey] || {};
            client[moduleKey] = {
              ...current,
              ...moduleValue
            };
          }
        }
        return client;
      }
      cometClient;
      constructor(cometClient) {
        this.cometClient = cometClient;
      }
      /**
       * Performs an ABCI query to Tendermint without requesting a proof.
       *
       * If the `desiredHeight` is set, a particular height is requested. Otherwise
       * the latest height is requested. The response contains the actual height of
       * the query.
       */
      async queryAbci(path, request, desiredHeight) {
        const response = await this.cometClient.abciQuery({
          path,
          data: request,
          prove: false,
          height: desiredHeight
        });
        if (response.code) {
          throw new Error(`Query failed with (${response.code}): ${response.log}`);
        }
        if (!response.height) {
          throw new Error("No query height returned");
        }
        return {
          value: response.value,
          height: response.height
        };
      }
    };
    exports$1.QueryClient = QueryClient;
  }
});

// ../../node_modules/@cosmjs/stargate/build/queryclient/utils.js
var require_utils5 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/queryclient/utils.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.toAccAddress = toAccAddress;
    exports$1.createPagination = createPagination;
    exports$1.createProtobufRpcClient = createProtobufRpcClient;
    exports$1.longify = longify;
    exports$1.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var pagination_1 = require_pagination();
    function toAccAddress(address) {
      return (0, encoding_1.fromBech32)(address).data;
    }
    function createPagination(paginationKey) {
      return paginationKey ? pagination_1.PageRequest.fromPartial({ key: paginationKey }) : pagination_1.PageRequest.fromPartial({});
    }
    function createProtobufRpcClient(base) {
      return {
        request: async (service, method, data2) => {
          const path = `/${service}/${method}`;
          const response = await base.queryAbci(path, data2, void 0);
          return response.value;
        }
      };
    }
    function longify(value) {
      const checkedValue = math_1.Uint64.fromString(value.toString());
      return BigInt(checkedValue.toString());
    }
    function decodeCosmosSdkDecFromProto(input) {
      const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
      return math_1.Decimal.fromAtomics(asString, 18);
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/queryclient/index.js
var require_queryclient2 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/queryclient/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.longify = exports$1.decodeCosmosSdkDecFromProto = exports$1.createProtobufRpcClient = exports$1.createPagination = exports$1.QueryClient = void 0;
    var queryclient_1 = require_queryclient();
    Object.defineProperty(exports$1, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var utils_1 = require_utils5();
    Object.defineProperty(exports$1, "createPagination", { enumerable: true, get: function() {
      return utils_1.createPagination;
    } });
    Object.defineProperty(exports$1, "createProtobufRpcClient", { enumerable: true, get: function() {
      return utils_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports$1, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return utils_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports$1, "longify", { enumerable: true, get: function() {
      return utils_1.longify;
    } });
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/auth/queries.js
var require_queries = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/auth/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupAuthExtension = setupAuthExtension;
    var query_1 = require_query();
    var queryclient_1 = require_queryclient2();
    function setupAuthExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        auth: {
          account: async (address) => {
            const { account } = await queryService.Account({ address });
            return account ?? null;
          }
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js
var require_aminomessages = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.createAuthzAminoConverters = createAuthzAminoConverters;
    function createAuthzAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
      };
    }
  }
});

// ../../node_modules/cosmjs-types/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/cosmjs-types/google/protobuf/timestamp.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Timestamp = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "google.protobuf";
    function createBaseTimestamp2() {
      return {
        seconds: BigInt(0),
        nanos: 0
      };
    }
    exports$1.Timestamp = {
      typeUrl: "/google.protobuf.Timestamp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimestamp2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTimestamp2();
        if ((0, helpers_1.isSet)(object.seconds))
          obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos))
          obj.nanos = Number(object.nanos);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTimestamp2();
        if (object.seconds !== void 0 && object.seconds !== null) {
          message.seconds = BigInt(object.seconds.toString());
        }
        message.nanos = object.nanos ?? 0;
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js
var require_authz = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.GrantQueueItem = exports$1.GrantAuthorization = exports$1.Grant = exports$1.GenericAuthorization = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseGenericAuthorization() {
      return {
        msg: ""
      };
    }
    exports$1.GenericAuthorization = {
      typeUrl: "/cosmos.authz.v1beta1.GenericAuthorization",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msg !== "") {
          writer.uint32(10).string(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGenericAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msg = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGenericAuthorization();
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = String(object.msg);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msg !== void 0 && (obj.msg = message.msg);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGenericAuthorization();
        message.msg = object.msg ?? "";
        return message;
      }
    };
    function createBaseGrant3() {
      return {
        authorization: void 0,
        expiration: void 0
      };
    }
    exports$1.Grant = {
      typeUrl: "/cosmos.authz.v1beta1.Grant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrant3();
        if ((0, helpers_1.isSet)(object.authorization))
          obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrant3();
        if (object.authorization !== void 0 && object.authorization !== null) {
          message.authorization = any_1.Any.fromPartial(object.authorization);
        }
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBaseGrantAuthorization2() {
      return {
        granter: "",
        grantee: "",
        authorization: void 0,
        expiration: void 0
      };
    }
    exports$1.GrantAuthorization = {
      typeUrl: "/cosmos.authz.v1beta1.GrantAuthorization",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(26).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrantAuthorization2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrantAuthorization2();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.authorization))
          obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrantAuthorization2();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.authorization !== void 0 && object.authorization !== null) {
          message.authorization = any_1.Any.fromPartial(object.authorization);
        }
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBaseGrantQueueItem() {
      return {
        msgTypeUrls: []
      };
    }
    exports$1.GrantQueueItem = {
      typeUrl: "/cosmos.authz.v1beta1.GrantQueueItem",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.msgTypeUrls) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrantQueueItem();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgTypeUrls.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrantQueueItem();
        if (Array.isArray(object?.msgTypeUrls))
          obj.msgTypeUrls = object.msgTypeUrls.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.msgTypeUrls) {
          obj.msgTypeUrls = message.msgTypeUrls.map((e) => e);
        } else {
          obj.msgTypeUrls = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrantQueueItem();
        message.msgTypeUrls = object.msgTypeUrls?.map((e) => e) || [];
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js
var require_tx3 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgRevokeResponse = exports$1.MsgRevoke = exports$1.MsgExecResponse = exports$1.MsgExec = exports$1.MsgGrantResponse = exports$1.MsgGrant = exports$1.protobufPackage = void 0;
    var authz_1 = require_authz();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseMsgGrant2() {
      return {
        granter: "",
        grantee: "",
        grant: authz_1.Grant.fromPartial({})
      };
    }
    exports$1.MsgGrant = {
      typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.grant !== void 0) {
          authz_1.Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrant2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.grant = authz_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgGrant2();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.grant))
          obj.grant = authz_1.Grant.fromJSON(object.grant);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.grant !== void 0 && (obj.grant = message.grant ? authz_1.Grant.toJSON(message.grant) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgGrant2();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.grant !== void 0 && object.grant !== null) {
          message.grant = authz_1.Grant.fromPartial(object.grant);
        }
        return message;
      }
    };
    function createBaseMsgGrantResponse2() {
      return {};
    }
    exports$1.MsgGrantResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgGrantResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgGrantResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgGrantResponse2();
        return message;
      }
    };
    function createBaseMsgExec3() {
      return {
        grantee: "",
        msgs: []
      };
    }
    exports$1.MsgExec = {
      typeUrl: "/cosmos.authz.v1beta1.MsgExec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        for (const v of message.msgs) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.msgs.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExec3();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if (Array.isArray(object?.msgs))
          obj.msgs = object.msgs.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        if (message.msgs) {
          obj.msgs = message.msgs.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExec3();
        message.grantee = object.grantee ?? "";
        message.msgs = object.msgs?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgExecResponse3() {
      return {
        results: []
      };
    }
    exports$1.MsgExecResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgExecResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.results) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.results.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecResponse3();
        if (Array.isArray(object?.results))
          obj.results = object.results.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.results) {
          obj.results = message.results.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.results = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecResponse3();
        message.results = object.results?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMsgRevoke2() {
      return {
        granter: "",
        grantee: "",
        msgTypeUrl: ""
      };
    }
    exports$1.MsgRevoke = {
      typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevoke2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRevoke2();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl))
          obj.msgTypeUrl = String(object.msgTypeUrl);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRevoke2();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        return message;
      }
    };
    function createBaseMsgRevokeResponse2() {
      return {};
    }
    exports$1.MsgRevokeResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgRevokeResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgRevokeResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRevokeResponse2();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grant = this.Grant.bind(this);
        this.Exec = this.Exec.bind(this);
        this.Revoke = this.Revoke.bind(this);
      }
      Grant(request) {
        const data2 = exports$1.MsgGrant.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", data2);
        return promise.then((data3) => exports$1.MsgGrantResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Exec(request) {
        const data2 = exports$1.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", data2);
        return promise.then((data3) => exports$1.MsgExecResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Revoke(request) {
        const data2 = exports$1.MsgRevoke.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", data2);
        return promise.then((data3) => exports$1.MsgRevokeResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/authz/messages.js
var require_messages = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/authz/messages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.authzTypes = void 0;
    var tx_1 = require_tx3();
    exports$1.authzTypes = [
      ["/cosmos.authz.v1beta1.MsgExec", tx_1.MsgExec],
      ["/cosmos.authz.v1beta1.MsgGrant", tx_1.MsgGrant],
      ["/cosmos.authz.v1beta1.MsgRevoke", tx_1.MsgRevoke]
    ];
  }
});

// ../../node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js
var require_query2 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryGranteeGrantsResponse = exports$1.QueryGranteeGrantsRequest = exports$1.QueryGranterGrantsResponse = exports$1.QueryGranterGrantsRequest = exports$1.QueryGrantsResponse = exports$1.QueryGrantsRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var authz_1 = require_authz();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseQueryGrantsRequest2() {
      return {
        granter: "",
        grantee: "",
        msgTypeUrl: "",
        pagination: void 0
      };
    }
    exports$1.QueryGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGrantsRequest2();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl))
          obj.msgTypeUrl = String(object.msgTypeUrl);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGrantsRequest2();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGrantsResponse2() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports$1.QueryGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants) {
          authz_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGrantsResponse2();
        if (Array.isArray(object?.grants))
          obj.grants = object.grants.map((e) => authz_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.Grant.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGrantsResponse2();
        message.grants = object.grants?.map((e) => authz_1.Grant.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranterGrantsRequest2() {
      return {
        granter: "",
        pagination: void 0
      };
    }
    exports$1.QueryGranterGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranterGrantsRequest2();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranterGrantsRequest2();
        message.granter = object.granter ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranterGrantsResponse2() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports$1.QueryGranterGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants) {
          authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranterGrantsResponse2();
        if (Array.isArray(object?.grants))
          obj.grants = object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranterGrantsResponse2();
        message.grants = object.grants?.map((e) => authz_1.GrantAuthorization.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranteeGrantsRequest2() {
      return {
        grantee: "",
        pagination: void 0
      };
    }
    exports$1.QueryGranteeGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranteeGrantsRequest2();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranteeGrantsRequest2();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranteeGrantsResponse2() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports$1.QueryGranteeGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants) {
          authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranteeGrantsResponse2();
        if (Array.isArray(object?.grants))
          obj.grants = object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranteeGrantsResponse2();
        message.grants = object.grants?.map((e) => authz_1.GrantAuthorization.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grants = this.Grants.bind(this);
        this.GranterGrants = this.GranterGrants.bind(this);
        this.GranteeGrants = this.GranteeGrants.bind(this);
      }
      Grants(request) {
        const data2 = exports$1.QueryGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", data2);
        return promise.then((data3) => exports$1.QueryGrantsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GranterGrants(request) {
        const data2 = exports$1.QueryGranterGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", data2);
        return promise.then((data3) => exports$1.QueryGranterGrantsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GranteeGrants(request) {
        const data2 = exports$1.QueryGranteeGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", data2);
        return promise.then((data3) => exports$1.QueryGranteeGrantsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/authz/queries.js
var require_queries2 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/authz/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupAuthzExtension = setupAuthzExtension;
    var query_1 = require_query2();
    var queryclient_1 = require_queryclient2();
    function setupAuthzExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        authz: {
          grants: async (granter, grantee, msgTypeUrl, paginationKey) => {
            return await queryService.Grants({
              granter,
              grantee,
              msgTypeUrl,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granteeGrants: async (grantee, paginationKey) => {
            return await queryService.GranteeGrants({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granterGrants: async (granter, paginationKey) => {
            return await queryService.GranterGrants({
              granter,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          }
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js
var require_aminomessages2 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isAminoMsgSend = isAminoMsgSend;
    exports$1.isAminoMsgMultiSend = isAminoMsgMultiSend;
    exports$1.createBankAminoConverters = createBankAminoConverters;
    function isAminoMsgSend(msg) {
      return msg.type === "cosmos-sdk/MsgSend";
    }
    function isAminoMsgMultiSend(msg) {
      return msg.type === "cosmos-sdk/MsgMultiSend";
    }
    function createBankAminoConverters() {
      return {
        "/cosmos.bank.v1beta1.MsgSend": {
          aminoType: "cosmos-sdk/MsgSend",
          toAmino: ({ fromAddress, toAddress, amount }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount]
          }),
          fromAmino: ({ from_address, to_address, amount }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount]
          })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
          aminoType: "cosmos-sdk/MsgMultiSend",
          toAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          }),
          fromAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          })
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/bank/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/bank/messages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.bankTypes = void 0;
    exports$1.isMsgSendEncodeObject = isMsgSendEncodeObject;
    var tx_1 = require_tx2();
    exports$1.bankTypes = [
      ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
      ["/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend]
    ];
    function isMsgSendEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js
var require_query3 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QuerySendEnabledResponse = exports$1.QuerySendEnabledRequest = exports$1.QueryDenomOwnersByQueryResponse = exports$1.QueryDenomOwnersByQueryRequest = exports$1.QueryDenomOwnersResponse = exports$1.DenomOwner = exports$1.QueryDenomOwnersRequest = exports$1.QueryDenomMetadataByQueryStringResponse = exports$1.QueryDenomMetadataByQueryStringRequest = exports$1.QueryDenomMetadataResponse = exports$1.QueryDenomMetadataRequest = exports$1.QueryDenomsMetadataResponse = exports$1.QueryDenomsMetadataRequest = exports$1.QueryParamsResponse = exports$1.QueryParamsRequest = exports$1.QuerySupplyOfResponse = exports$1.QuerySupplyOfRequest = exports$1.QueryTotalSupplyResponse = exports$1.QueryTotalSupplyRequest = exports$1.QuerySpendableBalanceByDenomResponse = exports$1.QuerySpendableBalanceByDenomRequest = exports$1.QuerySpendableBalancesResponse = exports$1.QuerySpendableBalancesRequest = exports$1.QueryAllBalancesResponse = exports$1.QueryAllBalancesRequest = exports$1.QueryBalanceResponse = exports$1.QueryBalanceRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var coin_1 = require_coin();
    var bank_1 = require_bank();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseQueryBalanceRequest3() {
      return {
        address: "",
        denom: ""
      };
    }
    exports$1.QueryBalanceRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryBalanceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.denom !== "") {
          writer.uint32(18).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryBalanceRequest3();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryBalanceRequest3();
        message.address = object.address ?? "";
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryBalanceResponse3() {
      return {
        balance: void 0
      };
    }
    exports$1.QueryBalanceResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryBalanceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryBalanceResponse3();
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryBalanceResponse3();
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseQueryAllBalancesRequest2() {
      return {
        address: "",
        pagination: void 0,
        resolveDenom: false
      };
    }
    exports$1.QueryAllBalancesRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.resolveDenom === true) {
          writer.uint32(24).bool(message.resolveDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 3:
              message.resolveDenom = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllBalancesRequest2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.resolveDenom))
          obj.resolveDenom = Boolean(object.resolveDenom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        message.resolveDenom !== void 0 && (obj.resolveDenom = message.resolveDenom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllBalancesRequest2();
        message.address = object.address ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.resolveDenom = object.resolveDenom ?? false;
        return message;
      }
    };
    function createBaseQueryAllBalancesResponse2() {
      return {
        balances: [],
        pagination: void 0
      };
    }
    exports$1.QueryAllBalancesResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.balances) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllBalancesResponse2();
        if (Array.isArray(object?.balances))
          obj.balances = object.balances.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.balances) {
          obj.balances = message.balances.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.balances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllBalancesResponse2();
        message.balances = object.balances?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySpendableBalancesRequest2() {
      return {
        address: "",
        pagination: void 0
      };
    }
    exports$1.QuerySpendableBalancesRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalancesRequest2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalancesRequest2();
        message.address = object.address ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySpendableBalancesResponse2() {
      return {
        balances: [],
        pagination: void 0
      };
    }
    exports$1.QuerySpendableBalancesResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.balances) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalancesResponse2();
        if (Array.isArray(object?.balances))
          obj.balances = object.balances.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.balances) {
          obj.balances = message.balances.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.balances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalancesResponse2();
        message.balances = object.balances?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySpendableBalanceByDenomRequest2() {
      return {
        address: "",
        denom: ""
      };
    }
    exports$1.QuerySpendableBalanceByDenomRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.denom !== "") {
          writer.uint32(18).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalanceByDenomRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalanceByDenomRequest2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalanceByDenomRequest2();
        message.address = object.address ?? "";
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQuerySpendableBalanceByDenomResponse2() {
      return {
        balance: void 0
      };
    }
    exports$1.QuerySpendableBalanceByDenomResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalanceByDenomResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalanceByDenomResponse2();
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalanceByDenomResponse2();
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseQueryTotalSupplyRequest2() {
      return {
        pagination: void 0
      };
    }
    exports$1.QueryTotalSupplyRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalSupplyRequest2();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalSupplyRequest2();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryTotalSupplyResponse2() {
      return {
        supply: [],
        pagination: void 0
      };
    }
    exports$1.QueryTotalSupplyResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.supply) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.supply.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalSupplyResponse2();
        if (Array.isArray(object?.supply))
          obj.supply = object.supply.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.supply) {
          obj.supply = message.supply.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.supply = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalSupplyResponse2();
        message.supply = object.supply?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySupplyOfRequest2() {
      return {
        denom: ""
      };
    }
    exports$1.QuerySupplyOfRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySupplyOfRequest2();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySupplyOfRequest2();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQuerySupplyOfResponse2() {
      return {
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports$1.QuerySupplyOfResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySupplyOfResponse2();
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySupplyOfResponse2();
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest18() {
      return {};
    }
    exports$1.QueryParamsRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest18();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest18();
        return message;
      }
    };
    function createBaseQueryParamsResponse18() {
      return {
        params: bank_1.Params.fromPartial({})
      };
    }
    exports$1.QueryParamsResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          bank_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = bank_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse18();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = bank_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse18();
        if (object.params !== void 0 && object.params !== null) {
          message.params = bank_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryDenomsMetadataRequest2() {
      return {
        pagination: void 0
      };
    }
    exports$1.QueryDenomsMetadataRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomsMetadataRequest2();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomsMetadataRequest2();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomsMetadataResponse2() {
      return {
        metadatas: [],
        pagination: void 0
      };
    }
    exports$1.QueryDenomsMetadataResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.metadatas) {
          bank_1.Metadata.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadatas.push(bank_1.Metadata.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomsMetadataResponse2();
        if (Array.isArray(object?.metadatas))
          obj.metadatas = object.metadatas.map((e) => bank_1.Metadata.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.metadatas) {
          obj.metadatas = message.metadatas.map((e) => e ? bank_1.Metadata.toJSON(e) : void 0);
        } else {
          obj.metadatas = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomsMetadataResponse2();
        message.metadatas = object.metadatas?.map((e) => bank_1.Metadata.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomMetadataRequest2() {
      return {
        denom: ""
      };
    }
    exports$1.QueryDenomMetadataRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataRequest2();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataRequest2();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryDenomMetadataResponse2() {
      return {
        metadata: bank_1.Metadata.fromPartial({})
      };
    }
    exports$1.QueryDenomMetadataResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.metadata !== void 0) {
          bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataResponse2();
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = bank_1.Metadata.fromJSON(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.metadata !== void 0 && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataResponse2();
        if (object.metadata !== void 0 && object.metadata !== null) {
          message.metadata = bank_1.Metadata.fromPartial(object.metadata);
        }
        return message;
      }
    };
    function createBaseQueryDenomMetadataByQueryStringRequest2() {
      return {
        denom: ""
      };
    }
    exports$1.QueryDenomMetadataByQueryStringRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataByQueryStringRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataByQueryStringRequest2();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataByQueryStringRequest2();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryDenomMetadataByQueryStringResponse2() {
      return {
        metadata: bank_1.Metadata.fromPartial({})
      };
    }
    exports$1.QueryDenomMetadataByQueryStringResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.metadata !== void 0) {
          bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataByQueryStringResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataByQueryStringResponse2();
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = bank_1.Metadata.fromJSON(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.metadata !== void 0 && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataByQueryStringResponse2();
        if (object.metadata !== void 0 && object.metadata !== null) {
          message.metadata = bank_1.Metadata.fromPartial(object.metadata);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersRequest2() {
      return {
        denom: "",
        pagination: void 0
      };
    }
    exports$1.QueryDenomOwnersRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersRequest2();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersRequest2();
        message.denom = object.denom ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseDenomOwner2() {
      return {
        address: "",
        balance: coin_1.Coin.fromPartial({})
      };
    }
    exports$1.DenomOwner = {
      typeUrl: "/cosmos.bank.v1beta1.DenomOwner",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomOwner2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomOwner2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDenomOwner2();
        message.address = object.address ?? "";
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersResponse2() {
      return {
        denomOwners: [],
        pagination: void 0
      };
    }
    exports$1.QueryDenomOwnersResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomOwners) {
          exports$1.DenomOwner.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomOwners.push(exports$1.DenomOwner.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersResponse2();
        if (Array.isArray(object?.denomOwners))
          obj.denomOwners = object.denomOwners.map((e) => exports$1.DenomOwner.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomOwners) {
          obj.denomOwners = message.denomOwners.map((e) => e ? exports$1.DenomOwner.toJSON(e) : void 0);
        } else {
          obj.denomOwners = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersResponse2();
        message.denomOwners = object.denomOwners?.map((e) => exports$1.DenomOwner.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersByQueryRequest2() {
      return {
        denom: "",
        pagination: void 0
      };
    }
    exports$1.QueryDenomOwnersByQueryRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersByQueryRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersByQueryRequest2();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersByQueryRequest2();
        message.denom = object.denom ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersByQueryResponse2() {
      return {
        denomOwners: [],
        pagination: void 0
      };
    }
    exports$1.QueryDenomOwnersByQueryResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomOwners) {
          exports$1.DenomOwner.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersByQueryResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomOwners.push(exports$1.DenomOwner.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersByQueryResponse2();
        if (Array.isArray(object?.denomOwners))
          obj.denomOwners = object.denomOwners.map((e) => exports$1.DenomOwner.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomOwners) {
          obj.denomOwners = message.denomOwners.map((e) => e ? exports$1.DenomOwner.toJSON(e) : void 0);
        } else {
          obj.denomOwners = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersByQueryResponse2();
        message.denomOwners = object.denomOwners?.map((e) => exports$1.DenomOwner.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySendEnabledRequest2() {
      return {
        denoms: [],
        pagination: void 0
      };
    }
    exports$1.QuerySendEnabledRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denoms) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(794).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySendEnabledRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denoms.push(reader.string());
              break;
            case 99:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySendEnabledRequest2();
        if (Array.isArray(object?.denoms))
          obj.denoms = object.denoms.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denoms) {
          obj.denoms = message.denoms.map((e) => e);
        } else {
          obj.denoms = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySendEnabledRequest2();
        message.denoms = object.denoms?.map((e) => e) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySendEnabledResponse2() {
      return {
        sendEnabled: [],
        pagination: void 0
      };
    }
    exports$1.QuerySendEnabledResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.sendEnabled) {
          bank_1.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(794).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySendEnabledResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 99:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySendEnabledResponse2();
        if (Array.isArray(object?.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? bank_1.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySendEnabledResponse2();
        message.sendEnabled = object.sendEnabled?.map((e) => bank_1.SendEnabled.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Balance = this.Balance.bind(this);
        this.AllBalances = this.AllBalances.bind(this);
        this.SpendableBalances = this.SpendableBalances.bind(this);
        this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this);
        this.TotalSupply = this.TotalSupply.bind(this);
        this.SupplyOf = this.SupplyOf.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomMetadata = this.DenomMetadata.bind(this);
        this.DenomMetadataByQueryString = this.DenomMetadataByQueryString.bind(this);
        this.DenomsMetadata = this.DenomsMetadata.bind(this);
        this.DenomOwners = this.DenomOwners.bind(this);
        this.DenomOwnersByQuery = this.DenomOwnersByQuery.bind(this);
        this.SendEnabled = this.SendEnabled.bind(this);
      }
      Balance(request) {
        const data2 = exports$1.QueryBalanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", data2);
        return promise.then((data3) => exports$1.QueryBalanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AllBalances(request) {
        const data2 = exports$1.QueryAllBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", data2);
        return promise.then((data3) => exports$1.QueryAllBalancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SpendableBalances(request) {
        const data2 = exports$1.QuerySpendableBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", data2);
        return promise.then((data3) => exports$1.QuerySpendableBalancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SpendableBalanceByDenom(request) {
        const data2 = exports$1.QuerySpendableBalanceByDenomRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", data2);
        return promise.then((data3) => exports$1.QuerySpendableBalanceByDenomResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TotalSupply(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports$1.QueryTotalSupplyRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", data2);
        return promise.then((data3) => exports$1.QueryTotalSupplyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SupplyOf(request) {
        const data2 = exports$1.QuerySupplyOfRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", data2);
        return promise.then((data3) => exports$1.QuerySupplyOfResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports$1.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports$1.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomMetadata(request) {
        const data2 = exports$1.QueryDenomMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", data2);
        return promise.then((data3) => exports$1.QueryDenomMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomMetadataByQueryString(request) {
        const data2 = exports$1.QueryDenomMetadataByQueryStringRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadataByQueryString", data2);
        return promise.then((data3) => exports$1.QueryDenomMetadataByQueryStringResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomsMetadata(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports$1.QueryDenomsMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", data2);
        return promise.then((data3) => exports$1.QueryDenomsMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomOwners(request) {
        const data2 = exports$1.QueryDenomOwnersRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", data2);
        return promise.then((data3) => exports$1.QueryDenomOwnersResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomOwnersByQuery(request) {
        const data2 = exports$1.QueryDenomOwnersByQueryRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwnersByQuery", data2);
        return promise.then((data3) => exports$1.QueryDenomOwnersByQueryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SendEnabled(request) {
        const data2 = exports$1.QuerySendEnabledRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", data2);
        return promise.then((data3) => exports$1.QuerySendEnabledResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/bank/queries.js
var require_queries3 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/bank/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupBankExtension = setupBankExtension;
    var utils_1 = require_build3();
    var query_1 = require_query3();
    var queryclient_1 = require_queryclient2();
    function setupBankExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        bank: {
          balance: async (address, denom) => {
            const { balance } = await queryService.Balance({ address, denom });
            (0, utils_1.assert)(balance);
            return balance;
          },
          allBalances: async (address) => {
            const { balances } = await queryService.AllBalances(query_1.QueryAllBalancesRequest.fromPartial({ address }));
            return balances;
          },
          totalSupply: async (paginationKey) => {
            const response = await queryService.TotalSupply({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          supplyOf: async (denom) => {
            const { amount } = await queryService.SupplyOf({ denom });
            (0, utils_1.assert)(amount);
            return amount;
          },
          denomMetadata: async (denom) => {
            const { metadata } = await queryService.DenomMetadata({ denom });
            (0, utils_1.assert)(metadata);
            return metadata;
          },
          denomsMetadata: async () => {
            const { metadatas } = await queryService.DenomsMetadata(query_1.QueryDenomsMetadataRequest.fromPartial({
              pagination: void 0
              // Not implemented
            }));
            return metadatas;
          }
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js
var require_aminomessages3 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
    exports$1.createCrysisAminoConverters = createCrysisAminoConverters;
    function isAminoMsgVerifyInvariant(msg) {
      return msg.type === "cosmos-sdk/MsgVerifyInvariant";
    }
    function createCrysisAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js
var require_aminomessages4 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
    exports$1.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
    exports$1.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
    exports$1.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
    exports$1.createDistributionAminoConverters = createDistributionAminoConverters;
    function isAminoMsgSetWithdrawAddress(msg) {
      return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
    }
    function isAminoMsgWithdrawDelegatorReward(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
    }
    function isAminoMsgWithdrawValidatorCommission(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
    }
    function isAminoMsgFundCommunityPool(msg) {
      return msg.type === "cosmos-sdk/MsgFundCommunityPool";
    }
    function createDistributionAminoConverters() {
      return {
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
          aminoType: "cosmos-sdk/MsgFundCommunityPool",
          toAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          }),
          fromAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
          aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
          toAmino: ({ delegatorAddress, withdrawAddress }) => ({
            delegator_address: delegatorAddress,
            withdraw_address: withdrawAddress
          }),
          fromAmino: ({ delegator_address, withdraw_address }) => ({
            delegatorAddress: delegator_address,
            withdrawAddress: withdraw_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
          aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
          toAmino: ({ delegatorAddress, validatorAddress }) => ({
            delegator_address: delegatorAddress,
            validator_address: validatorAddress
          }),
          fromAmino: ({ delegator_address, validator_address }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
          aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
          toAmino: ({ validatorAddress }) => ({
            validator_address: validatorAddress
          }),
          fromAmino: ({ validator_address }) => ({
            validatorAddress: validator_address
          })
        }
      };
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js
var require_distribution = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CommunityPoolSpendProposalWithDeposit = exports$1.DelegationDelegatorReward = exports$1.DelegatorStartingInfo = exports$1.CommunityPoolSpendProposal = exports$1.FeePool = exports$1.ValidatorSlashEvents = exports$1.ValidatorSlashEvent = exports$1.ValidatorOutstandingRewards = exports$1.ValidatorAccumulatedCommission = exports$1.ValidatorCurrentRewards = exports$1.ValidatorHistoricalRewards = exports$1.Params = exports$1.protobufPackage = void 0;
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseParams15() {
      return {
        communityTax: "",
        baseProposerReward: "",
        bonusProposerReward: "",
        withdrawAddrEnabled: false
      };
    }
    exports$1.Params = {
      typeUrl: "/cosmos.distribution.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.communityTax !== "") {
          writer.uint32(10).string(message.communityTax);
        }
        if (message.baseProposerReward !== "") {
          writer.uint32(18).string(message.baseProposerReward);
        }
        if (message.bonusProposerReward !== "") {
          writer.uint32(26).string(message.bonusProposerReward);
        }
        if (message.withdrawAddrEnabled === true) {
          writer.uint32(32).bool(message.withdrawAddrEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityTax = reader.string();
              break;
            case 2:
              message.baseProposerReward = reader.string();
              break;
            case 3:
              message.bonusProposerReward = reader.string();
              break;
            case 4:
              message.withdrawAddrEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if ((0, helpers_1.isSet)(object.communityTax))
          obj.communityTax = String(object.communityTax);
        if ((0, helpers_1.isSet)(object.baseProposerReward))
          obj.baseProposerReward = String(object.baseProposerReward);
        if ((0, helpers_1.isSet)(object.bonusProposerReward))
          obj.bonusProposerReward = String(object.bonusProposerReward);
        if ((0, helpers_1.isSet)(object.withdrawAddrEnabled))
          obj.withdrawAddrEnabled = Boolean(object.withdrawAddrEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.communityTax !== void 0 && (obj.communityTax = message.communityTax);
        message.baseProposerReward !== void 0 && (obj.baseProposerReward = message.baseProposerReward);
        message.bonusProposerReward !== void 0 && (obj.bonusProposerReward = message.bonusProposerReward);
        message.withdrawAddrEnabled !== void 0 && (obj.withdrawAddrEnabled = message.withdrawAddrEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        message.communityTax = object.communityTax ?? "";
        message.baseProposerReward = object.baseProposerReward ?? "";
        message.bonusProposerReward = object.bonusProposerReward ?? "";
        message.withdrawAddrEnabled = object.withdrawAddrEnabled ?? false;
        return message;
      }
    };
    function createBaseValidatorHistoricalRewards() {
      return {
        cumulativeRewardRatio: [],
        referenceCount: 0
      };
    }
    exports$1.ValidatorHistoricalRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.cumulativeRewardRatio) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.referenceCount !== 0) {
          writer.uint32(16).uint32(message.referenceCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorHistoricalRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cumulativeRewardRatio.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.referenceCount = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorHistoricalRewards();
        if (Array.isArray(object?.cumulativeRewardRatio))
          obj.cumulativeRewardRatio = object.cumulativeRewardRatio.map((e) => coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.referenceCount))
          obj.referenceCount = Number(object.referenceCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.cumulativeRewardRatio) {
          obj.cumulativeRewardRatio = message.cumulativeRewardRatio.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.cumulativeRewardRatio = [];
        }
        message.referenceCount !== void 0 && (obj.referenceCount = Math.round(message.referenceCount));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorHistoricalRewards();
        message.cumulativeRewardRatio = object.cumulativeRewardRatio?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        message.referenceCount = object.referenceCount ?? 0;
        return message;
      }
    };
    function createBaseValidatorCurrentRewards() {
      return {
        rewards: [],
        period: BigInt(0)
      };
    }
    exports$1.ValidatorCurrentRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== BigInt(0)) {
          writer.uint32(16).uint64(message.period);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorCurrentRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.period = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorCurrentRewards();
        if (Array.isArray(object?.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.period))
          obj.period = BigInt(object.period.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        message.period !== void 0 && (obj.period = (message.period || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorCurrentRewards();
        message.rewards = object.rewards?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        if (object.period !== void 0 && object.period !== null) {
          message.period = BigInt(object.period.toString());
        }
        return message;
      }
    };
    function createBaseValidatorAccumulatedCommission2() {
      return {
        commission: []
      };
    }
    exports$1.ValidatorAccumulatedCommission = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.commission) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorAccumulatedCommission2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorAccumulatedCommission2();
        if (Array.isArray(object?.commission))
          obj.commission = object.commission.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorAccumulatedCommission2();
        message.commission = object.commission?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseValidatorOutstandingRewards2() {
      return {
        rewards: []
      };
    }
    exports$1.ValidatorOutstandingRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorOutstandingRewards2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorOutstandingRewards2();
        if (Array.isArray(object?.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorOutstandingRewards2();
        message.rewards = object.rewards?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseValidatorSlashEvent2() {
      return {
        validatorPeriod: BigInt(0),
        fraction: ""
      };
    }
    exports$1.ValidatorSlashEvent = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorPeriod !== BigInt(0)) {
          writer.uint32(8).uint64(message.validatorPeriod);
        }
        if (message.fraction !== "") {
          writer.uint32(18).string(message.fraction);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvent2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorPeriod = reader.uint64();
              break;
            case 2:
              message.fraction = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSlashEvent2();
        if ((0, helpers_1.isSet)(object.validatorPeriod))
          obj.validatorPeriod = BigInt(object.validatorPeriod.toString());
        if ((0, helpers_1.isSet)(object.fraction))
          obj.fraction = String(object.fraction);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorPeriod !== void 0 && (obj.validatorPeriod = (message.validatorPeriod || BigInt(0)).toString());
        message.fraction !== void 0 && (obj.fraction = message.fraction);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSlashEvent2();
        if (object.validatorPeriod !== void 0 && object.validatorPeriod !== null) {
          message.validatorPeriod = BigInt(object.validatorPeriod.toString());
        }
        message.fraction = object.fraction ?? "";
        return message;
      }
    };
    function createBaseValidatorSlashEvents() {
      return {
        validatorSlashEvents: []
      };
    }
    exports$1.ValidatorSlashEvents = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validatorSlashEvents) {
          exports$1.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvents();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorSlashEvents.push(exports$1.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSlashEvents();
        if (Array.isArray(object?.validatorSlashEvents))
          obj.validatorSlashEvents = object.validatorSlashEvents.map((e) => exports$1.ValidatorSlashEvent.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validatorSlashEvents) {
          obj.validatorSlashEvents = message.validatorSlashEvents.map((e) => e ? exports$1.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.validatorSlashEvents = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSlashEvents();
        message.validatorSlashEvents = object.validatorSlashEvents?.map((e) => exports$1.ValidatorSlashEvent.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseFeePool() {
      return {
        communityPool: []
      };
    }
    exports$1.FeePool = {
      typeUrl: "/cosmos.distribution.v1beta1.FeePool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.communityPool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFeePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityPool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFeePool();
        if (Array.isArray(object?.communityPool))
          obj.communityPool = object.communityPool.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.communityPool) {
          obj.communityPool = message.communityPool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.communityPool = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseFeePool();
        message.communityPool = object.communityPool?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposal() {
      return {
        title: "",
        description: "",
        recipient: "",
        amount: []
      };
    }
    exports$1.CommunityPoolSpendProposal = {
      typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommunityPoolSpendProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommunityPoolSpendProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDelegatorStartingInfo() {
      return {
        previousPeriod: BigInt(0),
        stake: "",
        height: BigInt(0)
      };
    }
    exports$1.DelegatorStartingInfo = {
      typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.previousPeriod !== BigInt(0)) {
          writer.uint32(8).uint64(message.previousPeriod);
        }
        if (message.stake !== "") {
          writer.uint32(18).string(message.stake);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).uint64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegatorStartingInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.previousPeriod = reader.uint64();
              break;
            case 2:
              message.stake = reader.string();
              break;
            case 3:
              message.height = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegatorStartingInfo();
        if ((0, helpers_1.isSet)(object.previousPeriod))
          obj.previousPeriod = BigInt(object.previousPeriod.toString());
        if ((0, helpers_1.isSet)(object.stake))
          obj.stake = String(object.stake);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.previousPeriod !== void 0 && (obj.previousPeriod = (message.previousPeriod || BigInt(0)).toString());
        message.stake !== void 0 && (obj.stake = message.stake);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegatorStartingInfo();
        if (object.previousPeriod !== void 0 && object.previousPeriod !== null) {
          message.previousPeriod = BigInt(object.previousPeriod.toString());
        }
        message.stake = object.stake ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        return message;
      }
    };
    function createBaseDelegationDelegatorReward2() {
      return {
        validatorAddress: "",
        reward: []
      };
    }
    exports$1.DelegationDelegatorReward = {
      typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        for (const v of message.reward) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationDelegatorReward2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.reward.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegationDelegatorReward2();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object?.reward))
          obj.reward = object.reward.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.reward) {
          obj.reward = message.reward.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.reward = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegationDelegatorReward2();
        message.validatorAddress = object.validatorAddress ?? "";
        message.reward = object.reward?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposalWithDeposit() {
      return {
        title: "",
        description: "",
        recipient: "",
        amount: "",
        deposit: ""
      };
    }
    exports$1.CommunityPoolSpendProposalWithDeposit = {
      typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        if (message.amount !== "") {
          writer.uint32(34).string(message.amount);
        }
        if (message.deposit !== "") {
          writer.uint32(42).string(message.deposit);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            case 5:
              message.deposit = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommunityPoolSpendProposalWithDeposit();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        if ((0, helpers_1.isSet)(object.deposit))
          obj.deposit = String(object.deposit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.deposit !== void 0 && (obj.deposit = message.deposit);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount ?? "";
        message.deposit = object.deposit ?? "";
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js
var require_tx4 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgDepositValidatorRewardsPoolResponse = exports$1.MsgDepositValidatorRewardsPool = exports$1.MsgCommunityPoolSpendResponse = exports$1.MsgCommunityPoolSpend = exports$1.MsgUpdateParamsResponse = exports$1.MsgUpdateParams = exports$1.MsgFundCommunityPoolResponse = exports$1.MsgFundCommunityPool = exports$1.MsgWithdrawValidatorCommissionResponse = exports$1.MsgWithdrawValidatorCommission = exports$1.MsgWithdrawDelegatorRewardResponse = exports$1.MsgWithdrawDelegatorReward = exports$1.MsgSetWithdrawAddressResponse = exports$1.MsgSetWithdrawAddress = exports$1.protobufPackage = void 0;
    var coin_1 = require_coin();
    var distribution_1 = require_distribution();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseMsgSetWithdrawAddress2() {
      return {
        delegatorAddress: "",
        withdrawAddress: ""
      };
    }
    exports$1.MsgSetWithdrawAddress = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.withdrawAddress !== "") {
          writer.uint32(18).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddress2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSetWithdrawAddress2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.withdrawAddress))
          obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSetWithdrawAddress2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
      }
    };
    function createBaseMsgSetWithdrawAddressResponse2() {
      return {};
    }
    exports$1.MsgSetWithdrawAddressResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddressResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSetWithdrawAddressResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetWithdrawAddressResponse2();
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorReward2() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports$1.MsgWithdrawDelegatorReward = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorReward2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawDelegatorReward2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawDelegatorReward2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorRewardResponse2() {
      return {
        amount: []
      };
    }
    exports$1.MsgWithdrawDelegatorRewardResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorRewardResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawDelegatorRewardResponse2();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawDelegatorRewardResponse2();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommission2() {
      return {
        validatorAddress: ""
      };
    }
    exports$1.MsgWithdrawValidatorCommission = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommission2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawValidatorCommission2();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawValidatorCommission2();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommissionResponse2() {
      return {
        amount: []
      };
    }
    exports$1.MsgWithdrawValidatorCommissionResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommissionResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawValidatorCommissionResponse2();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawValidatorCommissionResponse2();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgFundCommunityPool3() {
      return {
        amount: [],
        depositor: ""
      };
    }
    exports$1.MsgFundCommunityPool = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPool3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgFundCommunityPool3();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgFundCommunityPool3();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.depositor = object.depositor ?? "";
        return message;
      }
    };
    function createBaseMsgFundCommunityPoolResponse3() {
      return {};
    }
    exports$1.MsgFundCommunityPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPoolResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgFundCommunityPoolResponse3();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgFundCommunityPoolResponse3();
        return message;
      }
    };
    function createBaseMsgUpdateParams17() {
      return {
        authority: "",
        params: distribution_1.Params.fromPartial({})
      };
    }
    exports$1.MsgUpdateParams = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams17();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams17();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = distribution_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse17() {
      return {};
    }
    exports$1.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse17();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse17();
        return message;
      }
    };
    function createBaseMsgCommunityPoolSpend3() {
      return {
        authority: "",
        recipient: "",
        amount: []
      };
    }
    exports$1.MsgCommunityPoolSpend = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.recipient !== "") {
          writer.uint32(18).string(message.recipient);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpend3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.recipient = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCommunityPoolSpend3();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCommunityPoolSpend3();
        message.authority = object.authority ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgCommunityPoolSpendResponse3() {
      return {};
    }
    exports$1.MsgCommunityPoolSpendResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpendResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCommunityPoolSpendResponse3();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCommunityPoolSpendResponse3();
        return message;
      }
    };
    function createBaseMsgDepositValidatorRewardsPool2() {
      return {
        depositor: "",
        validatorAddress: "",
        amount: []
      };
    }
    exports$1.MsgDepositValidatorRewardsPool = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.depositor !== "") {
          writer.uint32(10).string(message.depositor);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositValidatorRewardsPool2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.depositor = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDepositValidatorRewardsPool2();
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDepositValidatorRewardsPool2();
        message.depositor = object.depositor ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgDepositValidatorRewardsPoolResponse2() {
      return {};
    }
    exports$1.MsgDepositValidatorRewardsPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPoolResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositValidatorRewardsPoolResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDepositValidatorRewardsPoolResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositValidatorRewardsPoolResponse2();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);
        this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);
        this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this);
        this.FundCommunityPool = this.FundCommunityPool.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
        this.DepositValidatorRewardsPool = this.DepositValidatorRewardsPool.bind(this);
      }
      SetWithdrawAddress(request) {
        const data2 = exports$1.MsgSetWithdrawAddress.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", data2);
        return promise.then((data3) => exports$1.MsgSetWithdrawAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WithdrawDelegatorReward(request) {
        const data2 = exports$1.MsgWithdrawDelegatorReward.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", data2);
        return promise.then((data3) => exports$1.MsgWithdrawDelegatorRewardResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WithdrawValidatorCommission(request) {
        const data2 = exports$1.MsgWithdrawValidatorCommission.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", data2);
        return promise.then((data3) => exports$1.MsgWithdrawValidatorCommissionResponse.decode(new binary_1.BinaryReader(data3)));
      }
      FundCommunityPool(request) {
        const data2 = exports$1.MsgFundCommunityPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", data2);
        return promise.then((data3) => exports$1.MsgFundCommunityPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports$1.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports$1.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CommunityPoolSpend(request) {
        const data2 = exports$1.MsgCommunityPoolSpend.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", data2);
        return promise.then((data3) => exports$1.MsgCommunityPoolSpendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DepositValidatorRewardsPool(request) {
        const data2 = exports$1.MsgDepositValidatorRewardsPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "DepositValidatorRewardsPool", data2);
        return promise.then((data3) => exports$1.MsgDepositValidatorRewardsPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/distribution/messages.js
var require_messages3 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/distribution/messages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.distributionTypes = void 0;
    exports$1.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject;
    var tx_1 = require_tx4();
    exports$1.distributionTypes = [
      ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", tx_1.MsgFundCommunityPool],
      ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_1.MsgSetWithdrawAddress],
      ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_1.MsgWithdrawDelegatorReward],
      ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", tx_1.MsgWithdrawValidatorCommission]
    ];
    function isMsgWithdrawDelegatorRewardEncodeObject(object) {
      return object.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js
var require_query4 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryCommunityPoolResponse = exports$1.QueryCommunityPoolRequest = exports$1.QueryDelegatorWithdrawAddressResponse = exports$1.QueryDelegatorWithdrawAddressRequest = exports$1.QueryDelegatorValidatorsResponse = exports$1.QueryDelegatorValidatorsRequest = exports$1.QueryDelegationTotalRewardsResponse = exports$1.QueryDelegationTotalRewardsRequest = exports$1.QueryDelegationRewardsResponse = exports$1.QueryDelegationRewardsRequest = exports$1.QueryValidatorSlashesResponse = exports$1.QueryValidatorSlashesRequest = exports$1.QueryValidatorCommissionResponse = exports$1.QueryValidatorCommissionRequest = exports$1.QueryValidatorOutstandingRewardsResponse = exports$1.QueryValidatorOutstandingRewardsRequest = exports$1.QueryValidatorDistributionInfoResponse = exports$1.QueryValidatorDistributionInfoRequest = exports$1.QueryParamsResponse = exports$1.QueryParamsRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var distribution_1 = require_distribution();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseQueryParamsRequest18() {
      return {};
    }
    exports$1.QueryParamsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest18();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest18();
        return message;
      }
    };
    function createBaseQueryParamsResponse18() {
      return {
        params: distribution_1.Params.fromPartial({})
      };
    }
    exports$1.QueryParamsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse18();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse18();
        if (object.params !== void 0 && object.params !== null) {
          message.params = distribution_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDistributionInfoRequest2() {
      return {
        validatorAddress: ""
      };
    }
    exports$1.QueryValidatorDistributionInfoRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDistributionInfoRequest2();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDistributionInfoRequest2();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorDistributionInfoResponse2() {
      return {
        operatorAddress: "",
        selfBondRewards: [],
        commission: []
      };
    }
    exports$1.QueryValidatorDistributionInfoResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        for (const v of message.selfBondRewards) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.commission) {
          coin_1.DecCoin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.selfBondRewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDistributionInfoResponse2();
        if ((0, helpers_1.isSet)(object.operatorAddress))
          obj.operatorAddress = String(object.operatorAddress);
        if (Array.isArray(object?.selfBondRewards))
          obj.selfBondRewards = object.selfBondRewards.map((e) => coin_1.DecCoin.fromJSON(e));
        if (Array.isArray(object?.commission))
          obj.commission = object.commission.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        if (message.selfBondRewards) {
          obj.selfBondRewards = message.selfBondRewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.selfBondRewards = [];
        }
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDistributionInfoResponse2();
        message.operatorAddress = object.operatorAddress ?? "";
        message.selfBondRewards = object.selfBondRewards?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        message.commission = object.commission?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsRequest2() {
      return {
        validatorAddress: ""
      };
    }
    exports$1.QueryValidatorOutstandingRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorOutstandingRewardsRequest2();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsRequest2();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsResponse2() {
      return {
        rewards: distribution_1.ValidatorOutstandingRewards.fromPartial({})
      };
    }
    exports$1.QueryValidatorOutstandingRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rewards !== void 0) {
          distribution_1.ValidatorOutstandingRewards.encode(message.rewards, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards = distribution_1.ValidatorOutstandingRewards.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorOutstandingRewardsResponse2();
        if ((0, helpers_1.isSet)(object.rewards))
          obj.rewards = distribution_1.ValidatorOutstandingRewards.fromJSON(object.rewards);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rewards !== void 0 && (obj.rewards = message.rewards ? distribution_1.ValidatorOutstandingRewards.toJSON(message.rewards) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsResponse2();
        if (object.rewards !== void 0 && object.rewards !== null) {
          message.rewards = distribution_1.ValidatorOutstandingRewards.fromPartial(object.rewards);
        }
        return message;
      }
    };
    function createBaseQueryValidatorCommissionRequest2() {
      return {
        validatorAddress: ""
      };
    }
    exports$1.QueryValidatorCommissionRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorCommissionRequest2();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorCommissionRequest2();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorCommissionResponse2() {
      return {
        commission: distribution_1.ValidatorAccumulatedCommission.fromPartial({})
      };
    }
    exports$1.QueryValidatorCommissionResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commission !== void 0) {
          distribution_1.ValidatorAccumulatedCommission.encode(message.commission, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission = distribution_1.ValidatorAccumulatedCommission.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorCommissionResponse2();
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = distribution_1.ValidatorAccumulatedCommission.fromJSON(object.commission);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commission !== void 0 && (obj.commission = message.commission ? distribution_1.ValidatorAccumulatedCommission.toJSON(message.commission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorCommissionResponse2();
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = distribution_1.ValidatorAccumulatedCommission.fromPartial(object.commission);
        }
        return message;
      }
    };
    function createBaseQueryValidatorSlashesRequest2() {
      return {
        validatorAddress: "",
        startingHeight: BigInt(0),
        endingHeight: BigInt(0),
        pagination: void 0
      };
    }
    exports$1.QueryValidatorSlashesRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        if (message.startingHeight !== BigInt(0)) {
          writer.uint32(16).uint64(message.startingHeight);
        }
        if (message.endingHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.endingHeight);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.startingHeight = reader.uint64();
              break;
            case 3:
              message.endingHeight = reader.uint64();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorSlashesRequest2();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.startingHeight))
          obj.startingHeight = BigInt(object.startingHeight.toString());
        if ((0, helpers_1.isSet)(object.endingHeight))
          obj.endingHeight = BigInt(object.endingHeight.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.startingHeight !== void 0 && (obj.startingHeight = (message.startingHeight || BigInt(0)).toString());
        message.endingHeight !== void 0 && (obj.endingHeight = (message.endingHeight || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorSlashesRequest2();
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.startingHeight !== void 0 && object.startingHeight !== null) {
          message.startingHeight = BigInt(object.startingHeight.toString());
        }
        if (object.endingHeight !== void 0 && object.endingHeight !== null) {
          message.endingHeight = BigInt(object.endingHeight.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorSlashesResponse2() {
      return {
        slashes: [],
        pagination: void 0
      };
    }
    exports$1.QueryValidatorSlashesResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.slashes) {
          distribution_1.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.slashes.push(distribution_1.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorSlashesResponse2();
        if (Array.isArray(object?.slashes))
          obj.slashes = object.slashes.map((e) => distribution_1.ValidatorSlashEvent.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.slashes) {
          obj.slashes = message.slashes.map((e) => e ? distribution_1.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.slashes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorSlashesResponse2();
        message.slashes = object.slashes?.map((e) => distribution_1.ValidatorSlashEvent.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegationRewardsRequest2() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports$1.QueryDelegationRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRewardsRequest2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRewardsRequest2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationRewardsResponse2() {
      return {
        rewards: []
      };
    }
    exports$1.QueryDelegationRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRewardsResponse2();
        if (Array.isArray(object?.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRewardsResponse2();
        message.rewards = object.rewards?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsRequest2() {
      return {
        delegatorAddress: ""
      };
    }
    exports$1.QueryDelegationTotalRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationTotalRewardsRequest2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationTotalRewardsRequest2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsResponse2() {
      return {
        rewards: [],
        total: []
      };
    }
    exports$1.QueryDelegationTotalRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          distribution_1.DelegationDelegatorReward.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.total) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(distribution_1.DelegationDelegatorReward.decode(reader, reader.uint32()));
              break;
            case 2:
              message.total.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationTotalRewardsResponse2();
        if (Array.isArray(object?.rewards))
          obj.rewards = object.rewards.map((e) => distribution_1.DelegationDelegatorReward.fromJSON(e));
        if (Array.isArray(object?.total))
          obj.total = object.total.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? distribution_1.DelegationDelegatorReward.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationTotalRewardsResponse2();
        message.rewards = object.rewards?.map((e) => distribution_1.DelegationDelegatorReward.fromPartial(e)) || [];
        message.total = object.total?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest3() {
      return {
        delegatorAddress: ""
      };
    }
    exports$1.QueryDelegatorValidatorsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsRequest3();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest3();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse3() {
      return {
        validators: []
      };
    }
    exports$1.QueryDelegatorValidatorsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsResponse3();
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e);
        } else {
          obj.validators = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsResponse3();
        message.validators = object.validators?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressRequest2() {
      return {
        delegatorAddress: ""
      };
    }
    exports$1.QueryDelegatorWithdrawAddressRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorWithdrawAddressRequest2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressRequest2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressResponse2() {
      return {
        withdrawAddress: ""
      };
    }
    exports$1.QueryDelegatorWithdrawAddressResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.withdrawAddress !== "") {
          writer.uint32(10).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorWithdrawAddressResponse2();
        if ((0, helpers_1.isSet)(object.withdrawAddress))
          obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressResponse2();
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
      }
    };
    function createBaseQueryCommunityPoolRequest3() {
      return {};
    }
    exports$1.QueryCommunityPoolRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryCommunityPoolRequest3();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryCommunityPoolRequest3();
        return message;
      }
    };
    function createBaseQueryCommunityPoolResponse3() {
      return {
        pool: []
      };
    }
    exports$1.QueryCommunityPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCommunityPoolResponse3();
        if (Array.isArray(object?.pool))
          obj.pool = object.pool.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pool) {
          obj.pool = message.pool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.pool = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCommunityPoolResponse3();
        message.pool = object.pool?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this);
        this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this);
        this.ValidatorCommission = this.ValidatorCommission.bind(this);
        this.ValidatorSlashes = this.ValidatorSlashes.bind(this);
        this.DelegationRewards = this.DelegationRewards.bind(this);
        this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this);
        this.CommunityPool = this.CommunityPool.bind(this);
      }
      Params(request = {}) {
        const data2 = exports$1.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports$1.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorDistributionInfo(request) {
        const data2 = exports$1.QueryValidatorDistributionInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", data2);
        return promise.then((data3) => exports$1.QueryValidatorDistributionInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorOutstandingRewards(request) {
        const data2 = exports$1.QueryValidatorOutstandingRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", data2);
        return promise.then((data3) => exports$1.QueryValidatorOutstandingRewardsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorCommission(request) {
        const data2 = exports$1.QueryValidatorCommissionRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", data2);
        return promise.then((data3) => exports$1.QueryValidatorCommissionResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorSlashes(request) {
        const data2 = exports$1.QueryValidatorSlashesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", data2);
        return promise.then((data3) => exports$1.QueryValidatorSlashesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegationRewards(request) {
        const data2 = exports$1.QueryDelegationRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", data2);
        return promise.then((data3) => exports$1.QueryDelegationRewardsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegationTotalRewards(request) {
        const data2 = exports$1.QueryDelegationTotalRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", data2);
        return promise.then((data3) => exports$1.QueryDelegationTotalRewardsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorValidators(request) {
        const data2 = exports$1.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", data2);
        return promise.then((data3) => exports$1.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorWithdrawAddress(request) {
        const data2 = exports$1.QueryDelegatorWithdrawAddressRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", data2);
        return promise.then((data3) => exports$1.QueryDelegatorWithdrawAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CommunityPool(request = {}) {
        const data2 = exports$1.QueryCommunityPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", data2);
        return promise.then((data3) => exports$1.QueryCommunityPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/distribution/queries.js
var require_queries4 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/distribution/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupDistributionExtension = setupDistributionExtension;
    var query_1 = require_query4();
    var queryclient_1 = require_queryclient2();
    function setupDistributionExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        distribution: {
          communityPool: async () => {
            const response = await queryService.CommunityPool({});
            return response;
          },
          delegationRewards: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegationRewards({
              delegatorAddress,
              validatorAddress
            });
            return response;
          },
          delegationTotalRewards: async (delegatorAddress) => {
            const response = await queryService.DelegationTotalRewards({
              delegatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddress
            });
            return response;
          },
          delegatorWithdrawAddress: async (delegatorAddress) => {
            const response = await queryService.DelegatorWithdrawAddress({
              delegatorAddress
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          validatorCommission: async (validatorAddress) => {
            const response = await queryService.ValidatorCommission({
              validatorAddress
            });
            return response;
          },
          validatorOutstandingRewards: async (validatorAddress) => {
            const response = await queryService.ValidatorOutstandingRewards({
              validatorAddress
            });
            return response;
          },
          validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey) => {
            const response = await queryService.ValidatorSlashes({
              validatorAddress,
              startingHeight: BigInt(startingHeight),
              endingHeight: BigInt(endingHeight),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js
var require_aminomessages5 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
    exports$1.createEvidenceAminoConverters = createEvidenceAminoConverters;
    function isAminoMsgSubmitEvidence(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitEvidence";
    }
    function createEvidenceAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js
var require_aminomessages6 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.createFeegrantAminoConverters = createFeegrantAminoConverters;
    function createFeegrantAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
        // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
      };
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js
var require_tx5 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgPruneAllowancesResponse = exports$1.MsgPruneAllowances = exports$1.MsgRevokeAllowanceResponse = exports$1.MsgRevokeAllowance = exports$1.MsgGrantAllowanceResponse = exports$1.MsgGrantAllowance = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseMsgGrantAllowance2() {
      return {
        granter: "",
        grantee: "",
        allowance: void 0
      };
    }
    exports$1.MsgGrantAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowance2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgGrantAllowance2();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgGrantAllowance2();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        return message;
      }
    };
    function createBaseMsgGrantAllowanceResponse2() {
      return {};
    }
    exports$1.MsgGrantAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowanceResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowanceResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgGrantAllowanceResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgGrantAllowanceResponse2();
        return message;
      }
    };
    function createBaseMsgRevokeAllowance2() {
      return {
        granter: "",
        grantee: ""
      };
    }
    exports$1.MsgRevokeAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowance2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRevokeAllowance2();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRevokeAllowance2();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
      }
    };
    function createBaseMsgRevokeAllowanceResponse2() {
      return {};
    }
    exports$1.MsgRevokeAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowanceResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowanceResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgRevokeAllowanceResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRevokeAllowanceResponse2();
        return message;
      }
    };
    function createBaseMsgPruneAllowances2() {
      return {
        pruner: ""
      };
    }
    exports$1.MsgPruneAllowances = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgPruneAllowances",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pruner !== "") {
          writer.uint32(10).string(message.pruner);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAllowances2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pruner = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPruneAllowances2();
        if ((0, helpers_1.isSet)(object.pruner))
          obj.pruner = String(object.pruner);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pruner !== void 0 && (obj.pruner = message.pruner);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPruneAllowances2();
        message.pruner = object.pruner ?? "";
        return message;
      }
    };
    function createBaseMsgPruneAllowancesResponse2() {
      return {};
    }
    exports$1.MsgPruneAllowancesResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgPruneAllowancesResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAllowancesResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgPruneAllowancesResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgPruneAllowancesResponse2();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.GrantAllowance = this.GrantAllowance.bind(this);
        this.RevokeAllowance = this.RevokeAllowance.bind(this);
        this.PruneAllowances = this.PruneAllowances.bind(this);
      }
      GrantAllowance(request) {
        const data2 = exports$1.MsgGrantAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", data2);
        return promise.then((data3) => exports$1.MsgGrantAllowanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RevokeAllowance(request) {
        const data2 = exports$1.MsgRevokeAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", data2);
        return promise.then((data3) => exports$1.MsgRevokeAllowanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PruneAllowances(request) {
        const data2 = exports$1.MsgPruneAllowances.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "PruneAllowances", data2);
        return promise.then((data3) => exports$1.MsgPruneAllowancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js
var require_messages4 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.feegrantTypes = void 0;
    var tx_1 = require_tx5();
    exports$1.feegrantTypes = [
      ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", tx_1.MsgGrantAllowance],
      ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", tx_1.MsgRevokeAllowance]
    ];
  }
});

// ../../node_modules/cosmjs-types/google/protobuf/duration.js
var require_duration = __commonJS({
  "../../node_modules/cosmjs-types/google/protobuf/duration.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Duration = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "google.protobuf";
    function createBaseDuration2() {
      return {
        seconds: BigInt(0),
        nanos: 0
      };
    }
    exports$1.Duration = {
      typeUrl: "/google.protobuf.Duration",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuration2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDuration2();
        if ((0, helpers_1.isSet)(object.seconds))
          obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos))
          obj.nanos = Number(object.nanos);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDuration2();
        if (object.seconds !== void 0 && object.seconds !== null) {
          message.seconds = BigInt(object.seconds.toString());
        }
        message.nanos = object.nanos ?? 0;
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js
var require_feegrant = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Grant = exports$1.AllowedMsgAllowance = exports$1.PeriodicAllowance = exports$1.BasicAllowance = exports$1.protobufPackage = void 0;
    var coin_1 = require_coin();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseBasicAllowance() {
      return {
        spendLimit: [],
        expiration: void 0
      };
    }
    exports$1.BasicAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.BasicAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.spendLimit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBasicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.spendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBasicAllowance();
        if (Array.isArray(object?.spendLimit))
          obj.spendLimit = object.spendLimit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.spendLimit) {
          obj.spendLimit = message.spendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.spendLimit = [];
        }
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBasicAllowance();
        message.spendLimit = object.spendLimit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBasePeriodicAllowance() {
      return {
        basic: exports$1.BasicAllowance.fromPartial({}),
        period: duration_1.Duration.fromPartial({}),
        periodSpendLimit: [],
        periodCanSpend: [],
        periodReset: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.PeriodicAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.PeriodicAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.basic !== void 0) {
          exports$1.BasicAllowance.encode(message.basic, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== void 0) {
          duration_1.Duration.encode(message.period, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.periodSpendLimit) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.periodCanSpend) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.periodReset !== void 0) {
          timestamp_1.Timestamp.encode(message.periodReset, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.basic = exports$1.BasicAllowance.decode(reader, reader.uint32());
              break;
            case 2:
              message.period = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.periodSpendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.periodCanSpend.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.periodReset = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriodicAllowance();
        if ((0, helpers_1.isSet)(object.basic))
          obj.basic = exports$1.BasicAllowance.fromJSON(object.basic);
        if ((0, helpers_1.isSet)(object.period))
          obj.period = duration_1.Duration.fromJSON(object.period);
        if (Array.isArray(object?.periodSpendLimit))
          obj.periodSpendLimit = object.periodSpendLimit.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object?.periodCanSpend))
          obj.periodCanSpend = object.periodCanSpend.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.periodReset))
          obj.periodReset = (0, helpers_1.fromJsonTimestamp)(object.periodReset);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.basic !== void 0 && (obj.basic = message.basic ? exports$1.BasicAllowance.toJSON(message.basic) : void 0);
        message.period !== void 0 && (obj.period = message.period ? duration_1.Duration.toJSON(message.period) : void 0);
        if (message.periodSpendLimit) {
          obj.periodSpendLimit = message.periodSpendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodSpendLimit = [];
        }
        if (message.periodCanSpend) {
          obj.periodCanSpend = message.periodCanSpend.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodCanSpend = [];
        }
        message.periodReset !== void 0 && (obj.periodReset = (0, helpers_1.fromTimestamp)(message.periodReset).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePeriodicAllowance();
        if (object.basic !== void 0 && object.basic !== null) {
          message.basic = exports$1.BasicAllowance.fromPartial(object.basic);
        }
        if (object.period !== void 0 && object.period !== null) {
          message.period = duration_1.Duration.fromPartial(object.period);
        }
        message.periodSpendLimit = object.periodSpendLimit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.periodCanSpend = object.periodCanSpend?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.periodReset !== void 0 && object.periodReset !== null) {
          message.periodReset = timestamp_1.Timestamp.fromPartial(object.periodReset);
        }
        return message;
      }
    };
    function createBaseAllowedMsgAllowance() {
      return {
        allowance: void 0,
        allowedMessages: []
      };
    }
    exports$1.AllowedMsgAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.AllowedMsgAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.allowedMessages) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAllowedMsgAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.allowedMessages.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAllowedMsgAllowance();
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        if (Array.isArray(object?.allowedMessages))
          obj.allowedMessages = object.allowedMessages.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        if (message.allowedMessages) {
          obj.allowedMessages = message.allowedMessages.map((e) => e);
        } else {
          obj.allowedMessages = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAllowedMsgAllowance();
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        message.allowedMessages = object.allowedMessages?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseGrant3() {
      return {
        granter: "",
        grantee: "",
        allowance: void 0
      };
    }
    exports$1.Grant = {
      typeUrl: "/cosmos.feegrant.v1beta1.Grant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrant3();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrant3();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js
var require_query5 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryAllowancesByGranterResponse = exports$1.QueryAllowancesByGranterRequest = exports$1.QueryAllowancesResponse = exports$1.QueryAllowancesRequest = exports$1.QueryAllowanceResponse = exports$1.QueryAllowanceRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var feegrant_1 = require_feegrant();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseQueryAllowanceRequest2() {
      return {
        granter: "",
        grantee: ""
      };
    }
    exports$1.QueryAllowanceRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowanceRequest2();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowanceRequest2();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
      }
    };
    function createBaseQueryAllowanceResponse2() {
      return {
        allowance: void 0
      };
    }
    exports$1.QueryAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== void 0) {
          feegrant_1.Grant.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = feegrant_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowanceResponse2();
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = feegrant_1.Grant.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? feegrant_1.Grant.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowanceResponse2();
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = feegrant_1.Grant.fromPartial(object.allowance);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesRequest2() {
      return {
        grantee: "",
        pagination: void 0
      };
    }
    exports$1.QueryAllowancesRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesRequest2();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesRequest2();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesResponse2() {
      return {
        allowances: [],
        pagination: void 0
      };
    }
    exports$1.QueryAllowancesResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowances) {
          feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesResponse2();
        if (Array.isArray(object?.allowances))
          obj.allowances = object.allowances.map((e) => feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesResponse2();
        message.allowances = object.allowances?.map((e) => feegrant_1.Grant.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterRequest2() {
      return {
        granter: "",
        pagination: void 0
      };
    }
    exports$1.QueryAllowancesByGranterRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesByGranterRequest2();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesByGranterRequest2();
        message.granter = object.granter ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterResponse2() {
      return {
        allowances: [],
        pagination: void 0
      };
    }
    exports$1.QueryAllowancesByGranterResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowances) {
          feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesByGranterResponse2();
        if (Array.isArray(object?.allowances))
          obj.allowances = object.allowances.map((e) => feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesByGranterResponse2();
        message.allowances = object.allowances?.map((e) => feegrant_1.Grant.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Allowance = this.Allowance.bind(this);
        this.Allowances = this.Allowances.bind(this);
        this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
      }
      Allowance(request) {
        const data2 = exports$1.QueryAllowanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", data2);
        return promise.then((data3) => exports$1.QueryAllowanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Allowances(request) {
        const data2 = exports$1.QueryAllowancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", data2);
        return promise.then((data3) => exports$1.QueryAllowancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AllowancesByGranter(request) {
        const data2 = exports$1.QueryAllowancesByGranterRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", data2);
        return promise.then((data3) => exports$1.QueryAllowancesByGranterResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js
var require_queries5 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupFeegrantExtension = setupFeegrantExtension;
    var query_1 = require_query5();
    var queryclient_1 = require_queryclient2();
    function setupFeegrantExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        feegrant: {
          allowance: async (granter, grantee) => {
            const response = await queryService.Allowance({
              granter,
              grantee
            });
            return response;
          },
          allowances: async (grantee, paginationKey) => {
            const response = await queryService.Allowances({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js
var require_gov = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.TallyParams = exports$1.VotingParams = exports$1.DepositParams = exports$1.Vote = exports$1.TallyResult = exports$1.Proposal = exports$1.Deposit = exports$1.TextProposal = exports$1.WeightedVoteOption = exports$1.proposalStatusToJSON = exports$1.proposalStatusFromJSON = exports$1.ProposalStatus = exports$1.voteOptionToJSON = exports$1.voteOptionFromJSON = exports$1.VoteOption = exports$1.protobufPackage = void 0;
    var coin_1 = require_coin();
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.gov.v1beta1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports$1.VoteOption = VoteOption = {}));
    function voteOptionFromJSON4(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports$1.voteOptionFromJSON = voteOptionFromJSON4;
    function voteOptionToJSON4(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.voteOptionToJSON = voteOptionToJSON4;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports$1.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON4(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports$1.proposalStatusFromJSON = proposalStatusFromJSON4;
    function proposalStatusToJSON4(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.proposalStatusToJSON = proposalStatusToJSON4;
    function createBaseWeightedVoteOption3() {
      return {
        option: 0,
        weight: ""
      };
    }
    exports$1.WeightedVoteOption = {
      typeUrl: "/cosmos.gov.v1beta1.WeightedVoteOption",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseWeightedVoteOption3();
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON4(object.option);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON4(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseWeightedVoteOption3();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
      }
    };
    function createBaseTextProposal() {
      return {
        title: "",
        description: ""
      };
    }
    exports$1.TextProposal = {
      typeUrl: "/cosmos.gov.v1beta1.TextProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTextProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTextProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTextProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
      }
    };
    function createBaseDeposit4() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports$1.Deposit = {
      typeUrl: "/cosmos.gov.v1beta1.Deposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDeposit4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDeposit4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseProposal4() {
      return {
        proposalId: BigInt(0),
        content: void 0,
        status: 0,
        finalTallyResult: exports$1.TallyResult.fromPartial({}),
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        depositEndTime: timestamp_1.Timestamp.fromPartial({}),
        totalDeposit: [],
        votingStartTime: timestamp_1.Timestamp.fromPartial({}),
        votingEndTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.Proposal = {
      typeUrl: "/cosmos.gov.v1beta1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports$1.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
          coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports$1.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON4(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports$1.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime))
          obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object?.totalDeposit))
          obj.totalDeposit = object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime))
          obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime))
          obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.status !== void 0 && (obj.status = proposalStatusToJSON4(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports$1.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports$1.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.depositEndTime !== void 0 && object.depositEndTime !== null) {
          message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        }
        message.totalDeposit = object.totalDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.votingStartTime !== void 0 && object.votingStartTime !== null) {
          message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        }
        if (object.votingEndTime !== void 0 && object.votingEndTime !== null) {
          message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        }
        return message;
      }
    };
    function createBaseTallyResult4() {
      return {
        yes: "",
        abstain: "",
        no: "",
        noWithVeto: ""
      };
    }
    exports$1.TallyResult = {
      typeUrl: "/cosmos.gov.v1beta1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yes !== "") {
          writer.uint32(10).string(message.yes);
        }
        if (message.abstain !== "") {
          writer.uint32(18).string(message.abstain);
        }
        if (message.no !== "") {
          writer.uint32(26).string(message.no);
        }
        if (message.noWithVeto !== "") {
          writer.uint32(34).string(message.noWithVeto);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yes = reader.string();
              break;
            case 2:
              message.abstain = reader.string();
              break;
            case 3:
              message.no = reader.string();
              break;
            case 4:
              message.noWithVeto = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult4();
        if ((0, helpers_1.isSet)(object.yes))
          obj.yes = String(object.yes);
        if ((0, helpers_1.isSet)(object.abstain))
          obj.abstain = String(object.abstain);
        if ((0, helpers_1.isSet)(object.no))
          obj.no = String(object.no);
        if ((0, helpers_1.isSet)(object.noWithVeto))
          obj.noWithVeto = String(object.noWithVeto);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yes !== void 0 && (obj.yes = message.yes);
        message.abstain !== void 0 && (obj.abstain = message.abstain);
        message.no !== void 0 && (obj.no = message.no);
        message.noWithVeto !== void 0 && (obj.noWithVeto = message.noWithVeto);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult4();
        message.yes = object.yes ?? "";
        message.abstain = object.abstain ?? "";
        message.no = object.no ?? "";
        message.noWithVeto = object.noWithVeto ?? "";
        return message;
      }
    };
    function createBaseVote5() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        options: []
      };
    }
    exports$1.Vote = {
      typeUrl: "/cosmos.gov.v1beta1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        for (const v of message.options) {
          exports$1.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote5();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.options.push(exports$1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote5();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON4(object.option);
        if (Array.isArray(object?.options))
          obj.options = object.options.map((e) => exports$1.WeightedVoteOption.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON4(message.option));
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports$1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote5();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.options = object.options?.map((e) => exports$1.WeightedVoteOption.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDepositParams3() {
      return {
        minDeposit: [],
        maxDepositPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports$1.DepositParams = {
      typeUrl: "/cosmos.gov.v1beta1.DepositParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDepositParams3();
        if (Array.isArray(object?.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDepositParams3();
        message.minDeposit = object.minDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        return message;
      }
    };
    function createBaseVotingParams3() {
      return {
        votingPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports$1.VotingParams = {
      typeUrl: "/cosmos.gov.v1beta1.VotingParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVotingParams3();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams3();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        return message;
      }
    };
    function createBaseTallyParams3() {
      return {
        quorum: new Uint8Array(),
        threshold: new Uint8Array(),
        vetoThreshold: new Uint8Array()
      };
    }
    exports$1.TallyParams = {
      typeUrl: "/cosmos.gov.v1beta1.TallyParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum.length !== 0) {
          writer.uint32(10).bytes(message.quorum);
        }
        if (message.threshold.length !== 0) {
          writer.uint32(18).bytes(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
          writer.uint32(26).bytes(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.bytes();
              break;
            case 2:
              message.threshold = reader.bytes();
              break;
            case 3:
              message.vetoThreshold = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyParams3();
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = (0, helpers_1.bytesFromBase64)(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = (0, helpers_1.bytesFromBase64)(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = (0, helpers_1.bytesFromBase64)(object.vetoThreshold);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = (0, helpers_1.base64FromBytes)(message.quorum !== void 0 ? message.quorum : new Uint8Array()));
        message.threshold !== void 0 && (obj.threshold = (0, helpers_1.base64FromBytes)(message.threshold !== void 0 ? message.threshold : new Uint8Array()));
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = (0, helpers_1.base64FromBytes)(message.vetoThreshold !== void 0 ? message.vetoThreshold : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyParams3();
        message.quorum = object.quorum ?? new Uint8Array();
        message.threshold = object.threshold ?? new Uint8Array();
        message.vetoThreshold = object.vetoThreshold ?? new Uint8Array();
        return message;
      }
    };
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js
var require_aminomessages7 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
    exports$1.isAminoMsgVote = isAminoMsgVote;
    exports$1.isAminoMsgVoteWeighted = isAminoMsgVoteWeighted;
    exports$1.isAminoMsgDeposit = isAminoMsgDeposit;
    exports$1.createGovAminoConverters = createGovAminoConverters;
    var math_1 = require_build();
    var utils_1 = require_build3();
    var gov_1 = require_gov();
    var any_1 = require_any();
    var queryclient_1 = require_queryclient2();
    function isAminoMsgSubmitProposal(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitProposal";
    }
    function isAminoMsgVote(msg) {
      return msg.type === "cosmos-sdk/MsgVote";
    }
    function isAminoMsgVoteWeighted(msg) {
      return msg.type === "cosmos-sdk/MsgVoteWeighted";
    }
    function isAminoMsgDeposit(msg) {
      return msg.type === "cosmos-sdk/MsgDeposit";
    }
    function createGovAminoConverters() {
      return {
        "/cosmos.gov.v1beta1.MsgDeposit": {
          aminoType: "cosmos-sdk/MsgDeposit",
          toAmino: ({ amount, depositor, proposalId }) => {
            return {
              amount,
              depositor,
              proposal_id: proposalId.toString()
            };
          },
          fromAmino: ({ amount, depositor, proposal_id }) => {
            return {
              amount: Array.from(amount),
              depositor,
              proposalId: BigInt(proposal_id)
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
          aminoType: "cosmos-sdk/MsgVote",
          toAmino: ({ option, proposalId, voter }) => {
            return {
              option,
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ option, proposal_id, voter }) => {
            return {
              option: (0, gov_1.voteOptionFromJSON)(option),
              proposalId: BigInt(proposal_id),
              voter
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVoteWeighted": {
          aminoType: "cosmos-sdk/MsgVoteWeighted",
          toAmino: ({ options, proposalId, voter }) => {
            return {
              options: options.map((o) => ({
                option: o.option,
                // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
                // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
                weight: (0, queryclient_1.decodeCosmosSdkDecFromProto)(o.weight).toString().padEnd(20, "0")
              })),
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ options, proposal_id, voter }) => {
            return {
              proposalId: BigInt(proposal_id),
              voter,
              options: options.map((o) => ({
                option: (0, gov_1.voteOptionFromJSON)(o.option),
                weight: math_1.Decimal.fromUserInput(o.weight, 18).atomics
              }))
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
          aminoType: "cosmos-sdk/MsgSubmitProposal",
          toAmino: ({ initialDeposit, proposer, content }) => {
            (0, utils_1.assertDefinedAndNotNull)(content);
            let proposal;
            switch (content.typeUrl) {
              case "/cosmos.gov.v1beta1.TextProposal": {
                const textProposal = gov_1.TextProposal.decode(content.value);
                proposal = {
                  type: "cosmos-sdk/TextProposal",
                  value: {
                    description: textProposal.description,
                    title: textProposal.title
                  }
                };
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
            }
            return {
              initial_deposit: initialDeposit,
              proposer,
              content: proposal
            };
          },
          fromAmino: ({ initial_deposit, proposer, content }) => {
            let any_content;
            switch (content.type) {
              case "cosmos-sdk/TextProposal": {
                const { value } = content;
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                const { title, description } = value;
                (0, utils_1.assert)(typeof title === "string");
                (0, utils_1.assert)(typeof description === "string");
                any_content = any_1.Any.fromPartial({
                  typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                  value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                    title,
                    description
                  })).finish()
                });
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.type}'`);
            }
            return {
              initialDeposit: Array.from(initial_deposit),
              proposer,
              content: any_content
            };
          }
        }
      };
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/gov/v1/gov.js
var require_gov2 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/gov/v1/gov.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = exports$1.TallyParams = exports$1.VotingParams = exports$1.DepositParams = exports$1.Vote = exports$1.TallyResult = exports$1.Proposal = exports$1.Deposit = exports$1.WeightedVoteOption = exports$1.proposalStatusToJSON = exports$1.proposalStatusFromJSON = exports$1.ProposalStatus = exports$1.voteOptionToJSON = exports$1.voteOptionFromJSON = exports$1.VoteOption = exports$1.protobufPackage = void 0;
    var coin_1 = require_coin();
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.gov.v1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports$1.VoteOption = VoteOption = {}));
    function voteOptionFromJSON4(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports$1.voteOptionFromJSON = voteOptionFromJSON4;
    function voteOptionToJSON4(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.voteOptionToJSON = voteOptionToJSON4;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports$1.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON4(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports$1.proposalStatusFromJSON = proposalStatusFromJSON4;
    function proposalStatusToJSON4(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.proposalStatusToJSON = proposalStatusToJSON4;
    function createBaseWeightedVoteOption3() {
      return {
        option: 0,
        weight: ""
      };
    }
    exports$1.WeightedVoteOption = {
      typeUrl: "/cosmos.gov.v1.WeightedVoteOption",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseWeightedVoteOption3();
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON4(object.option);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON4(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseWeightedVoteOption3();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
      }
    };
    function createBaseDeposit4() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports$1.Deposit = {
      typeUrl: "/cosmos.gov.v1.Deposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDeposit4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDeposit4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseProposal4() {
      return {
        id: BigInt(0),
        messages: [],
        status: 0,
        finalTallyResult: void 0,
        submitTime: void 0,
        depositEndTime: void 0,
        totalDeposit: [],
        votingStartTime: void 0,
        votingEndTime: void 0,
        metadata: "",
        title: "",
        summary: "",
        proposer: "",
        expedited: false,
        failedReason: ""
      };
    }
    exports$1.Proposal = {
      typeUrl: "/cosmos.gov.v1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports$1.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
          coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(82).string(message.metadata);
        }
        if (message.title !== "") {
          writer.uint32(90).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(98).string(message.summary);
        }
        if (message.proposer !== "") {
          writer.uint32(106).string(message.proposer);
        }
        if (message.expedited === true) {
          writer.uint32(112).bool(message.expedited);
        }
        if (message.failedReason !== "") {
          writer.uint32(122).string(message.failedReason);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports$1.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.metadata = reader.string();
              break;
            case 11:
              message.title = reader.string();
              break;
            case 12:
              message.summary = reader.string();
              break;
            case 13:
              message.proposer = reader.string();
              break;
            case 14:
              message.expedited = reader.bool();
              break;
            case 15:
              message.failedReason = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal4();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON4(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports$1.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime))
          obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object?.totalDeposit))
          obj.totalDeposit = object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime))
          obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime))
          obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        if ((0, helpers_1.isSet)(object.expedited))
          obj.expedited = Boolean(object.expedited);
        if ((0, helpers_1.isSet)(object.failedReason))
          obj.failedReason = String(object.failedReason);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.status !== void 0 && (obj.status = proposalStatusToJSON4(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports$1.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        message.expedited !== void 0 && (obj.expedited = message.expedited);
        message.failedReason !== void 0 && (obj.failedReason = message.failedReason);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal4();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports$1.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.depositEndTime !== void 0 && object.depositEndTime !== null) {
          message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        }
        message.totalDeposit = object.totalDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.votingStartTime !== void 0 && object.votingStartTime !== null) {
          message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        }
        if (object.votingEndTime !== void 0 && object.votingEndTime !== null) {
          message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        }
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        message.proposer = object.proposer ?? "";
        message.expedited = object.expedited ?? false;
        message.failedReason = object.failedReason ?? "";
        return message;
      }
    };
    function createBaseTallyResult4() {
      return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
      };
    }
    exports$1.TallyResult = {
      typeUrl: "/cosmos.gov.v1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") {
          writer.uint32(10).string(message.yesCount);
        }
        if (message.abstainCount !== "") {
          writer.uint32(18).string(message.abstainCount);
        }
        if (message.noCount !== "") {
          writer.uint32(26).string(message.noCount);
        }
        if (message.noWithVetoCount !== "") {
          writer.uint32(34).string(message.noWithVetoCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yesCount = reader.string();
              break;
            case 2:
              message.abstainCount = reader.string();
              break;
            case 3:
              message.noCount = reader.string();
              break;
            case 4:
              message.noWithVetoCount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult4();
        if ((0, helpers_1.isSet)(object.yesCount))
          obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount))
          obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount))
          obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount))
          obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yesCount !== void 0 && (obj.yesCount = message.yesCount);
        message.abstainCount !== void 0 && (obj.abstainCount = message.abstainCount);
        message.noCount !== void 0 && (obj.noCount = message.noCount);
        message.noWithVetoCount !== void 0 && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult4();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
      }
    };
    function createBaseVote5() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
      };
    }
    exports$1.Vote = {
      typeUrl: "/cosmos.gov.v1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          exports$1.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(42).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote5();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 4:
              message.options.push(exports$1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            case 5:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote5();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object?.options))
          obj.options = object.options.map((e) => exports$1.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports$1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote5();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e) => exports$1.WeightedVoteOption.fromPartial(e)) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseDepositParams3() {
      return {
        minDeposit: [],
        maxDepositPeriod: void 0
      };
    }
    exports$1.DepositParams = {
      typeUrl: "/cosmos.gov.v1.DepositParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDepositParams3();
        if (Array.isArray(object?.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDepositParams3();
        message.minDeposit = object.minDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        return message;
      }
    };
    function createBaseVotingParams3() {
      return {
        votingPeriod: void 0
      };
    }
    exports$1.VotingParams = {
      typeUrl: "/cosmos.gov.v1.VotingParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVotingParams3();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams3();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        return message;
      }
    };
    function createBaseTallyParams3() {
      return {
        quorum: "",
        threshold: "",
        vetoThreshold: ""
      };
    }
    exports$1.TallyParams = {
      typeUrl: "/cosmos.gov.v1.TallyParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum !== "") {
          writer.uint32(10).string(message.quorum);
        }
        if (message.threshold !== "") {
          writer.uint32(18).string(message.threshold);
        }
        if (message.vetoThreshold !== "") {
          writer.uint32(26).string(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.string();
              break;
            case 2:
              message.threshold = reader.string();
              break;
            case 3:
              message.vetoThreshold = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyParams3();
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = String(object.vetoThreshold);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = message.quorum);
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = message.vetoThreshold);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyParams3();
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        return message;
      }
    };
    function createBaseParams15() {
      return {
        minDeposit: [],
        maxDepositPeriod: void 0,
        votingPeriod: void 0,
        quorum: "",
        threshold: "",
        vetoThreshold: "",
        minInitialDepositRatio: "",
        proposalCancelRatio: "",
        proposalCancelDest: "",
        expeditedVotingPeriod: void 0,
        expeditedThreshold: "",
        expeditedMinDeposit: [],
        burnVoteQuorum: false,
        burnProposalDepositPrevote: false,
        burnVoteVeto: false,
        minDepositRatio: ""
      };
    }
    exports$1.Params = {
      typeUrl: "/cosmos.gov.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.quorum !== "") {
          writer.uint32(34).string(message.quorum);
        }
        if (message.threshold !== "") {
          writer.uint32(42).string(message.threshold);
        }
        if (message.vetoThreshold !== "") {
          writer.uint32(50).string(message.vetoThreshold);
        }
        if (message.minInitialDepositRatio !== "") {
          writer.uint32(58).string(message.minInitialDepositRatio);
        }
        if (message.proposalCancelRatio !== "") {
          writer.uint32(66).string(message.proposalCancelRatio);
        }
        if (message.proposalCancelDest !== "") {
          writer.uint32(74).string(message.proposalCancelDest);
        }
        if (message.expeditedVotingPeriod !== void 0) {
          duration_1.Duration.encode(message.expeditedVotingPeriod, writer.uint32(82).fork()).ldelim();
        }
        if (message.expeditedThreshold !== "") {
          writer.uint32(90).string(message.expeditedThreshold);
        }
        for (const v of message.expeditedMinDeposit) {
          coin_1.Coin.encode(v, writer.uint32(98).fork()).ldelim();
        }
        if (message.burnVoteQuorum === true) {
          writer.uint32(104).bool(message.burnVoteQuorum);
        }
        if (message.burnProposalDepositPrevote === true) {
          writer.uint32(112).bool(message.burnProposalDepositPrevote);
        }
        if (message.burnVoteVeto === true) {
          writer.uint32(120).bool(message.burnVoteVeto);
        }
        if (message.minDepositRatio !== "") {
          writer.uint32(130).string(message.minDepositRatio);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.quorum = reader.string();
              break;
            case 5:
              message.threshold = reader.string();
              break;
            case 6:
              message.vetoThreshold = reader.string();
              break;
            case 7:
              message.minInitialDepositRatio = reader.string();
              break;
            case 8:
              message.proposalCancelRatio = reader.string();
              break;
            case 9:
              message.proposalCancelDest = reader.string();
              break;
            case 10:
              message.expeditedVotingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 11:
              message.expeditedThreshold = reader.string();
              break;
            case 12:
              message.expeditedMinDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 13:
              message.burnVoteQuorum = reader.bool();
              break;
            case 14:
              message.burnProposalDepositPrevote = reader.bool();
              break;
            case 15:
              message.burnVoteVeto = reader.bool();
              break;
            case 16:
              message.minDepositRatio = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if (Array.isArray(object?.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = String(object.vetoThreshold);
        if ((0, helpers_1.isSet)(object.minInitialDepositRatio))
          obj.minInitialDepositRatio = String(object.minInitialDepositRatio);
        if ((0, helpers_1.isSet)(object.proposalCancelRatio))
          obj.proposalCancelRatio = String(object.proposalCancelRatio);
        if ((0, helpers_1.isSet)(object.proposalCancelDest))
          obj.proposalCancelDest = String(object.proposalCancelDest);
        if ((0, helpers_1.isSet)(object.expeditedVotingPeriod))
          obj.expeditedVotingPeriod = duration_1.Duration.fromJSON(object.expeditedVotingPeriod);
        if ((0, helpers_1.isSet)(object.expeditedThreshold))
          obj.expeditedThreshold = String(object.expeditedThreshold);
        if (Array.isArray(object?.expeditedMinDeposit))
          obj.expeditedMinDeposit = object.expeditedMinDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.burnVoteQuorum))
          obj.burnVoteQuorum = Boolean(object.burnVoteQuorum);
        if ((0, helpers_1.isSet)(object.burnProposalDepositPrevote))
          obj.burnProposalDepositPrevote = Boolean(object.burnProposalDepositPrevote);
        if ((0, helpers_1.isSet)(object.burnVoteVeto))
          obj.burnVoteVeto = Boolean(object.burnVoteVeto);
        if ((0, helpers_1.isSet)(object.minDepositRatio))
          obj.minDepositRatio = String(object.minDepositRatio);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        message.quorum !== void 0 && (obj.quorum = message.quorum);
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = message.vetoThreshold);
        message.minInitialDepositRatio !== void 0 && (obj.minInitialDepositRatio = message.minInitialDepositRatio);
        message.proposalCancelRatio !== void 0 && (obj.proposalCancelRatio = message.proposalCancelRatio);
        message.proposalCancelDest !== void 0 && (obj.proposalCancelDest = message.proposalCancelDest);
        message.expeditedVotingPeriod !== void 0 && (obj.expeditedVotingPeriod = message.expeditedVotingPeriod ? duration_1.Duration.toJSON(message.expeditedVotingPeriod) : void 0);
        message.expeditedThreshold !== void 0 && (obj.expeditedThreshold = message.expeditedThreshold);
        if (message.expeditedMinDeposit) {
          obj.expeditedMinDeposit = message.expeditedMinDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.expeditedMinDeposit = [];
        }
        message.burnVoteQuorum !== void 0 && (obj.burnVoteQuorum = message.burnVoteQuorum);
        message.burnProposalDepositPrevote !== void 0 && (obj.burnProposalDepositPrevote = message.burnProposalDepositPrevote);
        message.burnVoteVeto !== void 0 && (obj.burnVoteVeto = message.burnVoteVeto);
        message.minDepositRatio !== void 0 && (obj.minDepositRatio = message.minDepositRatio);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        message.minDeposit = object.minDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        message.minInitialDepositRatio = object.minInitialDepositRatio ?? "";
        message.proposalCancelRatio = object.proposalCancelRatio ?? "";
        message.proposalCancelDest = object.proposalCancelDest ?? "";
        if (object.expeditedVotingPeriod !== void 0 && object.expeditedVotingPeriod !== null) {
          message.expeditedVotingPeriod = duration_1.Duration.fromPartial(object.expeditedVotingPeriod);
        }
        message.expeditedThreshold = object.expeditedThreshold ?? "";
        message.expeditedMinDeposit = object.expeditedMinDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.burnVoteQuorum = object.burnVoteQuorum ?? false;
        message.burnProposalDepositPrevote = object.burnProposalDepositPrevote ?? false;
        message.burnVoteVeto = object.burnVoteVeto ?? false;
        message.minDepositRatio = object.minDepositRatio ?? "";
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/gov/v1/tx.js
var require_tx6 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/gov/v1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgCancelProposalResponse = exports$1.MsgCancelProposal = exports$1.MsgUpdateParamsResponse = exports$1.MsgUpdateParams = exports$1.MsgDepositResponse = exports$1.MsgDeposit = exports$1.MsgVoteWeightedResponse = exports$1.MsgVoteWeighted = exports$1.MsgVoteResponse = exports$1.MsgVote = exports$1.MsgExecLegacyContentResponse = exports$1.MsgExecLegacyContent = exports$1.MsgSubmitProposalResponse = exports$1.MsgSubmitProposal = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var coin_1 = require_coin();
    var gov_1 = require_gov2();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.gov.v1";
    function createBaseMsgSubmitProposal4() {
      return {
        messages: [],
        initialDeposit: [],
        proposer: "",
        metadata: "",
        title: "",
        summary: "",
        expedited: false
      };
    }
    exports$1.MsgSubmitProposal = {
      typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.title !== "") {
          writer.uint32(42).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(50).string(message.summary);
        }
        if (message.expedited === true) {
          writer.uint32(56).bool(message.expedited);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.title = reader.string();
              break;
            case 6:
              message.summary = reader.string();
              break;
            case 7:
              message.expedited = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal4();
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if (Array.isArray(object?.initialDeposit))
          obj.initialDeposit = object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        if ((0, helpers_1.isSet)(object.expedited))
          obj.expedited = Boolean(object.expedited);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        message.expedited !== void 0 && (obj.expedited = message.expedited);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposal4();
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.initialDeposit = object.initialDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.proposer = object.proposer ?? "";
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        message.expedited = object.expedited ?? false;
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse4() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports$1.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.gov.v1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgExecLegacyContent2() {
      return {
        content: void 0,
        authority: ""
      };
    }
    exports$1.MsgExecLegacyContent = {
      typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        if (message.authority !== "") {
          writer.uint32(18).string(message.authority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContent2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.authority = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecLegacyContent2();
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.authority !== void 0 && (obj.authority = message.authority);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecLegacyContent2();
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.authority = object.authority ?? "";
        return message;
      }
    };
    function createBaseMsgExecLegacyContentResponse2() {
      return {};
    }
    exports$1.MsgExecLegacyContentResponse = {
      typeUrl: "/cosmos.gov.v1.MsgExecLegacyContentResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContentResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgExecLegacyContentResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgExecLegacyContentResponse2();
        return message;
      }
    };
    function createBaseMsgVote4() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: ""
      };
    }
    exports$1.MsgVote = {
      typeUrl: "/cosmos.gov.v1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgVoteResponse4() {
      return {};
    }
    exports$1.MsgVoteResponse = {
      typeUrl: "/cosmos.gov.v1.MsgVoteResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteResponse4();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse4();
        return message;
      }
    };
    function createBaseMsgVoteWeighted3() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
      };
    }
    exports$1.MsgVoteWeighted = {
      typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            case 4:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVoteWeighted3();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object?.options))
          obj.options = object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVoteWeighted3();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e) => gov_1.WeightedVoteOption.fromPartial(e)) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse3() {
      return {};
    }
    exports$1.MsgVoteWeightedResponse = {
      typeUrl: "/cosmos.gov.v1.MsgVoteWeightedResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteWeightedResponse3();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteWeightedResponse3();
        return message;
      }
    };
    function createBaseMsgDeposit3() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports$1.MsgDeposit = {
      typeUrl: "/cosmos.gov.v1.MsgDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDeposit3();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDeposit3();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse3() {
      return {};
    }
    exports$1.MsgDepositResponse = {
      typeUrl: "/cosmos.gov.v1.MsgDepositResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDepositResponse3();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositResponse3();
        return message;
      }
    };
    function createBaseMsgUpdateParams17() {
      return {
        authority: "",
        params: gov_1.Params.fromPartial({})
      };
    }
    exports$1.MsgUpdateParams = {
      typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          gov_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = gov_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams17();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = gov_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? gov_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams17();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = gov_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse17() {
      return {};
    }
    exports$1.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.gov.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse17();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse17();
        return message;
      }
    };
    function createBaseMsgCancelProposal2() {
      return {
        proposalId: BigInt(0),
        proposer: ""
      };
    }
    exports$1.MsgCancelProposal = {
      typeUrl: "/cosmos.gov.v1.MsgCancelProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.proposer !== "") {
          writer.uint32(18).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelProposal2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelProposal2();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelProposal2();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.proposer = object.proposer ?? "";
        return message;
      }
    };
    function createBaseMsgCancelProposalResponse2() {
      return {
        proposalId: BigInt(0),
        canceledTime: timestamp_1.Timestamp.fromPartial({}),
        canceledHeight: BigInt(0)
      };
    }
    exports$1.MsgCancelProposalResponse = {
      typeUrl: "/cosmos.gov.v1.MsgCancelProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.canceledTime !== void 0) {
          timestamp_1.Timestamp.encode(message.canceledTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.canceledHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.canceledHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelProposalResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.canceledTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.canceledHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelProposalResponse2();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.canceledTime))
          obj.canceledTime = (0, helpers_1.fromJsonTimestamp)(object.canceledTime);
        if ((0, helpers_1.isSet)(object.canceledHeight))
          obj.canceledHeight = BigInt(object.canceledHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.canceledTime !== void 0 && (obj.canceledTime = (0, helpers_1.fromTimestamp)(message.canceledTime).toISOString());
        message.canceledHeight !== void 0 && (obj.canceledHeight = (message.canceledHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelProposalResponse2();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.canceledTime !== void 0 && object.canceledTime !== null) {
          message.canceledTime = timestamp_1.Timestamp.fromPartial(object.canceledTime);
        }
        if (object.canceledHeight !== void 0 && object.canceledHeight !== null) {
          message.canceledHeight = BigInt(object.canceledHeight.toString());
        }
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.ExecLegacyContent = this.ExecLegacyContent.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.CancelProposal = this.CancelProposal.bind(this);
      }
      SubmitProposal(request) {
        const data2 = exports$1.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", data2);
        return promise.then((data3) => exports$1.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ExecLegacyContent(request) {
        const data2 = exports$1.MsgExecLegacyContent.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", data2);
        return promise.then((data3) => exports$1.MsgExecLegacyContentResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports$1.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Vote", data2);
        return promise.then((data3) => exports$1.MsgVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      VoteWeighted(request) {
        const data2 = exports$1.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", data2);
        return promise.then((data3) => exports$1.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposit(request) {
        const data2 = exports$1.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Deposit", data2);
        return promise.then((data3) => exports$1.MsgDepositResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports$1.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports$1.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CancelProposal(request) {
        const data2 = exports$1.MsgCancelProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "CancelProposal", data2);
        return promise.then((data3) => exports$1.MsgCancelProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js
var require_tx7 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgDepositResponse = exports$1.MsgDeposit = exports$1.MsgVoteWeightedResponse = exports$1.MsgVoteWeighted = exports$1.MsgVoteResponse = exports$1.MsgVote = exports$1.MsgSubmitProposalResponse = exports$1.MsgSubmitProposal = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var coin_1 = require_coin();
    var gov_1 = require_gov();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseMsgSubmitProposal4() {
      return {
        content: void 0,
        initialDeposit: [],
        proposer: ""
      };
    }
    exports$1.MsgSubmitProposal = {
      typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal4();
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if (Array.isArray(object?.initialDeposit))
          obj.initialDeposit = object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposal4();
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.initialDeposit = object.initialDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.proposer = object.proposer ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse4() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports$1.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgVote4() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0
      };
    }
    exports$1.MsgVote = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse4() {
      return {};
    }
    exports$1.MsgVoteResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteResponse4();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse4();
        return message;
      }
    };
    function createBaseMsgVoteWeighted3() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: []
      };
    }
    exports$1.MsgVoteWeighted = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVoteWeighted3();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object?.options))
          obj.options = object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVoteWeighted3();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e) => gov_1.WeightedVoteOption.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse3() {
      return {};
    }
    exports$1.MsgVoteWeightedResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeightedResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteWeightedResponse3();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteWeightedResponse3();
        return message;
      }
    };
    function createBaseMsgDeposit3() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports$1.MsgDeposit = {
      typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDeposit3();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDeposit3();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse3() {
      return {};
    }
    exports$1.MsgDepositResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgDepositResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDepositResponse3();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositResponse3();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
      }
      SubmitProposal(request) {
        const data2 = exports$1.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", data2);
        return promise.then((data3) => exports$1.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports$1.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", data2);
        return promise.then((data3) => exports$1.MsgVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      VoteWeighted(request) {
        const data2 = exports$1.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", data2);
        return promise.then((data3) => exports$1.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposit(request) {
        const data2 = exports$1.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", data2);
        return promise.then((data3) => exports$1.MsgDepositResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/gov/messages.js
var require_messages5 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/gov/messages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.govTypes = void 0;
    exports$1.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
    exports$1.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
    exports$1.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
    exports$1.isMsgVoteWeightedEncodeObject = isMsgVoteWeightedEncodeObject;
    var tx_1 = require_tx6();
    var tx_2 = require_tx7();
    exports$1.govTypes = [
      ["/cosmos.gov.v1.MsgDeposit", tx_1.MsgDeposit],
      ["/cosmos.gov.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.gov.v1.MsgUpdateParams", tx_1.MsgUpdateParams],
      ["/cosmos.gov.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.gov.v1.MsgVoteWeighted", tx_1.MsgVoteWeighted],
      ["/cosmos.gov.v1beta1.MsgDeposit", tx_2.MsgDeposit],
      ["/cosmos.gov.v1beta1.MsgSubmitProposal", tx_2.MsgSubmitProposal],
      ["/cosmos.gov.v1beta1.MsgVote", tx_2.MsgVote],
      ["/cosmos.gov.v1beta1.MsgVoteWeighted", tx_2.MsgVoteWeighted]
    ];
    function isMsgDepositEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
    }
    function isMsgSubmitProposalEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
    }
    function isMsgVoteEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
    }
    function isMsgVoteWeightedEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js
var require_query6 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryTallyResultResponse = exports$1.QueryTallyResultRequest = exports$1.QueryDepositsResponse = exports$1.QueryDepositsRequest = exports$1.QueryDepositResponse = exports$1.QueryDepositRequest = exports$1.QueryParamsResponse = exports$1.QueryParamsRequest = exports$1.QueryVotesResponse = exports$1.QueryVotesRequest = exports$1.QueryVoteResponse = exports$1.QueryVoteRequest = exports$1.QueryProposalsResponse = exports$1.QueryProposalsRequest = exports$1.QueryProposalResponse = exports$1.QueryProposalRequest = exports$1.protobufPackage = void 0;
    var gov_1 = require_gov();
    var pagination_1 = require_pagination();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseQueryProposalRequest4() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports$1.QueryProposalRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalRequest4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalRequest4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalRequest4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseQueryProposalResponse4() {
      return {
        proposal: gov_1.Proposal.fromPartial({})
      };
    }
    exports$1.QueryProposalResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposal !== void 0) {
          gov_1.Proposal.encode(message.proposal, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalResponse4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposal = gov_1.Proposal.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalResponse4();
        if ((0, helpers_1.isSet)(object.proposal))
          obj.proposal = gov_1.Proposal.fromJSON(object.proposal);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposal !== void 0 && (obj.proposal = message.proposal ? gov_1.Proposal.toJSON(message.proposal) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalResponse4();
        if (object.proposal !== void 0 && object.proposal !== null) {
          message.proposal = gov_1.Proposal.fromPartial(object.proposal);
        }
        return message;
      }
    };
    function createBaseQueryProposalsRequest3() {
      return {
        proposalStatus: 0,
        voter: "",
        depositor: "",
        pagination: void 0
      };
    }
    exports$1.QueryProposalsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalStatus !== 0) {
          writer.uint32(8).int32(message.proposalStatus);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.depositor !== "") {
          writer.uint32(26).string(message.depositor);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalStatus = reader.int32();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.depositor = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalsRequest3();
        if ((0, helpers_1.isSet)(object.proposalStatus))
          obj.proposalStatus = (0, gov_1.proposalStatusFromJSON)(object.proposalStatus);
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalStatus !== void 0 && (obj.proposalStatus = (0, gov_1.proposalStatusToJSON)(message.proposalStatus));
        message.voter !== void 0 && (obj.voter = message.voter);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalsRequest3();
        message.proposalStatus = object.proposalStatus ?? 0;
        message.voter = object.voter ?? "";
        message.depositor = object.depositor ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryProposalsResponse3() {
      return {
        proposals: [],
        pagination: void 0
      };
    }
    exports$1.QueryProposalsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.proposals) {
          gov_1.Proposal.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposals.push(gov_1.Proposal.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalsResponse3();
        if (Array.isArray(object?.proposals))
          obj.proposals = object.proposals.map((e) => gov_1.Proposal.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.proposals) {
          obj.proposals = message.proposals.map((e) => e ? gov_1.Proposal.toJSON(e) : void 0);
        } else {
          obj.proposals = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalsResponse3();
        message.proposals = object.proposals?.map((e) => gov_1.Proposal.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryVoteRequest3() {
      return {
        proposalId: BigInt(0),
        voter: ""
      };
    }
    exports$1.QueryVoteRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVoteRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVoteRequest3();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVoteRequest3();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        return message;
      }
    };
    function createBaseQueryVoteResponse3() {
      return {
        vote: gov_1.Vote.fromPartial({})
      };
    }
    exports$1.QueryVoteResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVoteResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.vote !== void 0) {
          gov_1.Vote.encode(message.vote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vote = gov_1.Vote.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVoteResponse3();
        if ((0, helpers_1.isSet)(object.vote))
          obj.vote = gov_1.Vote.fromJSON(object.vote);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.vote !== void 0 && (obj.vote = message.vote ? gov_1.Vote.toJSON(message.vote) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVoteResponse3();
        if (object.vote !== void 0 && object.vote !== null) {
          message.vote = gov_1.Vote.fromPartial(object.vote);
        }
        return message;
      }
    };
    function createBaseQueryVotesRequest3() {
      return {
        proposalId: BigInt(0),
        pagination: void 0
      };
    }
    exports$1.QueryVotesRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVotesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVotesRequest3();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVotesRequest3();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryVotesResponse3() {
      return {
        votes: [],
        pagination: void 0
      };
    }
    exports$1.QueryVotesResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVotesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.votes) {
          gov_1.Vote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votes.push(gov_1.Vote.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVotesResponse3();
        if (Array.isArray(object?.votes))
          obj.votes = object.votes.map((e) => gov_1.Vote.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? gov_1.Vote.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVotesResponse3();
        message.votes = object.votes?.map((e) => gov_1.Vote.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest18() {
      return {
        paramsType: ""
      };
    }
    exports$1.QueryParamsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryParamsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.paramsType !== "") {
          writer.uint32(10).string(message.paramsType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paramsType = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsRequest18();
        if ((0, helpers_1.isSet)(object.paramsType))
          obj.paramsType = String(object.paramsType);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.paramsType !== void 0 && (obj.paramsType = message.paramsType);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsRequest18();
        message.paramsType = object.paramsType ?? "";
        return message;
      }
    };
    function createBaseQueryParamsResponse18() {
      return {
        votingParams: gov_1.VotingParams.fromPartial({}),
        depositParams: gov_1.DepositParams.fromPartial({}),
        tallyParams: gov_1.TallyParams.fromPartial({})
      };
    }
    exports$1.QueryParamsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingParams !== void 0) {
          gov_1.VotingParams.encode(message.votingParams, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositParams !== void 0) {
          gov_1.DepositParams.encode(message.depositParams, writer.uint32(18).fork()).ldelim();
        }
        if (message.tallyParams !== void 0) {
          gov_1.TallyParams.encode(message.tallyParams, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingParams = gov_1.VotingParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.depositParams = gov_1.DepositParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.tallyParams = gov_1.TallyParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse18();
        if ((0, helpers_1.isSet)(object.votingParams))
          obj.votingParams = gov_1.VotingParams.fromJSON(object.votingParams);
        if ((0, helpers_1.isSet)(object.depositParams))
          obj.depositParams = gov_1.DepositParams.fromJSON(object.depositParams);
        if ((0, helpers_1.isSet)(object.tallyParams))
          obj.tallyParams = gov_1.TallyParams.fromJSON(object.tallyParams);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingParams !== void 0 && (obj.votingParams = message.votingParams ? gov_1.VotingParams.toJSON(message.votingParams) : void 0);
        message.depositParams !== void 0 && (obj.depositParams = message.depositParams ? gov_1.DepositParams.toJSON(message.depositParams) : void 0);
        message.tallyParams !== void 0 && (obj.tallyParams = message.tallyParams ? gov_1.TallyParams.toJSON(message.tallyParams) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse18();
        if (object.votingParams !== void 0 && object.votingParams !== null) {
          message.votingParams = gov_1.VotingParams.fromPartial(object.votingParams);
        }
        if (object.depositParams !== void 0 && object.depositParams !== null) {
          message.depositParams = gov_1.DepositParams.fromPartial(object.depositParams);
        }
        if (object.tallyParams !== void 0 && object.tallyParams !== null) {
          message.tallyParams = gov_1.TallyParams.fromPartial(object.tallyParams);
        }
        return message;
      }
    };
    function createBaseQueryDepositRequest3() {
      return {
        proposalId: BigInt(0),
        depositor: ""
      };
    }
    exports$1.QueryDepositRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositRequest3();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositRequest3();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        return message;
      }
    };
    function createBaseQueryDepositResponse3() {
      return {
        deposit: gov_1.Deposit.fromPartial({})
      };
    }
    exports$1.QueryDepositResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.deposit !== void 0) {
          gov_1.Deposit.encode(message.deposit, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposit = gov_1.Deposit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositResponse3();
        if ((0, helpers_1.isSet)(object.deposit))
          obj.deposit = gov_1.Deposit.fromJSON(object.deposit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.deposit !== void 0 && (obj.deposit = message.deposit ? gov_1.Deposit.toJSON(message.deposit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositResponse3();
        if (object.deposit !== void 0 && object.deposit !== null) {
          message.deposit = gov_1.Deposit.fromPartial(object.deposit);
        }
        return message;
      }
    };
    function createBaseQueryDepositsRequest3() {
      return {
        proposalId: BigInt(0),
        pagination: void 0
      };
    }
    exports$1.QueryDepositsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositsRequest3();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositsRequest3();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDepositsResponse3() {
      return {
        deposits: [],
        pagination: void 0
      };
    }
    exports$1.QueryDepositsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.deposits) {
          gov_1.Deposit.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposits.push(gov_1.Deposit.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositsResponse3();
        if (Array.isArray(object?.deposits))
          obj.deposits = object.deposits.map((e) => gov_1.Deposit.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.deposits) {
          obj.deposits = message.deposits.map((e) => e ? gov_1.Deposit.toJSON(e) : void 0);
        } else {
          obj.deposits = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositsResponse3();
        message.deposits = object.deposits?.map((e) => gov_1.Deposit.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryTallyResultRequest4() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports$1.QueryTallyResultRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultRequest4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTallyResultRequest4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultRequest4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseQueryTallyResultResponse4() {
      return {
        tally: gov_1.TallyResult.fromPartial({})
      };
    }
    exports$1.QueryTallyResultResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tally !== void 0) {
          gov_1.TallyResult.encode(message.tally, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultResponse4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tally = gov_1.TallyResult.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTallyResultResponse4();
        if ((0, helpers_1.isSet)(object.tally))
          obj.tally = gov_1.TallyResult.fromJSON(object.tally);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tally !== void 0 && (obj.tally = message.tally ? gov_1.TallyResult.toJSON(message.tally) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultResponse4();
        if (object.tally !== void 0 && object.tally !== null) {
          message.tally = gov_1.TallyResult.fromPartial(object.tally);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Proposal = this.Proposal.bind(this);
        this.Proposals = this.Proposals.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Votes = this.Votes.bind(this);
        this.Params = this.Params.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.Deposits = this.Deposits.bind(this);
        this.TallyResult = this.TallyResult.bind(this);
      }
      Proposal(request) {
        const data2 = exports$1.QueryProposalRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", data2);
        return promise.then((data3) => exports$1.QueryProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Proposals(request) {
        const data2 = exports$1.QueryProposalsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", data2);
        return promise.then((data3) => exports$1.QueryProposalsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports$1.QueryVoteRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", data2);
        return promise.then((data3) => exports$1.QueryVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Votes(request) {
        const data2 = exports$1.QueryVotesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", data2);
        return promise.then((data3) => exports$1.QueryVotesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request) {
        const data2 = exports$1.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports$1.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposit(request) {
        const data2 = exports$1.QueryDepositRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", data2);
        return promise.then((data3) => exports$1.QueryDepositResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposits(request) {
        const data2 = exports$1.QueryDepositsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", data2);
        return promise.then((data3) => exports$1.QueryDepositsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TallyResult(request) {
        const data2 = exports$1.QueryTallyResultRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", data2);
        return promise.then((data3) => exports$1.QueryTallyResultResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/gov/queries.js
var require_queries6 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/gov/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupGovExtension = setupGovExtension;
    var query_1 = require_query6();
    var queryclient_1 = require_queryclient2();
    function setupGovExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        gov: {
          params: async (parametersType) => {
            const response = await queryService.Params({ paramsType: parametersType });
            return response;
          },
          proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey) => {
            const response = await queryService.Proposals({
              proposalStatus,
              depositor: depositorAddress,
              voter: voterAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          proposal: async (proposalId) => {
            const response = await queryService.Proposal({ proposalId: (0, queryclient_1.longify)(proposalId) });
            return response;
          },
          deposits: async (proposalId, paginationKey) => {
            const response = await queryService.Deposits({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          deposit: async (proposalId, depositorAddress) => {
            const response = await queryService.Deposit({
              proposalId: (0, queryclient_1.longify)(proposalId),
              depositor: depositorAddress
            });
            return response;
          },
          tally: async (proposalId) => {
            const response = await queryService.TallyResult({
              proposalId: (0, queryclient_1.longify)(proposalId)
            });
            return response;
          },
          votes: async (proposalId, paginationKey) => {
            const response = await queryService.Votes({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          vote: async (proposalId, voterAddress) => {
            const response = await queryService.Vote({
              proposalId: (0, queryclient_1.longify)(proposalId),
              voter: voterAddress
            });
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js
var require_aminomessages8 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.createGroupAminoConverters = createGroupAminoConverters;
    function createGroupAminoConverters() {
      return {};
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/group/v1/types.js
var require_types = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/group/v1/types.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Vote = exports$1.TallyResult = exports$1.Proposal = exports$1.GroupPolicyInfo = exports$1.GroupMember = exports$1.GroupInfo = exports$1.DecisionPolicyWindows = exports$1.PercentageDecisionPolicy = exports$1.ThresholdDecisionPolicy = exports$1.MemberRequest = exports$1.Member = exports$1.proposalExecutorResultToJSON = exports$1.proposalExecutorResultFromJSON = exports$1.ProposalExecutorResult = exports$1.proposalStatusToJSON = exports$1.proposalStatusFromJSON = exports$1.ProposalStatus = exports$1.voteOptionToJSON = exports$1.voteOptionFromJSON = exports$1.VoteOption = exports$1.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.group.v1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports$1.VoteOption = VoteOption = {}));
    function voteOptionFromJSON4(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports$1.voteOptionFromJSON = voteOptionFromJSON4;
    function voteOptionToJSON4(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.voteOptionToJSON = voteOptionToJSON4;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_SUBMITTED"] = 1] = "PROPOSAL_STATUS_SUBMITTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_ACCEPTED"] = 2] = "PROPOSAL_STATUS_ACCEPTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 3] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_ABORTED"] = 4] = "PROPOSAL_STATUS_ABORTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_WITHDRAWN"] = 5] = "PROPOSAL_STATUS_WITHDRAWN";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports$1.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON4(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_SUBMITTED":
          return ProposalStatus.PROPOSAL_STATUS_SUBMITTED;
        case 2:
        case "PROPOSAL_STATUS_ACCEPTED":
          return ProposalStatus.PROPOSAL_STATUS_ACCEPTED;
        case 3:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 4:
        case "PROPOSAL_STATUS_ABORTED":
          return ProposalStatus.PROPOSAL_STATUS_ABORTED;
        case 5:
        case "PROPOSAL_STATUS_WITHDRAWN":
          return ProposalStatus.PROPOSAL_STATUS_WITHDRAWN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports$1.proposalStatusFromJSON = proposalStatusFromJSON4;
    function proposalStatusToJSON4(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_SUBMITTED:
          return "PROPOSAL_STATUS_SUBMITTED";
        case ProposalStatus.PROPOSAL_STATUS_ACCEPTED:
          return "PROPOSAL_STATUS_ACCEPTED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_ABORTED:
          return "PROPOSAL_STATUS_ABORTED";
        case ProposalStatus.PROPOSAL_STATUS_WITHDRAWN:
          return "PROPOSAL_STATUS_WITHDRAWN";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.proposalStatusToJSON = proposalStatusToJSON4;
    var ProposalExecutorResult;
    (function(ProposalExecutorResult2) {
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"] = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_NOT_RUN"] = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_SUCCESS"] = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_FAILURE"] = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE";
      ProposalExecutorResult2[ProposalExecutorResult2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalExecutorResult || (exports$1.ProposalExecutorResult = ProposalExecutorResult = {}));
    function proposalExecutorResultFromJSON2(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
        case 1:
        case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
        case 2:
        case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
        case 3:
        case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalExecutorResult.UNRECOGNIZED;
      }
    }
    exports$1.proposalExecutorResultFromJSON = proposalExecutorResultFromJSON2;
    function proposalExecutorResultToJSON2(object) {
      switch (object) {
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
          return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
          return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
          return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE:
          return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
        case ProposalExecutorResult.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.proposalExecutorResultToJSON = proposalExecutorResultToJSON2;
    function createBaseMember2() {
      return {
        address: "",
        weight: "",
        metadata: "",
        addedAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.Member = {
      typeUrl: "/cosmos.group.v1.Member",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.addedAt !== void 0) {
          timestamp_1.Timestamp.encode(message.addedAt, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMember2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.addedAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMember2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.addedAt))
          obj.addedAt = (0, helpers_1.fromJsonTimestamp)(object.addedAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.weight !== void 0 && (obj.weight = message.weight);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.addedAt !== void 0 && (obj.addedAt = (0, helpers_1.fromTimestamp)(message.addedAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMember2();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        if (object.addedAt !== void 0 && object.addedAt !== null) {
          message.addedAt = timestamp_1.Timestamp.fromPartial(object.addedAt);
        }
        return message;
      }
    };
    function createBaseMemberRequest2() {
      return {
        address: "",
        weight: "",
        metadata: ""
      };
    }
    exports$1.MemberRequest = {
      typeUrl: "/cosmos.group.v1.MemberRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMemberRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMemberRequest2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.weight !== void 0 && (obj.weight = message.weight);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMemberRequest2();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseThresholdDecisionPolicy() {
      return {
        threshold: "",
        windows: void 0
      };
    }
    exports$1.ThresholdDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.ThresholdDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== "") {
          writer.uint32(10).string(message.threshold);
        }
        if (message.windows !== void 0) {
          exports$1.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseThresholdDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.threshold = reader.string();
              break;
            case 2:
              message.windows = exports$1.DecisionPolicyWindows.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseThresholdDecisionPolicy();
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.windows))
          obj.windows = exports$1.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.windows !== void 0 && (obj.windows = message.windows ? exports$1.DecisionPolicyWindows.toJSON(message.windows) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseThresholdDecisionPolicy();
        message.threshold = object.threshold ?? "";
        if (object.windows !== void 0 && object.windows !== null) {
          message.windows = exports$1.DecisionPolicyWindows.fromPartial(object.windows);
        }
        return message;
      }
    };
    function createBasePercentageDecisionPolicy() {
      return {
        percentage: "",
        windows: void 0
      };
    }
    exports$1.PercentageDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.PercentageDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.percentage !== "") {
          writer.uint32(10).string(message.percentage);
        }
        if (message.windows !== void 0) {
          exports$1.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePercentageDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.percentage = reader.string();
              break;
            case 2:
              message.windows = exports$1.DecisionPolicyWindows.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePercentageDecisionPolicy();
        if ((0, helpers_1.isSet)(object.percentage))
          obj.percentage = String(object.percentage);
        if ((0, helpers_1.isSet)(object.windows))
          obj.windows = exports$1.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.percentage !== void 0 && (obj.percentage = message.percentage);
        message.windows !== void 0 && (obj.windows = message.windows ? exports$1.DecisionPolicyWindows.toJSON(message.windows) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePercentageDecisionPolicy();
        message.percentage = object.percentage ?? "";
        if (object.windows !== void 0 && object.windows !== null) {
          message.windows = exports$1.DecisionPolicyWindows.fromPartial(object.windows);
        }
        return message;
      }
    };
    function createBaseDecisionPolicyWindows() {
      return {
        votingPeriod: duration_1.Duration.fromPartial({}),
        minExecutionPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports$1.DecisionPolicyWindows = {
      typeUrl: "/cosmos.group.v1.DecisionPolicyWindows",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        if (message.minExecutionPeriod !== void 0) {
          duration_1.Duration.encode(message.minExecutionPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecisionPolicyWindows();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.minExecutionPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecisionPolicyWindows();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.minExecutionPeriod))
          obj.minExecutionPeriod = duration_1.Duration.fromJSON(object.minExecutionPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        message.minExecutionPeriod !== void 0 && (obj.minExecutionPeriod = message.minExecutionPeriod ? duration_1.Duration.toJSON(message.minExecutionPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecisionPolicyWindows();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        if (object.minExecutionPeriod !== void 0 && object.minExecutionPeriod !== null) {
          message.minExecutionPeriod = duration_1.Duration.fromPartial(object.minExecutionPeriod);
        }
        return message;
      }
    };
    function createBaseGroupInfo2() {
      return {
        id: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        totalWeight: "",
        createdAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.GroupInfo = {
      typeUrl: "/cosmos.group.v1.GroupInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(32).uint64(message.version);
        }
        if (message.totalWeight !== "") {
          writer.uint32(42).string(message.totalWeight);
        }
        if (message.createdAt !== void 0) {
          timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.version = reader.uint64();
              break;
            case 5:
              message.totalWeight = reader.string();
              break;
            case 6:
              message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupInfo2();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.totalWeight))
          obj.totalWeight = String(object.totalWeight);
        if ((0, helpers_1.isSet)(object.createdAt))
          obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.admin !== void 0 && (obj.admin = message.admin);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        message.totalWeight !== void 0 && (obj.totalWeight = message.totalWeight);
        message.createdAt !== void 0 && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupInfo2();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        message.totalWeight = object.totalWeight ?? "";
        if (object.createdAt !== void 0 && object.createdAt !== null) {
          message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        }
        return message;
      }
    };
    function createBaseGroupMember2() {
      return {
        groupId: BigInt(0),
        member: void 0
      };
    }
    exports$1.GroupMember = {
      typeUrl: "/cosmos.group.v1.GroupMember",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        if (message.member !== void 0) {
          exports$1.Member.encode(message.member, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupMember2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            case 2:
              message.member = exports$1.Member.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupMember2();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.member))
          obj.member = exports$1.Member.fromJSON(object.member);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.member !== void 0 && (obj.member = message.member ? exports$1.Member.toJSON(message.member) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupMember2();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        if (object.member !== void 0 && object.member !== null) {
          message.member = exports$1.Member.fromPartial(object.member);
        }
        return message;
      }
    };
    function createBaseGroupPolicyInfo2() {
      return {
        address: "",
        groupId: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        decisionPolicy: void 0,
        createdAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.GroupPolicyInfo = {
      typeUrl: "/cosmos.group.v1.GroupPolicyInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.admin !== "") {
          writer.uint32(26).string(message.admin);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(40).uint64(message.version);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        }
        if (message.createdAt !== void 0) {
          timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupPolicyInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.admin = reader.string();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.version = reader.uint64();
              break;
            case 6:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupPolicyInfo2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        if ((0, helpers_1.isSet)(object.createdAt))
          obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.admin !== void 0 && (obj.admin = message.admin);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        message.createdAt !== void 0 && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupPolicyInfo2();
        message.address = object.address ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        if (object.createdAt !== void 0 && object.createdAt !== null) {
          message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        }
        return message;
      }
    };
    function createBaseProposal4() {
      return {
        id: BigInt(0),
        groupPolicyAddress: "",
        metadata: "",
        proposers: [],
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        groupVersion: BigInt(0),
        groupPolicyVersion: BigInt(0),
        status: 0,
        finalTallyResult: exports$1.TallyResult.fromPartial({}),
        votingPeriodEnd: timestamp_1.Timestamp.fromPartial({}),
        executorResult: 0,
        messages: [],
        title: "",
        summary: ""
      };
    }
    exports$1.Proposal = {
      typeUrl: "/cosmos.group.v1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        for (const v of message.proposers) {
          writer.uint32(34).string(v);
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.groupVersion !== BigInt(0)) {
          writer.uint32(48).uint64(message.groupVersion);
        }
        if (message.groupPolicyVersion !== BigInt(0)) {
          writer.uint32(56).uint64(message.groupPolicyVersion);
        }
        if (message.status !== 0) {
          writer.uint32(64).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports$1.TallyResult.encode(message.finalTallyResult, writer.uint32(74).fork()).ldelim();
        }
        if (message.votingPeriodEnd !== void 0) {
          timestamp_1.Timestamp.encode(message.votingPeriodEnd, writer.uint32(82).fork()).ldelim();
        }
        if (message.executorResult !== 0) {
          writer.uint32(88).int32(message.executorResult);
        }
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(98).fork()).ldelim();
        }
        if (message.title !== "") {
          writer.uint32(106).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(114).string(message.summary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.proposers.push(reader.string());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.groupVersion = reader.uint64();
              break;
            case 7:
              message.groupPolicyVersion = reader.uint64();
              break;
            case 8:
              message.status = reader.int32();
              break;
            case 9:
              message.finalTallyResult = exports$1.TallyResult.decode(reader, reader.uint32());
              break;
            case 10:
              message.votingPeriodEnd = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.executorResult = reader.int32();
              break;
            case 12:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 13:
              message.title = reader.string();
              break;
            case 14:
              message.summary = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal4();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if (Array.isArray(object?.proposers))
          obj.proposers = object.proposers.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.groupVersion))
          obj.groupVersion = BigInt(object.groupVersion.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyVersion))
          obj.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON4(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports$1.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.votingPeriodEnd))
          obj.votingPeriodEnd = (0, helpers_1.fromJsonTimestamp)(object.votingPeriodEnd);
        if ((0, helpers_1.isSet)(object.executorResult))
          obj.executorResult = proposalExecutorResultFromJSON2(object.executorResult);
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        if (message.proposers) {
          obj.proposers = message.proposers.map((e) => e);
        } else {
          obj.proposers = [];
        }
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.groupVersion !== void 0 && (obj.groupVersion = (message.groupVersion || BigInt(0)).toString());
        message.groupPolicyVersion !== void 0 && (obj.groupPolicyVersion = (message.groupPolicyVersion || BigInt(0)).toString());
        message.status !== void 0 && (obj.status = proposalStatusToJSON4(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports$1.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.votingPeriodEnd !== void 0 && (obj.votingPeriodEnd = (0, helpers_1.fromTimestamp)(message.votingPeriodEnd).toISOString());
        message.executorResult !== void 0 && (obj.executorResult = proposalExecutorResultToJSON2(message.executorResult));
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal4();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        message.proposers = object.proposers?.map((e) => e) || [];
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.groupVersion !== void 0 && object.groupVersion !== null) {
          message.groupVersion = BigInt(object.groupVersion.toString());
        }
        if (object.groupPolicyVersion !== void 0 && object.groupPolicyVersion !== null) {
          message.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        }
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports$1.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.votingPeriodEnd !== void 0 && object.votingPeriodEnd !== null) {
          message.votingPeriodEnd = timestamp_1.Timestamp.fromPartial(object.votingPeriodEnd);
        }
        message.executorResult = object.executorResult ?? 0;
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
      }
    };
    function createBaseTallyResult4() {
      return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
      };
    }
    exports$1.TallyResult = {
      typeUrl: "/cosmos.group.v1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") {
          writer.uint32(10).string(message.yesCount);
        }
        if (message.abstainCount !== "") {
          writer.uint32(18).string(message.abstainCount);
        }
        if (message.noCount !== "") {
          writer.uint32(26).string(message.noCount);
        }
        if (message.noWithVetoCount !== "") {
          writer.uint32(34).string(message.noWithVetoCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yesCount = reader.string();
              break;
            case 2:
              message.abstainCount = reader.string();
              break;
            case 3:
              message.noCount = reader.string();
              break;
            case 4:
              message.noWithVetoCount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult4();
        if ((0, helpers_1.isSet)(object.yesCount))
          obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount))
          obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount))
          obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount))
          obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yesCount !== void 0 && (obj.yesCount = message.yesCount);
        message.abstainCount !== void 0 && (obj.abstainCount = message.abstainCount);
        message.noCount !== void 0 && (obj.noCount = message.noCount);
        message.noWithVetoCount !== void 0 && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult4();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
      }
    };
    function createBaseVote5() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        submitTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.Vote = {
      typeUrl: "/cosmos.group.v1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote5();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote5();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON4(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON4(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote5();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/group/v1/tx.js
var require_tx8 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/group/v1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgLeaveGroupResponse = exports$1.MsgLeaveGroup = exports$1.MsgExecResponse = exports$1.MsgExec = exports$1.MsgVoteResponse = exports$1.MsgVote = exports$1.MsgWithdrawProposalResponse = exports$1.MsgWithdrawProposal = exports$1.MsgSubmitProposalResponse = exports$1.MsgSubmitProposal = exports$1.MsgUpdateGroupPolicyMetadataResponse = exports$1.MsgUpdateGroupPolicyMetadata = exports$1.MsgUpdateGroupPolicyDecisionPolicyResponse = exports$1.MsgUpdateGroupPolicyDecisionPolicy = exports$1.MsgCreateGroupWithPolicyResponse = exports$1.MsgCreateGroupWithPolicy = exports$1.MsgUpdateGroupPolicyAdminResponse = exports$1.MsgUpdateGroupPolicyAdmin = exports$1.MsgCreateGroupPolicyResponse = exports$1.MsgCreateGroupPolicy = exports$1.MsgUpdateGroupMetadataResponse = exports$1.MsgUpdateGroupMetadata = exports$1.MsgUpdateGroupAdminResponse = exports$1.MsgUpdateGroupAdmin = exports$1.MsgUpdateGroupMembersResponse = exports$1.MsgUpdateGroupMembers = exports$1.MsgCreateGroupResponse = exports$1.MsgCreateGroup = exports$1.execToJSON = exports$1.execFromJSON = exports$1.Exec = exports$1.protobufPackage = void 0;
    var types_1 = require_types();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.group.v1";
    var Exec;
    (function(Exec2) {
      Exec2[Exec2["EXEC_UNSPECIFIED"] = 0] = "EXEC_UNSPECIFIED";
      Exec2[Exec2["EXEC_TRY"] = 1] = "EXEC_TRY";
      Exec2[Exec2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Exec || (exports$1.Exec = Exec = {}));
    function execFromJSON2(object) {
      switch (object) {
        case 0:
        case "EXEC_UNSPECIFIED":
          return Exec.EXEC_UNSPECIFIED;
        case 1:
        case "EXEC_TRY":
          return Exec.EXEC_TRY;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Exec.UNRECOGNIZED;
      }
    }
    exports$1.execFromJSON = execFromJSON2;
    function execToJSON2(object) {
      switch (object) {
        case Exec.EXEC_UNSPECIFIED:
          return "EXEC_UNSPECIFIED";
        case Exec.EXEC_TRY:
          return "EXEC_TRY";
        case Exec.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.execToJSON = execToJSON2;
    function createBaseMsgCreateGroup2() {
      return {
        admin: "",
        members: [],
        metadata: ""
      };
    }
    exports$1.MsgCreateGroup = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroup",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        for (const v of message.members) {
          types_1.MemberRequest.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroup2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroup2();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if (Array.isArray(object?.members))
          obj.members = object.members.map((e) => types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        if (message.members) {
          obj.members = message.members.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.members = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroup2();
        message.admin = object.admin ?? "";
        message.members = object.members?.map((e) => types_1.MemberRequest.fromPartial(e)) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgCreateGroupResponse2() {
      return {
        groupId: BigInt(0)
      };
    }
    exports$1.MsgCreateGroupResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupResponse2();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupResponse2();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        return message;
      }
    };
    function createBaseMsgUpdateGroupMembers2() {
      return {
        admin: "",
        groupId: BigInt(0),
        memberUpdates: []
      };
    }
    exports$1.MsgUpdateGroupMembers = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        for (const v of message.memberUpdates) {
          types_1.MemberRequest.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembers2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.memberUpdates.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupMembers2();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if (Array.isArray(object?.memberUpdates))
          obj.memberUpdates = object.memberUpdates.map((e) => types_1.MemberRequest.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        if (message.memberUpdates) {
          obj.memberUpdates = message.memberUpdates.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.memberUpdates = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupMembers2();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.memberUpdates = object.memberUpdates?.map((e) => types_1.MemberRequest.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgUpdateGroupMembersResponse2() {
      return {};
    }
    exports$1.MsgUpdateGroupMembersResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembersResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembersResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupMembersResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupMembersResponse2();
        return message;
      }
    };
    function createBaseMsgUpdateGroupAdmin2() {
      return {
        admin: "",
        groupId: BigInt(0),
        newAdmin: ""
      };
    }
    exports$1.MsgUpdateGroupAdmin = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.newAdmin !== "") {
          writer.uint32(26).string(message.newAdmin);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdmin2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.newAdmin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupAdmin2();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.newAdmin))
          obj.newAdmin = String(object.newAdmin);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupAdmin2();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.newAdmin = object.newAdmin ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupAdminResponse2() {
      return {};
    }
    exports$1.MsgUpdateGroupAdminResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdminResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdminResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupAdminResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupAdminResponse2();
        return message;
      }
    };
    function createBaseMsgUpdateGroupMetadata2() {
      return {
        admin: "",
        groupId: BigInt(0),
        metadata: ""
      };
    }
    exports$1.MsgUpdateGroupMetadata = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadata2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupMetadata2();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupMetadata2();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupMetadataResponse2() {
      return {};
    }
    exports$1.MsgUpdateGroupMetadataResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadataResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadataResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupMetadataResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupMetadataResponse2();
        return message;
      }
    };
    function createBaseMsgCreateGroupPolicy2() {
      return {
        admin: "",
        groupId: BigInt(0),
        metadata: "",
        decisionPolicy: void 0
      };
    }
    exports$1.MsgCreateGroupPolicy = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicy2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupPolicy2();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupPolicy2();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.metadata = object.metadata ?? "";
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgCreateGroupPolicyResponse2() {
      return {
        address: ""
      };
    }
    exports$1.MsgCreateGroupPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicyResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupPolicyResponse2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupPolicyResponse2();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyAdmin2() {
      return {
        admin: "",
        groupPolicyAddress: "",
        newAdmin: ""
      };
    }
    exports$1.MsgUpdateGroupPolicyAdmin = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.newAdmin !== "") {
          writer.uint32(26).string(message.newAdmin);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdmin2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.newAdmin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyAdmin2();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.newAdmin))
          obj.newAdmin = String(object.newAdmin);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyAdmin2();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.newAdmin = object.newAdmin ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyAdminResponse2() {
      return {};
    }
    exports$1.MsgUpdateGroupPolicyAdminResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdminResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupPolicyAdminResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupPolicyAdminResponse2();
        return message;
      }
    };
    function createBaseMsgCreateGroupWithPolicy2() {
      return {
        admin: "",
        members: [],
        groupMetadata: "",
        groupPolicyMetadata: "",
        groupPolicyAsAdmin: false,
        decisionPolicy: void 0
      };
    }
    exports$1.MsgCreateGroupWithPolicy = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        for (const v of message.members) {
          types_1.MemberRequest.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.groupMetadata !== "") {
          writer.uint32(26).string(message.groupMetadata);
        }
        if (message.groupPolicyMetadata !== "") {
          writer.uint32(34).string(message.groupPolicyMetadata);
        }
        if (message.groupPolicyAsAdmin === true) {
          writer.uint32(40).bool(message.groupPolicyAsAdmin);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicy2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            case 3:
              message.groupMetadata = reader.string();
              break;
            case 4:
              message.groupPolicyMetadata = reader.string();
              break;
            case 5:
              message.groupPolicyAsAdmin = reader.bool();
              break;
            case 6:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupWithPolicy2();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if (Array.isArray(object?.members))
          obj.members = object.members.map((e) => types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.groupMetadata))
          obj.groupMetadata = String(object.groupMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyMetadata))
          obj.groupPolicyMetadata = String(object.groupPolicyMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyAsAdmin))
          obj.groupPolicyAsAdmin = Boolean(object.groupPolicyAsAdmin);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        if (message.members) {
          obj.members = message.members.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.members = [];
        }
        message.groupMetadata !== void 0 && (obj.groupMetadata = message.groupMetadata);
        message.groupPolicyMetadata !== void 0 && (obj.groupPolicyMetadata = message.groupPolicyMetadata);
        message.groupPolicyAsAdmin !== void 0 && (obj.groupPolicyAsAdmin = message.groupPolicyAsAdmin);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupWithPolicy2();
        message.admin = object.admin ?? "";
        message.members = object.members?.map((e) => types_1.MemberRequest.fromPartial(e)) || [];
        message.groupMetadata = object.groupMetadata ?? "";
        message.groupPolicyMetadata = object.groupPolicyMetadata ?? "";
        message.groupPolicyAsAdmin = object.groupPolicyAsAdmin ?? false;
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgCreateGroupWithPolicyResponse2() {
      return {
        groupId: BigInt(0),
        groupPolicyAddress: ""
      };
    }
    exports$1.MsgCreateGroupWithPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicyResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupWithPolicyResponse2();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupWithPolicyResponse2();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyDecisionPolicy2() {
      return {
        admin: "",
        groupPolicyAddress: "",
        decisionPolicy: void 0
      };
    }
    exports$1.MsgUpdateGroupPolicyDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicy2();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy2();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyDecisionPolicyResponse2() {
      return {};
    }
    exports$1.MsgUpdateGroupPolicyDecisionPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse2();
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyMetadata2() {
      return {
        admin: "",
        groupPolicyAddress: "",
        metadata: ""
      };
    }
    exports$1.MsgUpdateGroupPolicyMetadata = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadata2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyMetadata2();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyMetadata2();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyMetadataResponse2() {
      return {};
    }
    exports$1.MsgUpdateGroupPolicyMetadataResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupPolicyMetadataResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse2();
        return message;
      }
    };
    function createBaseMsgSubmitProposal4() {
      return {
        groupPolicyAddress: "",
        proposers: [],
        metadata: "",
        messages: [],
        exec: 0,
        title: "",
        summary: ""
      };
    }
    exports$1.MsgSubmitProposal = {
      typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupPolicyAddress !== "") {
          writer.uint32(10).string(message.groupPolicyAddress);
        }
        for (const v of message.proposers) {
          writer.uint32(18).string(v);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.exec !== 0) {
          writer.uint32(40).int32(message.exec);
        }
        if (message.title !== "") {
          writer.uint32(50).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(58).string(message.summary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupPolicyAddress = reader.string();
              break;
            case 2:
              message.proposers.push(reader.string());
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 5:
              message.exec = reader.int32();
              break;
            case 6:
              message.title = reader.string();
              break;
            case 7:
              message.summary = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal4();
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if (Array.isArray(object?.proposers))
          obj.proposers = object.proposers.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.exec))
          obj.exec = execFromJSON2(object.exec);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        if (message.proposers) {
          obj.proposers = message.proposers.map((e) => e);
        } else {
          obj.proposers = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.exec !== void 0 && (obj.exec = execToJSON2(message.exec));
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposal4();
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.proposers = object.proposers?.map((e) => e) || [];
        message.metadata = object.metadata ?? "";
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.exec = object.exec ?? 0;
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse4() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports$1.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.group.v1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgWithdrawProposal2() {
      return {
        proposalId: BigInt(0),
        address: ""
      };
    }
    exports$1.MsgWithdrawProposal = {
      typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.address !== "") {
          writer.uint32(18).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposal2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawProposal2();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawProposal2();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawProposalResponse2() {
      return {};
    }
    exports$1.MsgWithdrawProposalResponse = {
      typeUrl: "/cosmos.group.v1.MsgWithdrawProposalResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposalResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgWithdrawProposalResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgWithdrawProposalResponse2();
        return message;
      }
    };
    function createBaseMsgVote4() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        exec: 0
      };
    }
    exports$1.MsgVote = {
      typeUrl: "/cosmos.group.v1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.exec !== 0) {
          writer.uint32(40).int32(message.exec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.exec = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote4();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, types_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.exec))
          obj.exec = execFromJSON2(object.exec);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, types_1.voteOptionToJSON)(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.exec !== void 0 && (obj.exec = execToJSON2(message.exec));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote4();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        message.exec = object.exec ?? 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse4() {
      return {};
    }
    exports$1.MsgVoteResponse = {
      typeUrl: "/cosmos.group.v1.MsgVoteResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteResponse4();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse4();
        return message;
      }
    };
    function createBaseMsgExec3() {
      return {
        proposalId: BigInt(0),
        executor: ""
      };
    }
    exports$1.MsgExec = {
      typeUrl: "/cosmos.group.v1.MsgExec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.executor !== "") {
          writer.uint32(18).string(message.executor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.executor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExec3();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.executor))
          obj.executor = String(object.executor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.executor !== void 0 && (obj.executor = message.executor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExec3();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.executor = object.executor ?? "";
        return message;
      }
    };
    function createBaseMsgExecResponse3() {
      return {
        result: 0
      };
    }
    exports$1.MsgExecResponse = {
      typeUrl: "/cosmos.group.v1.MsgExecResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(16).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecResponse3();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = (0, types_1.proposalExecutorResultFromJSON)(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = (0, types_1.proposalExecutorResultToJSON)(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecResponse3();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgLeaveGroup2() {
      return {
        address: "",
        groupId: BigInt(0)
      };
    }
    exports$1.MsgLeaveGroup = {
      typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroup2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgLeaveGroup2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgLeaveGroup2();
        message.address = object.address ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        return message;
      }
    };
    function createBaseMsgLeaveGroupResponse2() {
      return {};
    }
    exports$1.MsgLeaveGroupResponse = {
      typeUrl: "/cosmos.group.v1.MsgLeaveGroupResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroupResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgLeaveGroupResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgLeaveGroupResponse2();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateGroup = this.CreateGroup.bind(this);
        this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this);
        this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this);
        this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this);
        this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this);
        this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this);
        this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this);
        this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this);
        this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this);
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.WithdrawProposal = this.WithdrawProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Exec = this.Exec.bind(this);
        this.LeaveGroup = this.LeaveGroup.bind(this);
      }
      CreateGroup(request) {
        const data2 = exports$1.MsgCreateGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", data2);
        return promise.then((data3) => exports$1.MsgCreateGroupResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupMembers(request) {
        const data2 = exports$1.MsgUpdateGroupMembers.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", data2);
        return promise.then((data3) => exports$1.MsgUpdateGroupMembersResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupAdmin(request) {
        const data2 = exports$1.MsgUpdateGroupAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", data2);
        return promise.then((data3) => exports$1.MsgUpdateGroupAdminResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupMetadata(request) {
        const data2 = exports$1.MsgUpdateGroupMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", data2);
        return promise.then((data3) => exports$1.MsgUpdateGroupMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreateGroupPolicy(request) {
        const data2 = exports$1.MsgCreateGroupPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", data2);
        return promise.then((data3) => exports$1.MsgCreateGroupPolicyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreateGroupWithPolicy(request) {
        const data2 = exports$1.MsgCreateGroupWithPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", data2);
        return promise.then((data3) => exports$1.MsgCreateGroupWithPolicyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupPolicyAdmin(request) {
        const data2 = exports$1.MsgUpdateGroupPolicyAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", data2);
        return promise.then((data3) => exports$1.MsgUpdateGroupPolicyAdminResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupPolicyDecisionPolicy(request) {
        const data2 = exports$1.MsgUpdateGroupPolicyDecisionPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", data2);
        return promise.then((data3) => exports$1.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupPolicyMetadata(request) {
        const data2 = exports$1.MsgUpdateGroupPolicyMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", data2);
        return promise.then((data3) => exports$1.MsgUpdateGroupPolicyMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SubmitProposal(request) {
        const data2 = exports$1.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", data2);
        return promise.then((data3) => exports$1.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WithdrawProposal(request) {
        const data2 = exports$1.MsgWithdrawProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", data2);
        return promise.then((data3) => exports$1.MsgWithdrawProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports$1.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Vote", data2);
        return promise.then((data3) => exports$1.MsgVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Exec(request) {
        const data2 = exports$1.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Exec", data2);
        return promise.then((data3) => exports$1.MsgExecResponse.decode(new binary_1.BinaryReader(data3)));
      }
      LeaveGroup(request) {
        const data2 = exports$1.MsgLeaveGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", data2);
        return promise.then((data3) => exports$1.MsgLeaveGroupResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/group/messages.js
var require_messages6 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/group/messages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.groupTypes = void 0;
    var tx_1 = require_tx8();
    exports$1.groupTypes = [
      ["/cosmos.group.v1.MsgCreateGroup", tx_1.MsgCreateGroup],
      ["/cosmos.group.v1.MsgCreateGroupPolicy", tx_1.MsgCreateGroupPolicy],
      ["/cosmos.group.v1.MsgCreateGroupWithPolicy", tx_1.MsgCreateGroupWithPolicy],
      ["/cosmos.group.v1.MsgExec", tx_1.MsgExec],
      ["/cosmos.group.v1.MsgLeaveGroup", tx_1.MsgLeaveGroup],
      ["/cosmos.group.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.group.v1.MsgUpdateGroupAdmin", tx_1.MsgUpdateGroupAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupMembers", tx_1.MsgUpdateGroupMembers],
      ["/cosmos.group.v1.MsgUpdateGroupMetadata", tx_1.MsgUpdateGroupMetadata],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", tx_1.MsgUpdateGroupPolicyAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", tx_1.MsgUpdateGroupPolicyDecisionPolicy],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", tx_1.MsgUpdateGroupPolicyMetadata],
      ["/cosmos.group.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.group.v1.MsgWithdrawProposal", tx_1.MsgWithdrawProposal]
    ];
  }
});

// ../../node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js
var require_upgrade = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ModuleVersion = exports$1.CancelSoftwareUpgradeProposal = exports$1.SoftwareUpgradeProposal = exports$1.Plan = exports$1.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.upgrade.v1beta1";
    function createBasePlan2() {
      return {
        name: "",
        time: timestamp_1.Timestamp.fromPartial({}),
        height: BigInt(0),
        info: "",
        upgradedClientState: void 0
      };
    }
    exports$1.Plan = {
      typeUrl: "/cosmos.upgrade.v1beta1.Plan",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePlan2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePlan2();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.info !== void 0 && (obj.info = message.info);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePlan2();
        message.name = object.name ?? "";
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.info = object.info ?? "";
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
    function createBaseSoftwareUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: exports$1.Plan.fromPartial({})
      };
    }
    exports$1.SoftwareUpgradeProposal = {
      typeUrl: "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          exports$1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = exports$1.Plan.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = exports$1.Plan.fromJSON(object.plan);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? exports$1.Plan.toJSON(message.plan) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = exports$1.Plan.fromPartial(object.plan);
        }
        return message;
      }
    };
    function createBaseCancelSoftwareUpgradeProposal() {
      return {
        title: "",
        description: ""
      };
    }
    exports$1.CancelSoftwareUpgradeProposal = {
      typeUrl: "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCancelSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCancelSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
      }
    };
    function createBaseModuleVersion2() {
      return {
        name: "",
        version: BigInt(0)
      };
    }
    exports$1.ModuleVersion = {
      typeUrl: "/cosmos.upgrade.v1beta1.ModuleVersion",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(16).uint64(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleVersion2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.version = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleVersion2();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModuleVersion2();
        message.name = object.name ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/ibc/core/client/v1/client.js
var require_client = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/client/v1/client.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.UpgradeProposal = exports$1.ClientUpdateProposal = exports$1.Params = exports$1.Height = exports$1.ClientConsensusStates = exports$1.ConsensusStateWithHeight = exports$1.IdentifiedClientState = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var upgrade_1 = require_upgrade();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.client.v1";
    function createBaseIdentifiedClientState() {
      return {
        clientId: "",
        clientState: void 0
      };
    }
    exports$1.IdentifiedClientState = {
      typeUrl: "/ibc.core.client.v1.IdentifiedClientState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedClientState();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIdentifiedClientState();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        return message;
      }
    };
    function createBaseConsensusStateWithHeight() {
      return {
        height: exports$1.Height.fromPartial({}),
        consensusState: void 0
      };
    }
    exports$1.ConsensusStateWithHeight = {
      typeUrl: "/ibc.core.client.v1.ConsensusStateWithHeight",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== void 0) {
          exports$1.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusStateWithHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = exports$1.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusStateWithHeight();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = exports$1.Height.fromJSON(object.height);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? exports$1.Height.toJSON(message.height) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusStateWithHeight();
        if (object.height !== void 0 && object.height !== null) {
          message.height = exports$1.Height.fromPartial(object.height);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        return message;
      }
    };
    function createBaseClientConsensusStates() {
      return {
        clientId: "",
        consensusStates: []
      };
    }
    exports$1.ClientConsensusStates = {
      typeUrl: "/ibc.core.client.v1.ClientConsensusStates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.consensusStates) {
          exports$1.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientConsensusStates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.consensusStates.push(exports$1.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientConsensusStates();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object?.consensusStates))
          obj.consensusStates = object.consensusStates.map((e) => exports$1.ConsensusStateWithHeight.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? exports$1.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientConsensusStates();
        message.clientId = object.clientId ?? "";
        message.consensusStates = object.consensusStates?.map((e) => exports$1.ConsensusStateWithHeight.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseHeight() {
      return {
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports$1.Height = {
      typeUrl: "/ibc.core.client.v1.Height",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(8).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.revisionNumber = reader.uint64();
              break;
            case 2:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeight();
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeight();
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseParams15() {
      return {
        allowedClients: []
      };
    }
    exports$1.Params = {
      typeUrl: "/ibc.core.client.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowedClients) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowedClients.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if (Array.isArray(object?.allowedClients))
          obj.allowedClients = object.allowedClients.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowedClients) {
          obj.allowedClients = message.allowedClients.map((e) => e);
        } else {
          obj.allowedClients = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        message.allowedClients = object.allowedClients?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseClientUpdateProposal() {
      return {
        title: "",
        description: "",
        subjectClientId: "",
        substituteClientId: ""
      };
    }
    exports$1.ClientUpdateProposal = {
      typeUrl: "/ibc.core.client.v1.ClientUpdateProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.subjectClientId !== "") {
          writer.uint32(26).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(34).string(message.substituteClientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientUpdateProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.subjectClientId = reader.string();
              break;
            case 4:
              message.substituteClientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientUpdateProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.subjectClientId))
          obj.subjectClientId = String(object.subjectClientId);
        if ((0, helpers_1.isSet)(object.substituteClientId))
          obj.substituteClientId = String(object.substituteClientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientUpdateProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.subjectClientId = object.subjectClientId ?? "";
        message.substituteClientId = object.substituteClientId ?? "";
        return message;
      }
    };
    function createBaseUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: upgrade_1.Plan.fromPartial({}),
        upgradedClientState: void 0
      };
    }
    exports$1.UpgradeProposal = {
      typeUrl: "/ibc.core.client.v1.UpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 4:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = upgrade_1.Plan.fromJSON(object.plan);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = upgrade_1.Plan.fromPartial(object.plan);
        }
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js
var require_tx9 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgUpdateParamsResponse = exports$1.MsgUpdateParams = exports$1.MsgTransferResponse = exports$1.MsgTransfer = exports$1.protobufPackage = void 0;
    var coin_1 = require_coin();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseMsgTransfer() {
      return {
        sourcePort: "",
        sourceChannel: "",
        token: coin_1.Coin.fromPartial({}),
        sender: "",
        receiver: "",
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0),
        memo: ""
      };
    }
    exports$1.MsgTransfer = {
      typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sourcePort !== "") {
          writer.uint32(10).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(18).string(message.sourceChannel);
        }
        if (message.token !== void 0) {
          coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        }
        if (message.sender !== "") {
          writer.uint32(34).string(message.sender);
        }
        if (message.receiver !== "") {
          writer.uint32(42).string(message.receiver);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== BigInt(0)) {
          writer.uint32(56).uint64(message.timeoutTimestamp);
        }
        if (message.memo !== "") {
          writer.uint32(66).string(message.memo);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sourcePort = reader.string();
              break;
            case 2:
              message.sourceChannel = reader.string();
              break;
            case 3:
              message.token = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.sender = reader.string();
              break;
            case 5:
              message.receiver = reader.string();
              break;
            case 6:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.timeoutTimestamp = reader.uint64();
              break;
            case 8:
              message.memo = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTransfer();
        if ((0, helpers_1.isSet)(object.sourcePort))
          obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel))
          obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.token))
          obj.token = coin_1.Coin.fromJSON(object.token);
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.receiver))
          obj.receiver = String(object.receiver);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp))
          obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        if ((0, helpers_1.isSet)(object.memo))
          obj.memo = String(object.memo);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.token !== void 0 && (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : void 0);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        message.memo !== void 0 && (obj.memo = message.memo);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTransfer();
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        if (object.token !== void 0 && object.token !== null) {
          message.token = coin_1.Coin.fromPartial(object.token);
        }
        message.sender = object.sender ?? "";
        message.receiver = object.receiver ?? "";
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        }
        if (object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null) {
          message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        }
        message.memo = object.memo ?? "";
        return message;
      }
    };
    function createBaseMsgTransferResponse() {
      return {
        sequence: BigInt(0)
      };
    }
    exports$1.MsgTransferResponse = {
      typeUrl: "/ibc.applications.transfer.v1.MsgTransferResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTransferResponse();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTransferResponse();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgUpdateParams17() {
      return {
        signer: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports$1.MsgUpdateParams = {
      typeUrl: "/ibc.applications.transfer.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams17();
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams17();
        message.signer = object.signer ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse17() {
      return {};
    }
    exports$1.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.applications.transfer.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse17();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse17();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Transfer = this.Transfer.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
      }
      Transfer(request) {
        const data2 = exports$1.MsgTransfer.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", data2);
        return promise.then((data3) => exports$1.MsgTransferResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports$1.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports$1.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js
var require_aminomessages9 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isAminoMsgTransfer = isAminoMsgTransfer;
    exports$1.createIbcAminoConverters = createIbcAminoConverters;
    var amino_1 = require_build5();
    var tx_1 = require_tx9();
    function isAminoMsgTransfer(msg) {
      return msg.type === "cosmos-sdk/MsgTransfer";
    }
    function createIbcAminoConverters() {
      return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
          aminoType: "cosmos-sdk/MsgTransfer",
          toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp, memo }) => ({
            source_port: sourcePort,
            source_channel: sourceChannel,
            token,
            sender,
            receiver,
            timeout_height: timeoutHeight ? {
              revision_height: (0, amino_1.omitDefault)(timeoutHeight.revisionHeight)?.toString(),
              revision_number: (0, amino_1.omitDefault)(timeoutHeight.revisionNumber)?.toString()
            } : {},
            timeout_timestamp: (0, amino_1.omitDefault)(timeoutTimestamp)?.toString(),
            memo: (0, amino_1.omitDefault)(memo)
          }),
          fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo }) => tx_1.MsgTransfer.fromPartial({
            sourcePort: source_port,
            sourceChannel: source_channel,
            token,
            sender,
            receiver,
            timeoutHeight: timeout_height ? {
              revisionHeight: BigInt(timeout_height.revision_height || "0"),
              revisionNumber: BigInt(timeout_height.revision_number || "0")
            } : void 0,
            timeoutTimestamp: BigInt(timeout_timestamp || "0"),
            memo: memo ?? ""
          })
        }
      };
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/channel/v1/channel.js
var require_channel = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/channel/v1/channel.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = exports$1.Timeout = exports$1.Acknowledgement = exports$1.PacketId = exports$1.PacketState = exports$1.Packet = exports$1.Counterparty = exports$1.IdentifiedChannel = exports$1.Channel = exports$1.orderToJSON = exports$1.orderFromJSON = exports$1.Order = exports$1.stateToJSON = exports$1.stateFromJSON = exports$1.State = exports$1.protobufPackage = void 0;
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.channel.v1";
    var State3;
    (function(State4) {
      State4[State4["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State4[State4["STATE_INIT"] = 1] = "STATE_INIT";
      State4[State4["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State4[State4["STATE_OPEN"] = 3] = "STATE_OPEN";
      State4[State4["STATE_CLOSED"] = 4] = "STATE_CLOSED";
      State4[State4["STATE_FLUSHING"] = 5] = "STATE_FLUSHING";
      State4[State4["STATE_FLUSHCOMPLETE"] = 6] = "STATE_FLUSHCOMPLETE";
      State4[State4["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State3 || (exports$1.State = State3 = {}));
    function stateFromJSON3(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State3.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State3.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State3.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State3.STATE_OPEN;
        case 4:
        case "STATE_CLOSED":
          return State3.STATE_CLOSED;
        case 5:
        case "STATE_FLUSHING":
          return State3.STATE_FLUSHING;
        case 6:
        case "STATE_FLUSHCOMPLETE":
          return State3.STATE_FLUSHCOMPLETE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State3.UNRECOGNIZED;
      }
    }
    exports$1.stateFromJSON = stateFromJSON3;
    function stateToJSON3(object) {
      switch (object) {
        case State3.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State3.STATE_INIT:
          return "STATE_INIT";
        case State3.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State3.STATE_OPEN:
          return "STATE_OPEN";
        case State3.STATE_CLOSED:
          return "STATE_CLOSED";
        case State3.STATE_FLUSHING:
          return "STATE_FLUSHING";
        case State3.STATE_FLUSHCOMPLETE:
          return "STATE_FLUSHCOMPLETE";
        case State3.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.stateToJSON = stateToJSON3;
    var Order2;
    (function(Order3) {
      Order3[Order3["ORDER_NONE_UNSPECIFIED"] = 0] = "ORDER_NONE_UNSPECIFIED";
      Order3[Order3["ORDER_UNORDERED"] = 1] = "ORDER_UNORDERED";
      Order3[Order3["ORDER_ORDERED"] = 2] = "ORDER_ORDERED";
      Order3[Order3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Order2 || (exports$1.Order = Order2 = {}));
    function orderFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_NONE_UNSPECIFIED":
          return Order2.ORDER_NONE_UNSPECIFIED;
        case 1:
        case "ORDER_UNORDERED":
          return Order2.ORDER_UNORDERED;
        case 2:
        case "ORDER_ORDERED":
          return Order2.ORDER_ORDERED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Order2.UNRECOGNIZED;
      }
    }
    exports$1.orderFromJSON = orderFromJSON;
    function orderToJSON(object) {
      switch (object) {
        case Order2.ORDER_NONE_UNSPECIFIED:
          return "ORDER_NONE_UNSPECIFIED";
        case Order2.ORDER_UNORDERED:
          return "ORDER_UNORDERED";
        case Order2.ORDER_ORDERED:
          return "ORDER_ORDERED";
        case Order2.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.orderToJSON = orderToJSON;
    function createBaseChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: exports$1.Counterparty.fromPartial({}),
        connectionHops: [],
        version: "",
        upgradeSequence: BigInt(0)
      };
    }
    exports$1.Channel = {
      typeUrl: "/ibc.core.channel.v1.Channel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports$1.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(48).uint64(message.upgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports$1.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.upgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseChannel();
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON3(object.state);
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports$1.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object?.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON3(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports$1.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports$1.Counterparty.fromPartial(object.counterparty);
        }
        message.connectionHops = object.connectionHops?.map((e) => e) || [];
        message.version = object.version ?? "";
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseIdentifiedChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: exports$1.Counterparty.fromPartial({}),
        connectionHops: [],
        version: "",
        portId: "",
        channelId: "",
        upgradeSequence: BigInt(0)
      };
    }
    exports$1.IdentifiedChannel = {
      typeUrl: "/ibc.core.channel.v1.IdentifiedChannel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports$1.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.portId !== "") {
          writer.uint32(50).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(58).string(message.channelId);
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(64).uint64(message.upgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports$1.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.portId = reader.string();
              break;
            case 7:
              message.channelId = reader.string();
              break;
            case 8:
              message.upgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedChannel();
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON3(object.state);
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports$1.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object?.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON3(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports$1.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIdentifiedChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports$1.Counterparty.fromPartial(object.counterparty);
        }
        message.connectionHops = object.connectionHops?.map((e) => e) || [];
        message.version = object.version ?? "";
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseCounterparty() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports$1.Counterparty = {
      typeUrl: "/ibc.core.channel.v1.Counterparty",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCounterparty();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBasePacket() {
      return {
        sequence: BigInt(0),
        sourcePort: "",
        sourceChannel: "",
        destinationPort: "",
        destinationChannel: "",
        data: new Uint8Array(),
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0)
      };
    }
    exports$1.Packet = {
      typeUrl: "/ibc.core.channel.v1.Packet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.sourcePort !== "") {
          writer.uint32(18).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(26).string(message.sourceChannel);
        }
        if (message.destinationPort !== "") {
          writer.uint32(34).string(message.destinationPort);
        }
        if (message.destinationChannel !== "") {
          writer.uint32(42).string(message.destinationChannel);
        }
        if (message.data.length !== 0) {
          writer.uint32(50).bytes(message.data);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== BigInt(0)) {
          writer.uint32(64).uint64(message.timeoutTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            case 2:
              message.sourcePort = reader.string();
              break;
            case 3:
              message.sourceChannel = reader.string();
              break;
            case 4:
              message.destinationPort = reader.string();
              break;
            case 5:
              message.destinationChannel = reader.string();
              break;
            case 6:
              message.data = reader.bytes();
              break;
            case 7:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.timeoutTimestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacket();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.sourcePort))
          obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel))
          obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.destinationPort))
          obj.destinationPort = String(object.destinationPort);
        if ((0, helpers_1.isSet)(object.destinationChannel))
          obj.destinationChannel = String(object.destinationChannel);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp))
          obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.destinationPort !== void 0 && (obj.destinationPort = message.destinationPort);
        message.destinationChannel !== void 0 && (obj.destinationChannel = message.destinationChannel);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacket();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        message.destinationPort = object.destinationPort ?? "";
        message.destinationChannel = object.destinationChannel ?? "";
        message.data = object.data ?? new Uint8Array();
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        }
        if (object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null) {
          message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        }
        return message;
      }
    };
    function createBasePacketState() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0),
        data: new Uint8Array()
      };
    }
    exports$1.PacketState = {
      typeUrl: "/ibc.core.channel.v1.PacketState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        if (message.data.length !== 0) {
          writer.uint32(34).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            case 4:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacketState();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacketState();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBasePacketId() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports$1.PacketId = {
      typeUrl: "/ibc.core.channel.v1.PacketId",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketId();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacketId();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacketId();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseAcknowledgement() {
      return {
        result: void 0,
        error: void 0
      };
    }
    exports$1.Acknowledgement = {
      typeUrl: "/ibc.core.channel.v1.Acknowledgement",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== void 0) {
          writer.uint32(170).bytes(message.result);
        }
        if (message.error !== void 0) {
          writer.uint32(178).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 21:
              message.result = reader.bytes();
              break;
            case 22:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAcknowledgement();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = (0, helpers_1.bytesFromBase64)(object.result);
        if ((0, helpers_1.isSet)(object.error))
          obj.error = String(object.error);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = message.result !== void 0 ? (0, helpers_1.base64FromBytes)(message.result) : void 0);
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAcknowledgement();
        message.result = object.result ?? void 0;
        message.error = object.error ?? void 0;
        return message;
      }
    };
    function createBaseTimeout() {
      return {
        height: client_1.Height.fromPartial({}),
        timestamp: BigInt(0)
      };
    }
    exports$1.Timeout = {
      typeUrl: "/ibc.core.channel.v1.Timeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.timestamp !== BigInt(0)) {
          writer.uint32(16).uint64(message.timestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.timestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTimeout();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = BigInt(object.timestamp.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTimeout();
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = BigInt(object.timestamp.toString());
        }
        return message;
      }
    };
    function createBaseParams15() {
      return {
        upgradeTimeout: exports$1.Timeout.fromPartial({})
      };
    }
    exports$1.Params = {
      typeUrl: "/ibc.core.channel.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradeTimeout !== void 0) {
          exports$1.Timeout.encode(message.upgradeTimeout, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradeTimeout = exports$1.Timeout.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if ((0, helpers_1.isSet)(object.upgradeTimeout))
          obj.upgradeTimeout = exports$1.Timeout.fromJSON(object.upgradeTimeout);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradeTimeout !== void 0 && (obj.upgradeTimeout = message.upgradeTimeout ? exports$1.Timeout.toJSON(message.upgradeTimeout) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        if (object.upgradeTimeout !== void 0 && object.upgradeTimeout !== null) {
          message.upgradeTimeout = exports$1.Timeout.fromPartial(object.upgradeTimeout);
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/ibc/core/channel/v1/upgrade.js
var require_upgrade2 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/channel/v1/upgrade.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ErrorReceipt = exports$1.UpgradeFields = exports$1.Upgrade = exports$1.protobufPackage = void 0;
    var channel_1 = require_channel();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.channel.v1";
    function createBaseUpgrade() {
      return {
        fields: exports$1.UpgradeFields.fromPartial({}),
        timeout: channel_1.Timeout.fromPartial({}),
        nextSequenceSend: BigInt(0)
      };
    }
    exports$1.Upgrade = {
      typeUrl: "/ibc.core.channel.v1.Upgrade",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fields !== void 0) {
          exports$1.UpgradeFields.encode(message.fields, writer.uint32(10).fork()).ldelim();
        }
        if (message.timeout !== void 0) {
          channel_1.Timeout.encode(message.timeout, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextSequenceSend !== BigInt(0)) {
          writer.uint32(24).uint64(message.nextSequenceSend);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgrade();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fields = exports$1.UpgradeFields.decode(reader, reader.uint32());
              break;
            case 2:
              message.timeout = channel_1.Timeout.decode(reader, reader.uint32());
              break;
            case 3:
              message.nextSequenceSend = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgrade();
        if ((0, helpers_1.isSet)(object.fields))
          obj.fields = exports$1.UpgradeFields.fromJSON(object.fields);
        if ((0, helpers_1.isSet)(object.timeout))
          obj.timeout = channel_1.Timeout.fromJSON(object.timeout);
        if ((0, helpers_1.isSet)(object.nextSequenceSend))
          obj.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fields !== void 0 && (obj.fields = message.fields ? exports$1.UpgradeFields.toJSON(message.fields) : void 0);
        message.timeout !== void 0 && (obj.timeout = message.timeout ? channel_1.Timeout.toJSON(message.timeout) : void 0);
        message.nextSequenceSend !== void 0 && (obj.nextSequenceSend = (message.nextSequenceSend || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUpgrade();
        if (object.fields !== void 0 && object.fields !== null) {
          message.fields = exports$1.UpgradeFields.fromPartial(object.fields);
        }
        if (object.timeout !== void 0 && object.timeout !== null) {
          message.timeout = channel_1.Timeout.fromPartial(object.timeout);
        }
        if (object.nextSequenceSend !== void 0 && object.nextSequenceSend !== null) {
          message.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        }
        return message;
      }
    };
    function createBaseUpgradeFields() {
      return {
        ordering: 0,
        connectionHops: [],
        version: ""
      };
    }
    exports$1.UpgradeFields = {
      typeUrl: "/ibc.core.channel.v1.UpgradeFields",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.ordering !== 0) {
          writer.uint32(8).int32(message.ordering);
        }
        for (const v of message.connectionHops) {
          writer.uint32(18).string(v);
        }
        if (message.version !== "") {
          writer.uint32(26).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeFields();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ordering = reader.int32();
              break;
            case 2:
              message.connectionHops.push(reader.string());
              break;
            case 3:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgradeFields();
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = (0, channel_1.orderFromJSON)(object.ordering);
        if (Array.isArray(object?.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.ordering !== void 0 && (obj.ordering = (0, channel_1.orderToJSON)(message.ordering));
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUpgradeFields();
        message.ordering = object.ordering ?? 0;
        message.connectionHops = object.connectionHops?.map((e) => e) || [];
        message.version = object.version ?? "";
        return message;
      }
    };
    function createBaseErrorReceipt() {
      return {
        sequence: BigInt(0),
        message: ""
      };
    }
    exports$1.ErrorReceipt = {
      typeUrl: "/ibc.core.channel.v1.ErrorReceipt",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.message !== "") {
          writer.uint32(18).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseErrorReceipt();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            case 2:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseErrorReceipt();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseErrorReceipt();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.message = object.message ?? "";
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/ibc/core/channel/v1/tx.js
var require_tx10 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/channel/v1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgPruneAcknowledgementsResponse = exports$1.MsgPruneAcknowledgements = exports$1.MsgUpdateParamsResponse = exports$1.MsgUpdateParams = exports$1.MsgChannelUpgradeCancelResponse = exports$1.MsgChannelUpgradeCancel = exports$1.MsgChannelUpgradeTimeoutResponse = exports$1.MsgChannelUpgradeTimeout = exports$1.MsgChannelUpgradeOpenResponse = exports$1.MsgChannelUpgradeOpen = exports$1.MsgChannelUpgradeConfirmResponse = exports$1.MsgChannelUpgradeConfirm = exports$1.MsgChannelUpgradeAckResponse = exports$1.MsgChannelUpgradeAck = exports$1.MsgChannelUpgradeTryResponse = exports$1.MsgChannelUpgradeTry = exports$1.MsgChannelUpgradeInitResponse = exports$1.MsgChannelUpgradeInit = exports$1.MsgAcknowledgementResponse = exports$1.MsgAcknowledgement = exports$1.MsgTimeoutOnCloseResponse = exports$1.MsgTimeoutOnClose = exports$1.MsgTimeoutResponse = exports$1.MsgTimeout = exports$1.MsgRecvPacketResponse = exports$1.MsgRecvPacket = exports$1.MsgChannelCloseConfirmResponse = exports$1.MsgChannelCloseConfirm = exports$1.MsgChannelCloseInitResponse = exports$1.MsgChannelCloseInit = exports$1.MsgChannelOpenConfirmResponse = exports$1.MsgChannelOpenConfirm = exports$1.MsgChannelOpenAckResponse = exports$1.MsgChannelOpenAck = exports$1.MsgChannelOpenTryResponse = exports$1.MsgChannelOpenTry = exports$1.MsgChannelOpenInitResponse = exports$1.MsgChannelOpenInit = exports$1.responseResultTypeToJSON = exports$1.responseResultTypeFromJSON = exports$1.ResponseResultType = exports$1.protobufPackage = void 0;
    var channel_1 = require_channel();
    var client_1 = require_client();
    var upgrade_1 = require_upgrade2();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.channel.v1";
    var ResponseResultType;
    (function(ResponseResultType2) {
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_UNSPECIFIED"] = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_NOOP"] = 1] = "RESPONSE_RESULT_TYPE_NOOP";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_SUCCESS"] = 2] = "RESPONSE_RESULT_TYPE_SUCCESS";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_FAILURE"] = 3] = "RESPONSE_RESULT_TYPE_FAILURE";
      ResponseResultType2[ResponseResultType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseResultType || (exports$1.ResponseResultType = ResponseResultType = {}));
    function responseResultTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
          return ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED;
        case 1:
        case "RESPONSE_RESULT_TYPE_NOOP":
          return ResponseResultType.RESPONSE_RESULT_TYPE_NOOP;
        case 2:
        case "RESPONSE_RESULT_TYPE_SUCCESS":
          return ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS;
        case 3:
        case "RESPONSE_RESULT_TYPE_FAILURE":
          return ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseResultType.UNRECOGNIZED;
      }
    }
    exports$1.responseResultTypeFromJSON = responseResultTypeFromJSON;
    function responseResultTypeToJSON(object) {
      switch (object) {
        case ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED:
          return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
        case ResponseResultType.RESPONSE_RESULT_TYPE_NOOP:
          return "RESPONSE_RESULT_TYPE_NOOP";
        case ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS:
          return "RESPONSE_RESULT_TYPE_SUCCESS";
        case ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE:
          return "RESPONSE_RESULT_TYPE_FAILURE";
        case ResponseResultType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.responseResultTypeToJSON = responseResultTypeToJSON;
    function createBaseMsgChannelOpenInit() {
      return {
        portId: "",
        channel: channel_1.Channel.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelOpenInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenInit();
        message.portId = object.portId ?? "";
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenInitResponse() {
      return {
        channelId: "",
        version: ""
      };
    }
    exports$1.MsgChannelOpenInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInitResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.channelId !== "") {
          writer.uint32(10).string(message.channelId);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channelId = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenInitResponse();
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenInitResponse();
        message.channelId = object.channelId ?? "";
        message.version = object.version ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTry() {
      return {
        portId: "",
        previousChannelId: "",
        channel: channel_1.Channel.fromPartial({}),
        counterpartyVersion: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelOpenTry = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.previousChannelId !== "") {
          writer.uint32(18).string(message.previousChannelId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(42).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.previousChannelId = reader.string();
              break;
            case 3:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofInit = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenTry();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.previousChannelId))
          obj.previousChannelId = String(object.previousChannelId);
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.counterpartyVersion))
          obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.previousChannelId !== void 0 && (obj.previousChannelId = message.previousChannelId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenTry();
        message.portId = object.portId ?? "";
        message.previousChannelId = object.previousChannelId ?? "";
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTryResponse() {
      return {
        version: "",
        channelId: ""
      };
    }
    exports$1.MsgChannelOpenTryResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenTryResponse();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenTryResponse();
        message.version = object.version ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenAck() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelId: "",
        counterpartyVersion: "",
        proofTry: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelOpenAck = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelId !== "") {
          writer.uint32(26).string(message.counterpartyChannelId);
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(42).bytes(message.proofTry);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelId = reader.string();
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofTry = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenAck();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelId))
          obj.counterpartyChannelId = String(object.counterpartyChannelId);
        if ((0, helpers_1.isSet)(object.counterpartyVersion))
          obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofTry))
          obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelId !== void 0 && (obj.counterpartyChannelId = message.counterpartyChannelId);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofTry !== void 0 && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenAck();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelId = object.counterpartyChannelId ?? "";
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofTry = object.proofTry ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenAckResponse() {
      return {};
    }
    exports$1.MsgChannelOpenAckResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAckResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelOpenAckResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirm() {
      return {
        portId: "",
        channelId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelOpenConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(26).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofAck = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofAck))
          obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofAck !== void 0 && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirmResponse() {
      return {};
    }
    exports$1.MsgChannelOpenConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirmResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelOpenConfirmResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelOpenConfirmResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseInit() {
      return {
        portId: "",
        channelId: "",
        signer: ""
      };
    }
    exports$1.MsgChannelCloseInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelCloseInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelCloseInit();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelCloseInitResponse() {
      return {};
    }
    exports$1.MsgChannelCloseInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInitResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelCloseInitResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelCloseInitResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirm() {
      return {
        portId: "",
        channelId: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: "",
        counterpartyUpgradeSequence: BigInt(0)
      };
    }
    exports$1.MsgChannelCloseConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(26).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(48).uint64(message.counterpartyUpgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofInit = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            case 6:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelCloseConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelCloseConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirmResponse() {
      return {};
    }
    exports$1.MsgChannelCloseConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirmResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelCloseConfirmResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelCloseConfirmResponse();
        return message;
      }
    };
    function createBaseMsgRecvPacket() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofCommitment: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgRecvPacket = {
      typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofCommitment.length !== 0) {
          writer.uint32(18).bytes(message.proofCommitment);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofCommitment = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecvPacket();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofCommitment))
          obj.proofCommitment = (0, helpers_1.bytesFromBase64)(object.proofCommitment);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofCommitment !== void 0 && (obj.proofCommitment = (0, helpers_1.base64FromBytes)(message.proofCommitment !== void 0 ? message.proofCommitment : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecvPacket();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofCommitment = object.proofCommitment ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgRecvPacketResponse() {
      return {
        result: 0
      };
    }
    exports$1.MsgRecvPacketResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgRecvPacketResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacketResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecvPacketResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecvPacketResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgTimeout() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: ""
      };
    }
    exports$1.MsgTimeout = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.nextSequenceRecv !== BigInt(0)) {
          writer.uint32(32).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeout();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived))
          obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv))
          obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeout();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null) {
          message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgTimeoutResponse() {
      return {
        result: 0
      };
    }
    exports$1.MsgTimeoutResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgTimeoutOnClose() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofClose: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: "",
        counterpartyUpgradeSequence: BigInt(0)
      };
    }
    exports$1.MsgTimeoutOnClose = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofClose.length !== 0) {
          writer.uint32(26).bytes(message.proofClose);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.nextSequenceRecv !== BigInt(0)) {
          writer.uint32(40).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(56).uint64(message.counterpartyUpgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnClose();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofClose = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 6:
              message.signer = reader.string();
              break;
            case 7:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutOnClose();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived))
          obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofClose))
          obj.proofClose = (0, helpers_1.bytesFromBase64)(object.proofClose);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv))
          obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofClose !== void 0 && (obj.proofClose = (0, helpers_1.base64FromBytes)(message.proofClose !== void 0 ? message.proofClose : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutOnClose();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        message.proofClose = object.proofClose ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null) {
          message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        }
        message.signer = object.signer ?? "";
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgTimeoutOnCloseResponse() {
      return {
        result: 0
      };
    }
    exports$1.MsgTimeoutOnCloseResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnCloseResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnCloseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutOnCloseResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutOnCloseResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgAcknowledgement() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        acknowledgement: new Uint8Array(),
        proofAcked: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgAcknowledgement = {
      typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.acknowledgement.length !== 0) {
          writer.uint32(18).bytes(message.acknowledgement);
        }
        if (message.proofAcked.length !== 0) {
          writer.uint32(26).bytes(message.proofAcked);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.acknowledgement = reader.bytes();
              break;
            case 3:
              message.proofAcked = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgAcknowledgement();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.acknowledgement))
          obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proofAcked))
          obj.proofAcked = (0, helpers_1.bytesFromBase64)(object.proofAcked);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.acknowledgement !== void 0 && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proofAcked !== void 0 && (obj.proofAcked = (0, helpers_1.base64FromBytes)(message.proofAcked !== void 0 ? message.proofAcked : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgAcknowledgement();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proofAcked = object.proofAcked ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgAcknowledgementResponse() {
      return {
        result: 0
      };
    }
    exports$1.MsgAcknowledgementResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgAcknowledgementResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgAcknowledgementResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeInit() {
      return {
        portId: "",
        channelId: "",
        fields: upgrade_1.UpgradeFields.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelUpgradeInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.fields !== void 0) {
          upgrade_1.UpgradeFields.encode(message.fields, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.fields = upgrade_1.UpgradeFields.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.fields))
          obj.fields = upgrade_1.UpgradeFields.fromJSON(object.fields);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.fields !== void 0 && (obj.fields = message.fields ? upgrade_1.UpgradeFields.toJSON(message.fields) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeInit();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.fields !== void 0 && object.fields !== null) {
          message.fields = upgrade_1.UpgradeFields.fromPartial(object.fields);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeInitResponse() {
      return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        upgradeSequence: BigInt(0)
      };
    }
    exports$1.MsgChannelUpgradeInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInitResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(16).uint64(message.upgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 2:
              message.upgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeInitResponse();
        if ((0, helpers_1.isSet)(object.upgrade))
          obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgrade !== void 0 && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : void 0);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeInitResponse();
        if (object.upgrade !== void 0 && object.upgrade !== null) {
          message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        }
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTry() {
      return {
        portId: "",
        channelId: "",
        proposedUpgradeConnectionHops: [],
        counterpartyUpgradeFields: upgrade_1.UpgradeFields.fromPartial({}),
        counterpartyUpgradeSequence: BigInt(0),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelUpgradeTry = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        for (const v of message.proposedUpgradeConnectionHops) {
          writer.uint32(26).string(v);
        }
        if (message.counterpartyUpgradeFields !== void 0) {
          upgrade_1.UpgradeFields.encode(message.counterpartyUpgradeFields, writer.uint32(34).fork()).ldelim();
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(40).uint64(message.counterpartyUpgradeSequence);
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(50).bytes(message.proofChannel);
        }
        if (message.proofUpgrade.length !== 0) {
          writer.uint32(58).bytes(message.proofUpgrade);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(66).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(74).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proposedUpgradeConnectionHops.push(reader.string());
              break;
            case 4:
              message.counterpartyUpgradeFields = upgrade_1.UpgradeFields.decode(reader, reader.uint32());
              break;
            case 5:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            case 6:
              message.proofChannel = reader.bytes();
              break;
            case 7:
              message.proofUpgrade = reader.bytes();
              break;
            case 8:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 9:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeTry();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object?.proposedUpgradeConnectionHops))
          obj.proposedUpgradeConnectionHops = object.proposedUpgradeConnectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeFields))
          obj.counterpartyUpgradeFields = upgrade_1.UpgradeFields.fromJSON(object.counterpartyUpgradeFields);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade))
          obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.proposedUpgradeConnectionHops) {
          obj.proposedUpgradeConnectionHops = message.proposedUpgradeConnectionHops.map((e) => e);
        } else {
          obj.proposedUpgradeConnectionHops = [];
        }
        message.counterpartyUpgradeFields !== void 0 && (obj.counterpartyUpgradeFields = message.counterpartyUpgradeFields ? upgrade_1.UpgradeFields.toJSON(message.counterpartyUpgradeFields) : void 0);
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== void 0 && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== void 0 ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeTry();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proposedUpgradeConnectionHops = object.proposedUpgradeConnectionHops?.map((e) => e) || [];
        if (object.counterpartyUpgradeFields !== void 0 && object.counterpartyUpgradeFields !== null) {
          message.counterpartyUpgradeFields = upgrade_1.UpgradeFields.fromPartial(object.counterpartyUpgradeFields);
        }
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTryResponse() {
      return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        upgradeSequence: BigInt(0),
        result: 0
      };
    }
    exports$1.MsgChannelUpgradeTryResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(16).uint64(message.upgradeSequence);
        }
        if (message.result !== 0) {
          writer.uint32(24).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 2:
              message.upgradeSequence = reader.uint64();
              break;
            case 3:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeTryResponse();
        if ((0, helpers_1.isSet)(object.upgrade))
          obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgrade !== void 0 && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : void 0);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeTryResponse();
        if (object.upgrade !== void 0 && object.upgrade !== null) {
          message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        }
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeAck() {
      return {
        portId: "",
        channelId: "",
        counterpartyUpgrade: upgrade_1.Upgrade.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelUpgradeAck = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyUpgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.counterpartyUpgrade, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(34).bytes(message.proofChannel);
        }
        if (message.proofUpgrade.length !== 0) {
          writer.uint32(42).bytes(message.proofUpgrade);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyUpgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofChannel = reader.bytes();
              break;
            case 5:
              message.proofUpgrade = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeAck();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyUpgrade))
          obj.counterpartyUpgrade = upgrade_1.Upgrade.fromJSON(object.counterpartyUpgrade);
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade))
          obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyUpgrade !== void 0 && (obj.counterpartyUpgrade = message.counterpartyUpgrade ? upgrade_1.Upgrade.toJSON(message.counterpartyUpgrade) : void 0);
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== void 0 && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== void 0 ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeAck();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.counterpartyUpgrade !== void 0 && object.counterpartyUpgrade !== null) {
          message.counterpartyUpgrade = upgrade_1.Upgrade.fromPartial(object.counterpartyUpgrade);
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeAckResponse() {
      return {
        result: 0
      };
    }
    exports$1.MsgChannelUpgradeAckResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAckResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeAckResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeAckResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeConfirm() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelState: 0,
        counterpartyUpgrade: upgrade_1.Upgrade.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelUpgradeConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelState !== 0) {
          writer.uint32(24).int32(message.counterpartyChannelState);
        }
        if (message.counterpartyUpgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.counterpartyUpgrade, writer.uint32(34).fork()).ldelim();
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(42).bytes(message.proofChannel);
        }
        if (message.proofUpgrade.length !== 0) {
          writer.uint32(50).bytes(message.proofUpgrade);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(66).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelState = reader.int32();
              break;
            case 4:
              message.counterpartyUpgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 5:
              message.proofChannel = reader.bytes();
              break;
            case 6:
              message.proofUpgrade = reader.bytes();
              break;
            case 7:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelState))
          obj.counterpartyChannelState = (0, channel_1.stateFromJSON)(object.counterpartyChannelState);
        if ((0, helpers_1.isSet)(object.counterpartyUpgrade))
          obj.counterpartyUpgrade = upgrade_1.Upgrade.fromJSON(object.counterpartyUpgrade);
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade))
          obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelState !== void 0 && (obj.counterpartyChannelState = (0, channel_1.stateToJSON)(message.counterpartyChannelState));
        message.counterpartyUpgrade !== void 0 && (obj.counterpartyUpgrade = message.counterpartyUpgrade ? upgrade_1.Upgrade.toJSON(message.counterpartyUpgrade) : void 0);
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== void 0 && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== void 0 ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelState = object.counterpartyChannelState ?? 0;
        if (object.counterpartyUpgrade !== void 0 && object.counterpartyUpgrade !== null) {
          message.counterpartyUpgrade = upgrade_1.Upgrade.fromPartial(object.counterpartyUpgrade);
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeConfirmResponse() {
      return {
        result: 0
      };
    }
    exports$1.MsgChannelUpgradeConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirmResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeConfirmResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeOpen() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelState: 0,
        counterpartyUpgradeSequence: BigInt(0),
        proofChannel: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelUpgradeOpen = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpen",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelState !== 0) {
          writer.uint32(24).int32(message.counterpartyChannelState);
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(32).uint64(message.counterpartyUpgradeSequence);
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(42).bytes(message.proofChannel);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpen();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelState = reader.int32();
              break;
            case 4:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            case 5:
              message.proofChannel = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeOpen();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelState))
          obj.counterpartyChannelState = (0, channel_1.stateFromJSON)(object.counterpartyChannelState);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelState !== void 0 && (obj.counterpartyChannelState = (0, channel_1.stateToJSON)(message.counterpartyChannelState));
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeOpen();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelState = object.counterpartyChannelState ?? 0;
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeOpenResponse() {
      return {};
    }
    exports$1.MsgChannelUpgradeOpenResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpenResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpenResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelUpgradeOpenResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelUpgradeOpenResponse();
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTimeout() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannel: channel_1.Channel.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelUpgradeTimeout = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannel !== void 0) {
          channel_1.Channel.encode(message.counterpartyChannel, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(34).bytes(message.proofChannel);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofChannel = reader.bytes();
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeTimeout();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannel))
          obj.counterpartyChannel = channel_1.Channel.fromJSON(object.counterpartyChannel);
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannel !== void 0 && (obj.counterpartyChannel = message.counterpartyChannel ? channel_1.Channel.toJSON(message.counterpartyChannel) : void 0);
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeTimeout();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.counterpartyChannel !== void 0 && object.counterpartyChannel !== null) {
          message.counterpartyChannel = channel_1.Channel.fromPartial(object.counterpartyChannel);
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTimeoutResponse() {
      return {};
    }
    exports$1.MsgChannelUpgradeTimeoutResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeoutResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelUpgradeTimeoutResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        return message;
      }
    };
    function createBaseMsgChannelUpgradeCancel() {
      return {
        portId: "",
        channelId: "",
        errorReceipt: upgrade_1.ErrorReceipt.fromPartial({}),
        proofErrorReceipt: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgChannelUpgradeCancel = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.errorReceipt !== void 0) {
          upgrade_1.ErrorReceipt.encode(message.errorReceipt, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofErrorReceipt.length !== 0) {
          writer.uint32(34).bytes(message.proofErrorReceipt);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.errorReceipt = upgrade_1.ErrorReceipt.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofErrorReceipt = reader.bytes();
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeCancel();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.errorReceipt))
          obj.errorReceipt = upgrade_1.ErrorReceipt.fromJSON(object.errorReceipt);
        if ((0, helpers_1.isSet)(object.proofErrorReceipt))
          obj.proofErrorReceipt = (0, helpers_1.bytesFromBase64)(object.proofErrorReceipt);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.errorReceipt !== void 0 && (obj.errorReceipt = message.errorReceipt ? upgrade_1.ErrorReceipt.toJSON(message.errorReceipt) : void 0);
        message.proofErrorReceipt !== void 0 && (obj.proofErrorReceipt = (0, helpers_1.base64FromBytes)(message.proofErrorReceipt !== void 0 ? message.proofErrorReceipt : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeCancel();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.errorReceipt !== void 0 && object.errorReceipt !== null) {
          message.errorReceipt = upgrade_1.ErrorReceipt.fromPartial(object.errorReceipt);
        }
        message.proofErrorReceipt = object.proofErrorReceipt ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeCancelResponse() {
      return {};
    }
    exports$1.MsgChannelUpgradeCancelResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancelResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancelResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelUpgradeCancelResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelUpgradeCancelResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams17() {
      return {
        authority: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports$1.MsgUpdateParams = {
      typeUrl: "/ibc.core.channel.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams17();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams17();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse17() {
      return {};
    }
    exports$1.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse17();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse17();
        return message;
      }
    };
    function createBaseMsgPruneAcknowledgements() {
      return {
        portId: "",
        channelId: "",
        limit: BigInt(0),
        signer: ""
      };
    }
    exports$1.MsgPruneAcknowledgements = {
      typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgements",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(24).uint64(message.limit);
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgements();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.limit = reader.uint64();
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPruneAcknowledgements();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPruneAcknowledgements();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgPruneAcknowledgementsResponse() {
      return {
        totalPrunedSequences: BigInt(0),
        totalRemainingSequences: BigInt(0)
      };
    }
    exports$1.MsgPruneAcknowledgementsResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgementsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalPrunedSequences !== BigInt(0)) {
          writer.uint32(8).uint64(message.totalPrunedSequences);
        }
        if (message.totalRemainingSequences !== BigInt(0)) {
          writer.uint32(16).uint64(message.totalRemainingSequences);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgementsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalPrunedSequences = reader.uint64();
              break;
            case 2:
              message.totalRemainingSequences = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPruneAcknowledgementsResponse();
        if ((0, helpers_1.isSet)(object.totalPrunedSequences))
          obj.totalPrunedSequences = BigInt(object.totalPrunedSequences.toString());
        if ((0, helpers_1.isSet)(object.totalRemainingSequences))
          obj.totalRemainingSequences = BigInt(object.totalRemainingSequences.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalPrunedSequences !== void 0 && (obj.totalPrunedSequences = (message.totalPrunedSequences || BigInt(0)).toString());
        message.totalRemainingSequences !== void 0 && (obj.totalRemainingSequences = (message.totalRemainingSequences || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPruneAcknowledgementsResponse();
        if (object.totalPrunedSequences !== void 0 && object.totalPrunedSequences !== null) {
          message.totalPrunedSequences = BigInt(object.totalPrunedSequences.toString());
        }
        if (object.totalRemainingSequences !== void 0 && object.totalRemainingSequences !== null) {
          message.totalRemainingSequences = BigInt(object.totalRemainingSequences.toString());
        }
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ChannelOpenInit = this.ChannelOpenInit.bind(this);
        this.ChannelOpenTry = this.ChannelOpenTry.bind(this);
        this.ChannelOpenAck = this.ChannelOpenAck.bind(this);
        this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);
        this.ChannelCloseInit = this.ChannelCloseInit.bind(this);
        this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);
        this.RecvPacket = this.RecvPacket.bind(this);
        this.Timeout = this.Timeout.bind(this);
        this.TimeoutOnClose = this.TimeoutOnClose.bind(this);
        this.Acknowledgement = this.Acknowledgement.bind(this);
        this.ChannelUpgradeInit = this.ChannelUpgradeInit.bind(this);
        this.ChannelUpgradeTry = this.ChannelUpgradeTry.bind(this);
        this.ChannelUpgradeAck = this.ChannelUpgradeAck.bind(this);
        this.ChannelUpgradeConfirm = this.ChannelUpgradeConfirm.bind(this);
        this.ChannelUpgradeOpen = this.ChannelUpgradeOpen.bind(this);
        this.ChannelUpgradeTimeout = this.ChannelUpgradeTimeout.bind(this);
        this.ChannelUpgradeCancel = this.ChannelUpgradeCancel.bind(this);
        this.UpdateChannelParams = this.UpdateChannelParams.bind(this);
        this.PruneAcknowledgements = this.PruneAcknowledgements.bind(this);
      }
      ChannelOpenInit(request) {
        const data2 = exports$1.MsgChannelOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", data2);
        return promise.then((data3) => exports$1.MsgChannelOpenInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelOpenTry(request) {
        const data2 = exports$1.MsgChannelOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", data2);
        return promise.then((data3) => exports$1.MsgChannelOpenTryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelOpenAck(request) {
        const data2 = exports$1.MsgChannelOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", data2);
        return promise.then((data3) => exports$1.MsgChannelOpenAckResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelOpenConfirm(request) {
        const data2 = exports$1.MsgChannelOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", data2);
        return promise.then((data3) => exports$1.MsgChannelOpenConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelCloseInit(request) {
        const data2 = exports$1.MsgChannelCloseInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", data2);
        return promise.then((data3) => exports$1.MsgChannelCloseInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelCloseConfirm(request) {
        const data2 = exports$1.MsgChannelCloseConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", data2);
        return promise.then((data3) => exports$1.MsgChannelCloseConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RecvPacket(request) {
        const data2 = exports$1.MsgRecvPacket.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", data2);
        return promise.then((data3) => exports$1.MsgRecvPacketResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Timeout(request) {
        const data2 = exports$1.MsgTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", data2);
        return promise.then((data3) => exports$1.MsgTimeoutResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TimeoutOnClose(request) {
        const data2 = exports$1.MsgTimeoutOnClose.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", data2);
        return promise.then((data3) => exports$1.MsgTimeoutOnCloseResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Acknowledgement(request) {
        const data2 = exports$1.MsgAcknowledgement.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", data2);
        return promise.then((data3) => exports$1.MsgAcknowledgementResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeInit(request) {
        const data2 = exports$1.MsgChannelUpgradeInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeInit", data2);
        return promise.then((data3) => exports$1.MsgChannelUpgradeInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeTry(request) {
        const data2 = exports$1.MsgChannelUpgradeTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeTry", data2);
        return promise.then((data3) => exports$1.MsgChannelUpgradeTryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeAck(request) {
        const data2 = exports$1.MsgChannelUpgradeAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeAck", data2);
        return promise.then((data3) => exports$1.MsgChannelUpgradeAckResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeConfirm(request) {
        const data2 = exports$1.MsgChannelUpgradeConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeConfirm", data2);
        return promise.then((data3) => exports$1.MsgChannelUpgradeConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeOpen(request) {
        const data2 = exports$1.MsgChannelUpgradeOpen.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeOpen", data2);
        return promise.then((data3) => exports$1.MsgChannelUpgradeOpenResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeTimeout(request) {
        const data2 = exports$1.MsgChannelUpgradeTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeTimeout", data2);
        return promise.then((data3) => exports$1.MsgChannelUpgradeTimeoutResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeCancel(request) {
        const data2 = exports$1.MsgChannelUpgradeCancel.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeCancel", data2);
        return promise.then((data3) => exports$1.MsgChannelUpgradeCancelResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateChannelParams(request) {
        const data2 = exports$1.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "UpdateChannelParams", data2);
        return promise.then((data3) => exports$1.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PruneAcknowledgements(request) {
        const data2 = exports$1.MsgPruneAcknowledgements.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "PruneAcknowledgements", data2);
        return promise.then((data3) => exports$1.MsgPruneAcknowledgementsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/cosmjs-types/ibc/core/client/v1/tx.js
var require_tx11 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/client/v1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgUpdateParamsResponse = exports$1.MsgUpdateParams = exports$1.MsgIBCSoftwareUpgradeResponse = exports$1.MsgIBCSoftwareUpgrade = exports$1.MsgRecoverClientResponse = exports$1.MsgRecoverClient = exports$1.MsgSubmitMisbehaviourResponse = exports$1.MsgSubmitMisbehaviour = exports$1.MsgUpgradeClientResponse = exports$1.MsgUpgradeClient = exports$1.MsgUpdateClientResponse = exports$1.MsgUpdateClient = exports$1.MsgCreateClientResponse = exports$1.MsgCreateClient = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var upgrade_1 = require_upgrade();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.client.v1";
    function createBaseMsgCreateClient() {
      return {
        clientState: void 0,
        consensusState: void 0,
        signer: ""
      };
    }
    exports$1.MsgCreateClient = {
      typeUrl: "/ibc.core.client.v1.MsgCreateClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateClient();
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateClient();
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgCreateClientResponse() {
      return {};
    }
    exports$1.MsgCreateClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgCreateClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreateClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpdateClient() {
      return {
        clientId: "",
        clientMessage: void 0,
        signer: ""
      };
    }
    exports$1.MsgUpdateClient = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientMessage !== void 0) {
          any_1.Any.encode(message.clientMessage, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientMessage = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateClient();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientMessage))
          obj.clientMessage = any_1.Any.fromJSON(object.clientMessage);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientMessage !== void 0 && (obj.clientMessage = message.clientMessage ? any_1.Any.toJSON(message.clientMessage) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateClient();
        message.clientId = object.clientId ?? "";
        if (object.clientMessage !== void 0 && object.clientMessage !== null) {
          message.clientMessage = any_1.Any.fromPartial(object.clientMessage);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateClientResponse() {
      return {};
    }
    exports$1.MsgUpdateClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpgradeClient() {
      return {
        clientId: "",
        clientState: void 0,
        consensusState: void 0,
        proofUpgradeClient: new Uint8Array(),
        proofUpgradeConsensusState: new Uint8Array(),
        signer: ""
      };
    }
    exports$1.MsgUpgradeClient = {
      typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofUpgradeClient.length !== 0) {
          writer.uint32(34).bytes(message.proofUpgradeClient);
        }
        if (message.proofUpgradeConsensusState.length !== 0) {
          writer.uint32(42).bytes(message.proofUpgradeConsensusState);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofUpgradeClient = reader.bytes();
              break;
            case 5:
              message.proofUpgradeConsensusState = reader.bytes();
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpgradeClient();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proofUpgradeClient))
          obj.proofUpgradeClient = (0, helpers_1.bytesFromBase64)(object.proofUpgradeClient);
        if ((0, helpers_1.isSet)(object.proofUpgradeConsensusState))
          obj.proofUpgradeConsensusState = (0, helpers_1.bytesFromBase64)(object.proofUpgradeConsensusState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proofUpgradeClient !== void 0 && (obj.proofUpgradeClient = (0, helpers_1.base64FromBytes)(message.proofUpgradeClient !== void 0 ? message.proofUpgradeClient : new Uint8Array()));
        message.proofUpgradeConsensusState !== void 0 && (obj.proofUpgradeConsensusState = (0, helpers_1.base64FromBytes)(message.proofUpgradeConsensusState !== void 0 ? message.proofUpgradeConsensusState : new Uint8Array()));
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpgradeClient();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.proofUpgradeClient = object.proofUpgradeClient ?? new Uint8Array();
        message.proofUpgradeConsensusState = object.proofUpgradeConsensusState ?? new Uint8Array();
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgUpgradeClientResponse() {
      return {};
    }
    exports$1.MsgUpgradeClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpgradeClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpgradeClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpgradeClientResponse();
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviour() {
      return {
        clientId: "",
        misbehaviour: void 0,
        signer: ""
      };
    }
    exports$1.MsgSubmitMisbehaviour = {
      typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.misbehaviour !== void 0) {
          any_1.Any.encode(message.misbehaviour, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.misbehaviour = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.misbehaviour))
          obj.misbehaviour = any_1.Any.fromJSON(object.misbehaviour);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.misbehaviour !== void 0 && (obj.misbehaviour = message.misbehaviour ? any_1.Any.toJSON(message.misbehaviour) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.misbehaviour !== void 0 && object.misbehaviour !== null) {
          message.misbehaviour = any_1.Any.fromPartial(object.misbehaviour);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviourResponse() {
      return {};
    }
    exports$1.MsgSubmitMisbehaviourResponse = {
      typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviourResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviourResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSubmitMisbehaviourResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSubmitMisbehaviourResponse();
        return message;
      }
    };
    function createBaseMsgRecoverClient() {
      return {
        subjectClientId: "",
        substituteClientId: "",
        signer: ""
      };
    }
    exports$1.MsgRecoverClient = {
      typeUrl: "/ibc.core.client.v1.MsgRecoverClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.subjectClientId !== "") {
          writer.uint32(10).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(18).string(message.substituteClientId);
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.subjectClientId = reader.string();
              break;
            case 2:
              message.substituteClientId = reader.string();
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecoverClient();
        if ((0, helpers_1.isSet)(object.subjectClientId))
          obj.subjectClientId = String(object.subjectClientId);
        if ((0, helpers_1.isSet)(object.substituteClientId))
          obj.substituteClientId = String(object.substituteClientId);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecoverClient();
        message.subjectClientId = object.subjectClientId ?? "";
        message.substituteClientId = object.substituteClientId ?? "";
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgRecoverClientResponse() {
      return {};
    }
    exports$1.MsgRecoverClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgRecoverClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgRecoverClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRecoverClientResponse();
        return message;
      }
    };
    function createBaseMsgIBCSoftwareUpgrade() {
      return {
        plan: upgrade_1.Plan.fromPartial({}),
        upgradedClientState: void 0,
        signer: ""
      };
    }
    exports$1.MsgIBCSoftwareUpgrade = {
      typeUrl: "/ibc.core.client.v1.MsgIBCSoftwareUpgrade",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgrade();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 2:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgIBCSoftwareUpgrade();
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = upgrade_1.Plan.fromJSON(object.plan);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgIBCSoftwareUpgrade();
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = upgrade_1.Plan.fromPartial(object.plan);
        }
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgIBCSoftwareUpgradeResponse() {
      return {};
    }
    exports$1.MsgIBCSoftwareUpgradeResponse = {
      typeUrl: "/ibc.core.client.v1.MsgIBCSoftwareUpgradeResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgIBCSoftwareUpgradeResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams17() {
      return {
        signer: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports$1.MsgUpdateParams = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams17();
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams17();
        message.signer = object.signer ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse17() {
      return {};
    }
    exports$1.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse17();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse17();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateClient = this.CreateClient.bind(this);
        this.UpdateClient = this.UpdateClient.bind(this);
        this.UpgradeClient = this.UpgradeClient.bind(this);
        this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
        this.RecoverClient = this.RecoverClient.bind(this);
        this.IBCSoftwareUpgrade = this.IBCSoftwareUpgrade.bind(this);
        this.UpdateClientParams = this.UpdateClientParams.bind(this);
      }
      CreateClient(request) {
        const data2 = exports$1.MsgCreateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", data2);
        return promise.then((data3) => exports$1.MsgCreateClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateClient(request) {
        const data2 = exports$1.MsgUpdateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", data2);
        return promise.then((data3) => exports$1.MsgUpdateClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradeClient(request) {
        const data2 = exports$1.MsgUpgradeClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", data2);
        return promise.then((data3) => exports$1.MsgUpgradeClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SubmitMisbehaviour(request) {
        const data2 = exports$1.MsgSubmitMisbehaviour.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", data2);
        return promise.then((data3) => exports$1.MsgSubmitMisbehaviourResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RecoverClient(request) {
        const data2 = exports$1.MsgRecoverClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "RecoverClient", data2);
        return promise.then((data3) => exports$1.MsgRecoverClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      IBCSoftwareUpgrade(request) {
        const data2 = exports$1.MsgIBCSoftwareUpgrade.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "IBCSoftwareUpgrade", data2);
        return promise.then((data3) => exports$1.MsgIBCSoftwareUpgradeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateClientParams(request) {
        const data2 = exports$1.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClientParams", data2);
        return promise.then((data3) => exports$1.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/cosmjs-types/cosmos/ics23/v1/proofs.js
var require_proofs = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/ics23/v1/proofs.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CompressedNonExistenceProof = exports$1.CompressedExistenceProof = exports$1.CompressedBatchEntry = exports$1.CompressedBatchProof = exports$1.BatchEntry = exports$1.BatchProof = exports$1.InnerSpec = exports$1.ProofSpec = exports$1.InnerOp = exports$1.LeafOp = exports$1.CommitmentProof = exports$1.NonExistenceProof = exports$1.ExistenceProof = exports$1.lengthOpToJSON = exports$1.lengthOpFromJSON = exports$1.LengthOp = exports$1.hashOpToJSON = exports$1.hashOpFromJSON = exports$1.HashOp = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.ics23.v1";
    var HashOp;
    (function(HashOp2) {
      HashOp2[HashOp2["NO_HASH"] = 0] = "NO_HASH";
      HashOp2[HashOp2["SHA256"] = 1] = "SHA256";
      HashOp2[HashOp2["SHA512"] = 2] = "SHA512";
      HashOp2[HashOp2["KECCAK"] = 3] = "KECCAK";
      HashOp2[HashOp2["RIPEMD160"] = 4] = "RIPEMD160";
      HashOp2[HashOp2["BITCOIN"] = 5] = "BITCOIN";
      HashOp2[HashOp2["SHA512_256"] = 6] = "SHA512_256";
      HashOp2[HashOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(HashOp || (exports$1.HashOp = HashOp = {}));
    function hashOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_HASH":
          return HashOp.NO_HASH;
        case 1:
        case "SHA256":
          return HashOp.SHA256;
        case 2:
        case "SHA512":
          return HashOp.SHA512;
        case 3:
        case "KECCAK":
          return HashOp.KECCAK;
        case 4:
        case "RIPEMD160":
          return HashOp.RIPEMD160;
        case 5:
        case "BITCOIN":
          return HashOp.BITCOIN;
        case 6:
        case "SHA512_256":
          return HashOp.SHA512_256;
        case -1:
        case "UNRECOGNIZED":
        default:
          return HashOp.UNRECOGNIZED;
      }
    }
    exports$1.hashOpFromJSON = hashOpFromJSON;
    function hashOpToJSON(object) {
      switch (object) {
        case HashOp.NO_HASH:
          return "NO_HASH";
        case HashOp.SHA256:
          return "SHA256";
        case HashOp.SHA512:
          return "SHA512";
        case HashOp.KECCAK:
          return "KECCAK";
        case HashOp.RIPEMD160:
          return "RIPEMD160";
        case HashOp.BITCOIN:
          return "BITCOIN";
        case HashOp.SHA512_256:
          return "SHA512_256";
        case HashOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.hashOpToJSON = hashOpToJSON;
    var LengthOp;
    (function(LengthOp2) {
      LengthOp2[LengthOp2["NO_PREFIX"] = 0] = "NO_PREFIX";
      LengthOp2[LengthOp2["VAR_PROTO"] = 1] = "VAR_PROTO";
      LengthOp2[LengthOp2["VAR_RLP"] = 2] = "VAR_RLP";
      LengthOp2[LengthOp2["FIXED32_BIG"] = 3] = "FIXED32_BIG";
      LengthOp2[LengthOp2["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
      LengthOp2[LengthOp2["FIXED64_BIG"] = 5] = "FIXED64_BIG";
      LengthOp2[LengthOp2["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
      LengthOp2[LengthOp2["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
      LengthOp2[LengthOp2["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
      LengthOp2[LengthOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LengthOp || (exports$1.LengthOp = LengthOp = {}));
    function lengthOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_PREFIX":
          return LengthOp.NO_PREFIX;
        case 1:
        case "VAR_PROTO":
          return LengthOp.VAR_PROTO;
        case 2:
        case "VAR_RLP":
          return LengthOp.VAR_RLP;
        case 3:
        case "FIXED32_BIG":
          return LengthOp.FIXED32_BIG;
        case 4:
        case "FIXED32_LITTLE":
          return LengthOp.FIXED32_LITTLE;
        case 5:
        case "FIXED64_BIG":
          return LengthOp.FIXED64_BIG;
        case 6:
        case "FIXED64_LITTLE":
          return LengthOp.FIXED64_LITTLE;
        case 7:
        case "REQUIRE_32_BYTES":
          return LengthOp.REQUIRE_32_BYTES;
        case 8:
        case "REQUIRE_64_BYTES":
          return LengthOp.REQUIRE_64_BYTES;
        case -1:
        case "UNRECOGNIZED":
        default:
          return LengthOp.UNRECOGNIZED;
      }
    }
    exports$1.lengthOpFromJSON = lengthOpFromJSON;
    function lengthOpToJSON(object) {
      switch (object) {
        case LengthOp.NO_PREFIX:
          return "NO_PREFIX";
        case LengthOp.VAR_PROTO:
          return "VAR_PROTO";
        case LengthOp.VAR_RLP:
          return "VAR_RLP";
        case LengthOp.FIXED32_BIG:
          return "FIXED32_BIG";
        case LengthOp.FIXED32_LITTLE:
          return "FIXED32_LITTLE";
        case LengthOp.FIXED64_BIG:
          return "FIXED64_BIG";
        case LengthOp.FIXED64_LITTLE:
          return "FIXED64_LITTLE";
        case LengthOp.REQUIRE_32_BYTES:
          return "REQUIRE_32_BYTES";
        case LengthOp.REQUIRE_64_BYTES:
          return "REQUIRE_64_BYTES";
        case LengthOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.lengthOpToJSON = lengthOpToJSON;
    function createBaseExistenceProof() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: void 0,
        path: []
      };
    }
    exports$1.ExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.ExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports$1.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.path) {
          exports$1.InnerOp.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports$1.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              message.path.push(exports$1.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf))
          obj.leaf = exports$1.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object?.path))
          obj.path = object.path.map((e) => exports$1.InnerOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports$1.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => e ? exports$1.InnerOp.toJSON(e) : void 0);
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== void 0 && object.leaf !== null) {
          message.leaf = exports$1.LeafOp.fromPartial(object.leaf);
        }
        message.path = object.path?.map((e) => exports$1.InnerOp.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseNonExistenceProof() {
      return {
        key: new Uint8Array(),
        left: void 0,
        right: void 0
      };
    }
    exports$1.NonExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.NonExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports$1.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports$1.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports$1.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports$1.ExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left))
          obj.left = exports$1.ExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right))
          obj.right = exports$1.ExistenceProof.fromJSON(object.right);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports$1.ExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports$1.ExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== void 0 && object.left !== null) {
          message.left = exports$1.ExistenceProof.fromPartial(object.left);
        }
        if (object.right !== void 0 && object.right !== null) {
          message.right = exports$1.ExistenceProof.fromPartial(object.right);
        }
        return message;
      }
    };
    function createBaseCommitmentProof() {
      return {
        exist: void 0,
        nonexist: void 0,
        batch: void 0,
        compressed: void 0
      };
    }
    exports$1.CommitmentProof = {
      typeUrl: "/cosmos.ics23.v1.CommitmentProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports$1.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports$1.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        if (message.batch !== void 0) {
          exports$1.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();
        }
        if (message.compressed !== void 0) {
          exports$1.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitmentProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports$1.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports$1.NonExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.batch = exports$1.BatchProof.decode(reader, reader.uint32());
              break;
            case 4:
              message.compressed = exports$1.CompressedBatchProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitmentProof();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports$1.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports$1.NonExistenceProof.fromJSON(object.nonexist);
        if ((0, helpers_1.isSet)(object.batch))
          obj.batch = exports$1.BatchProof.fromJSON(object.batch);
        if ((0, helpers_1.isSet)(object.compressed))
          obj.compressed = exports$1.CompressedBatchProof.fromJSON(object.compressed);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports$1.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports$1.NonExistenceProof.toJSON(message.nonexist) : void 0);
        message.batch !== void 0 && (obj.batch = message.batch ? exports$1.BatchProof.toJSON(message.batch) : void 0);
        message.compressed !== void 0 && (obj.compressed = message.compressed ? exports$1.CompressedBatchProof.toJSON(message.compressed) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitmentProof();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports$1.ExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports$1.NonExistenceProof.fromPartial(object.nonexist);
        }
        if (object.batch !== void 0 && object.batch !== null) {
          message.batch = exports$1.BatchProof.fromPartial(object.batch);
        }
        if (object.compressed !== void 0 && object.compressed !== null) {
          message.compressed = exports$1.CompressedBatchProof.fromPartial(object.compressed);
        }
        return message;
      }
    };
    function createBaseLeafOp() {
      return {
        hash: 0,
        prehashKey: 0,
        prehashValue: 0,
        length: 0,
        prefix: new Uint8Array()
      };
    }
    exports$1.LeafOp = {
      typeUrl: "/cosmos.ics23.v1.LeafOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prehashKey !== 0) {
          writer.uint32(16).int32(message.prehashKey);
        }
        if (message.prehashValue !== 0) {
          writer.uint32(24).int32(message.prehashValue);
        }
        if (message.length !== 0) {
          writer.uint32(32).int32(message.length);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(42).bytes(message.prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLeafOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prehashKey = reader.int32();
              break;
            case 3:
              message.prehashValue = reader.int32();
              break;
            case 4:
              message.length = reader.int32();
              break;
            case 5:
              message.prefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLeafOp();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prehashKey))
          obj.prehashKey = hashOpFromJSON(object.prehashKey);
        if ((0, helpers_1.isSet)(object.prehashValue))
          obj.prehashValue = hashOpFromJSON(object.prehashValue);
        if ((0, helpers_1.isSet)(object.length))
          obj.length = lengthOpFromJSON(object.length);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prehashKey !== void 0 && (obj.prehashKey = hashOpToJSON(message.prehashKey));
        message.prehashValue !== void 0 && (obj.prehashValue = hashOpToJSON(message.prehashValue));
        message.length !== void 0 && (obj.length = lengthOpToJSON(message.length));
        message.prefix !== void 0 && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLeafOp();
        message.hash = object.hash ?? 0;
        message.prehashKey = object.prehashKey ?? 0;
        message.prehashValue = object.prehashValue ?? 0;
        message.length = object.length ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseInnerOp() {
      return {
        hash: 0,
        prefix: new Uint8Array(),
        suffix: new Uint8Array()
      };
    }
    exports$1.InnerOp = {
      typeUrl: "/cosmos.ics23.v1.InnerOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(18).bytes(message.prefix);
        }
        if (message.suffix.length !== 0) {
          writer.uint32(26).bytes(message.suffix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prefix = reader.bytes();
              break;
            case 3:
              message.suffix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInnerOp();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        if ((0, helpers_1.isSet)(object.suffix))
          obj.suffix = (0, helpers_1.bytesFromBase64)(object.suffix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prefix !== void 0 && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        message.suffix !== void 0 && (obj.suffix = (0, helpers_1.base64FromBytes)(message.suffix !== void 0 ? message.suffix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseInnerOp();
        message.hash = object.hash ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        message.suffix = object.suffix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProofSpec() {
      return {
        leafSpec: void 0,
        innerSpec: void 0,
        maxDepth: 0,
        minDepth: 0
      };
    }
    exports$1.ProofSpec = {
      typeUrl: "/cosmos.ics23.v1.ProofSpec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.leafSpec !== void 0) {
          exports$1.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();
        }
        if (message.innerSpec !== void 0) {
          exports$1.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxDepth !== 0) {
          writer.uint32(24).int32(message.maxDepth);
        }
        if (message.minDepth !== 0) {
          writer.uint32(32).int32(message.minDepth);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.leafSpec = exports$1.LeafOp.decode(reader, reader.uint32());
              break;
            case 2:
              message.innerSpec = exports$1.InnerSpec.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxDepth = reader.int32();
              break;
            case 4:
              message.minDepth = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofSpec();
        if ((0, helpers_1.isSet)(object.leafSpec))
          obj.leafSpec = exports$1.LeafOp.fromJSON(object.leafSpec);
        if ((0, helpers_1.isSet)(object.innerSpec))
          obj.innerSpec = exports$1.InnerSpec.fromJSON(object.innerSpec);
        if ((0, helpers_1.isSet)(object.maxDepth))
          obj.maxDepth = Number(object.maxDepth);
        if ((0, helpers_1.isSet)(object.minDepth))
          obj.minDepth = Number(object.minDepth);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.leafSpec !== void 0 && (obj.leafSpec = message.leafSpec ? exports$1.LeafOp.toJSON(message.leafSpec) : void 0);
        message.innerSpec !== void 0 && (obj.innerSpec = message.innerSpec ? exports$1.InnerSpec.toJSON(message.innerSpec) : void 0);
        message.maxDepth !== void 0 && (obj.maxDepth = Math.round(message.maxDepth));
        message.minDepth !== void 0 && (obj.minDepth = Math.round(message.minDepth));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofSpec();
        if (object.leafSpec !== void 0 && object.leafSpec !== null) {
          message.leafSpec = exports$1.LeafOp.fromPartial(object.leafSpec);
        }
        if (object.innerSpec !== void 0 && object.innerSpec !== null) {
          message.innerSpec = exports$1.InnerSpec.fromPartial(object.innerSpec);
        }
        message.maxDepth = object.maxDepth ?? 0;
        message.minDepth = object.minDepth ?? 0;
        return message;
      }
    };
    function createBaseInnerSpec() {
      return {
        childOrder: [],
        childSize: 0,
        minPrefixLength: 0,
        maxPrefixLength: 0,
        emptyChild: new Uint8Array(),
        hash: 0
      };
    }
    exports$1.InnerSpec = {
      typeUrl: "/cosmos.ics23.v1.InnerSpec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.childOrder) {
          writer.int32(v);
        }
        writer.ldelim();
        if (message.childSize !== 0) {
          writer.uint32(16).int32(message.childSize);
        }
        if (message.minPrefixLength !== 0) {
          writer.uint32(24).int32(message.minPrefixLength);
        }
        if (message.maxPrefixLength !== 0) {
          writer.uint32(32).int32(message.maxPrefixLength);
        }
        if (message.emptyChild.length !== 0) {
          writer.uint32(42).bytes(message.emptyChild);
        }
        if (message.hash !== 0) {
          writer.uint32(48).int32(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.childOrder.push(reader.int32());
                }
              } else {
                message.childOrder.push(reader.int32());
              }
              break;
            case 2:
              message.childSize = reader.int32();
              break;
            case 3:
              message.minPrefixLength = reader.int32();
              break;
            case 4:
              message.maxPrefixLength = reader.int32();
              break;
            case 5:
              message.emptyChild = reader.bytes();
              break;
            case 6:
              message.hash = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInnerSpec();
        if (Array.isArray(object?.childOrder))
          obj.childOrder = object.childOrder.map((e) => Number(e));
        if ((0, helpers_1.isSet)(object.childSize))
          obj.childSize = Number(object.childSize);
        if ((0, helpers_1.isSet)(object.minPrefixLength))
          obj.minPrefixLength = Number(object.minPrefixLength);
        if ((0, helpers_1.isSet)(object.maxPrefixLength))
          obj.maxPrefixLength = Number(object.maxPrefixLength);
        if ((0, helpers_1.isSet)(object.emptyChild))
          obj.emptyChild = (0, helpers_1.bytesFromBase64)(object.emptyChild);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.childOrder) {
          obj.childOrder = message.childOrder.map((e) => Math.round(e));
        } else {
          obj.childOrder = [];
        }
        message.childSize !== void 0 && (obj.childSize = Math.round(message.childSize));
        message.minPrefixLength !== void 0 && (obj.minPrefixLength = Math.round(message.minPrefixLength));
        message.maxPrefixLength !== void 0 && (obj.maxPrefixLength = Math.round(message.maxPrefixLength));
        message.emptyChild !== void 0 && (obj.emptyChild = (0, helpers_1.base64FromBytes)(message.emptyChild !== void 0 ? message.emptyChild : new Uint8Array()));
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseInnerSpec();
        message.childOrder = object.childOrder?.map((e) => e) || [];
        message.childSize = object.childSize ?? 0;
        message.minPrefixLength = object.minPrefixLength ?? 0;
        message.maxPrefixLength = object.maxPrefixLength ?? 0;
        message.emptyChild = object.emptyChild ?? new Uint8Array();
        message.hash = object.hash ?? 0;
        return message;
      }
    };
    function createBaseBatchProof() {
      return {
        entries: []
      };
    }
    exports$1.BatchProof = {
      typeUrl: "/cosmos.ics23.v1.BatchProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.entries) {
          exports$1.BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports$1.BatchEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBatchProof();
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports$1.BatchEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports$1.BatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBatchProof();
        message.entries = object.entries?.map((e) => exports$1.BatchEntry.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseBatchEntry() {
      return {
        exist: void 0,
        nonexist: void 0
      };
    }
    exports$1.BatchEntry = {
      typeUrl: "/cosmos.ics23.v1.BatchEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports$1.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports$1.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports$1.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports$1.NonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBatchEntry();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports$1.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports$1.NonExistenceProof.fromJSON(object.nonexist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports$1.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports$1.NonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBatchEntry();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports$1.ExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports$1.NonExistenceProof.fromPartial(object.nonexist);
        }
        return message;
      }
    };
    function createBaseCompressedBatchProof() {
      return {
        entries: [],
        lookupInners: []
      };
    }
    exports$1.CompressedBatchProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedBatchProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.entries) {
          exports$1.CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.lookupInners) {
          exports$1.InnerOp.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports$1.CompressedBatchEntry.decode(reader, reader.uint32()));
              break;
            case 2:
              message.lookupInners.push(exports$1.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedBatchProof();
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports$1.CompressedBatchEntry.fromJSON(e));
        if (Array.isArray(object?.lookupInners))
          obj.lookupInners = object.lookupInners.map((e) => exports$1.InnerOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports$1.CompressedBatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        if (message.lookupInners) {
          obj.lookupInners = message.lookupInners.map((e) => e ? exports$1.InnerOp.toJSON(e) : void 0);
        } else {
          obj.lookupInners = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedBatchProof();
        message.entries = object.entries?.map((e) => exports$1.CompressedBatchEntry.fromPartial(e)) || [];
        message.lookupInners = object.lookupInners?.map((e) => exports$1.InnerOp.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCompressedBatchEntry() {
      return {
        exist: void 0,
        nonexist: void 0
      };
    }
    exports$1.CompressedBatchEntry = {
      typeUrl: "/cosmos.ics23.v1.CompressedBatchEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports$1.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports$1.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports$1.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports$1.CompressedNonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedBatchEntry();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports$1.CompressedExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports$1.CompressedNonExistenceProof.fromJSON(object.nonexist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports$1.CompressedExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports$1.CompressedNonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedBatchEntry();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports$1.CompressedExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports$1.CompressedNonExistenceProof.fromPartial(object.nonexist);
        }
        return message;
      }
    };
    function createBaseCompressedExistenceProof() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: void 0,
        path: []
      };
    }
    exports$1.CompressedExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports$1.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.path) {
          writer.int32(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports$1.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.path.push(reader.int32());
                }
              } else {
                message.path.push(reader.int32());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf))
          obj.leaf = exports$1.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object?.path))
          obj.path = object.path.map((e) => Number(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports$1.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => Math.round(e));
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== void 0 && object.leaf !== null) {
          message.leaf = exports$1.LeafOp.fromPartial(object.leaf);
        }
        message.path = object.path?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseCompressedNonExistenceProof() {
      return {
        key: new Uint8Array(),
        left: void 0,
        right: void 0
      };
    }
    exports$1.CompressedNonExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedNonExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports$1.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports$1.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports$1.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports$1.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left))
          obj.left = exports$1.CompressedExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right))
          obj.right = exports$1.CompressedExistenceProof.fromJSON(object.right);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports$1.CompressedExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports$1.CompressedExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== void 0 && object.left !== null) {
          message.left = exports$1.CompressedExistenceProof.fromPartial(object.left);
        }
        if (object.right !== void 0 && object.right !== null) {
          message.right = exports$1.CompressedExistenceProof.fromPartial(object.right);
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js
var require_commitment = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MerkleProof = exports$1.MerklePath = exports$1.MerklePrefix = exports$1.MerkleRoot = exports$1.protobufPackage = void 0;
    var proofs_1 = require_proofs();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.commitment.v1";
    function createBaseMerkleRoot() {
      return {
        hash: new Uint8Array()
      };
    }
    exports$1.MerkleRoot = {
      typeUrl: "/ibc.core.commitment.v1.MerkleRoot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleRoot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerkleRoot();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerkleRoot();
        message.hash = object.hash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePrefix() {
      return {
        keyPrefix: new Uint8Array()
      };
    }
    exports$1.MerklePrefix = {
      typeUrl: "/ibc.core.commitment.v1.MerklePrefix",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.keyPrefix.length !== 0) {
          writer.uint32(10).bytes(message.keyPrefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePrefix();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPrefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerklePrefix();
        if ((0, helpers_1.isSet)(object.keyPrefix))
          obj.keyPrefix = (0, helpers_1.bytesFromBase64)(object.keyPrefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.keyPrefix !== void 0 && (obj.keyPrefix = (0, helpers_1.base64FromBytes)(message.keyPrefix !== void 0 ? message.keyPrefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerklePrefix();
        message.keyPrefix = object.keyPrefix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePath() {
      return {
        keyPath: []
      };
    }
    exports$1.MerklePath = {
      typeUrl: "/ibc.core.commitment.v1.MerklePath",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.keyPath) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePath();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPath.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerklePath();
        if (Array.isArray(object?.keyPath))
          obj.keyPath = object.keyPath.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.keyPath) {
          obj.keyPath = message.keyPath.map((e) => e);
        } else {
          obj.keyPath = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerklePath();
        message.keyPath = object.keyPath?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMerkleProof() {
      return {
        proofs: []
      };
    }
    exports$1.MerkleProof = {
      typeUrl: "/ibc.core.commitment.v1.MerkleProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.proofs) {
          proofs_1.CommitmentProof.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proofs.push(proofs_1.CommitmentProof.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerkleProof();
        if (Array.isArray(object?.proofs))
          obj.proofs = object.proofs.map((e) => proofs_1.CommitmentProof.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.proofs) {
          obj.proofs = message.proofs.map((e) => e ? proofs_1.CommitmentProof.toJSON(e) : void 0);
        } else {
          obj.proofs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerkleProof();
        message.proofs = object.proofs?.map((e) => proofs_1.CommitmentProof.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/ibc/core/connection/v1/connection.js
var require_connection = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/connection/v1/connection.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = exports$1.Version = exports$1.ConnectionPaths = exports$1.ClientPaths = exports$1.Counterparty = exports$1.IdentifiedConnection = exports$1.ConnectionEnd = exports$1.stateToJSON = exports$1.stateFromJSON = exports$1.State = exports$1.protobufPackage = void 0;
    var commitment_1 = require_commitment();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.connection.v1";
    var State3;
    (function(State4) {
      State4[State4["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State4[State4["STATE_INIT"] = 1] = "STATE_INIT";
      State4[State4["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State4[State4["STATE_OPEN"] = 3] = "STATE_OPEN";
      State4[State4["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State3 || (exports$1.State = State3 = {}));
    function stateFromJSON3(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State3.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State3.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State3.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State3.STATE_OPEN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State3.UNRECOGNIZED;
      }
    }
    exports$1.stateFromJSON = stateFromJSON3;
    function stateToJSON3(object) {
      switch (object) {
        case State3.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State3.STATE_INIT:
          return "STATE_INIT";
        case State3.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State3.STATE_OPEN:
          return "STATE_OPEN";
        case State3.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.stateToJSON = stateToJSON3;
    function createBaseConnectionEnd() {
      return {
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports$1.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
      };
    }
    exports$1.ConnectionEnd = {
      typeUrl: "/ibc.core.connection.v1.ConnectionEnd",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.versions) {
          exports$1.Version.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(24).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports$1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionEnd();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.versions.push(exports$1.Version.decode(reader, reader.uint32()));
              break;
            case 3:
              message.state = reader.int32();
              break;
            case 4:
              message.counterparty = exports$1.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConnectionEnd();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object?.versions))
          obj.versions = object.versions.map((e) => exports$1.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON3(object.state);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports$1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports$1.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON3(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports$1.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConnectionEnd();
        message.clientId = object.clientId ?? "";
        message.versions = object.versions?.map((e) => exports$1.Version.fromPartial(e)) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports$1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        return message;
      }
    };
    function createBaseIdentifiedConnection() {
      return {
        id: "",
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports$1.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
      };
    }
    exports$1.IdentifiedConnection = {
      typeUrl: "/ibc.core.connection.v1.IdentifiedConnection",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        for (const v of message.versions) {
          exports$1.Version.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(32).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports$1.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(48).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedConnection();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.versions.push(exports$1.Version.decode(reader, reader.uint32()));
              break;
            case 4:
              message.state = reader.int32();
              break;
            case 5:
              message.counterparty = exports$1.Counterparty.decode(reader, reader.uint32());
              break;
            case 6:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedConnection();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = String(object.id);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object?.versions))
          obj.versions = object.versions.map((e) => exports$1.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON3(object.state);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports$1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports$1.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON3(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports$1.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIdentifiedConnection();
        message.id = object.id ?? "";
        message.clientId = object.clientId ?? "";
        message.versions = object.versions?.map((e) => exports$1.Version.fromPartial(e)) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports$1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        return message;
      }
    };
    function createBaseCounterparty() {
      return {
        clientId: "",
        connectionId: "",
        prefix: commitment_1.MerklePrefix.fromPartial({})
      };
    }
    exports$1.Counterparty = {
      typeUrl: "/ibc.core.connection.v1.Counterparty",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.connectionId !== "") {
          writer.uint32(18).string(message.connectionId);
        }
        if (message.prefix !== void 0) {
          commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.connectionId = reader.string();
              break;
            case 3:
              message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = commitment_1.MerklePrefix.fromJSON(object.prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.prefix !== void 0 && (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCounterparty();
        message.clientId = object.clientId ?? "";
        message.connectionId = object.connectionId ?? "";
        if (object.prefix !== void 0 && object.prefix !== null) {
          message.prefix = commitment_1.MerklePrefix.fromPartial(object.prefix);
        }
        return message;
      }
    };
    function createBaseClientPaths() {
      return {
        paths: []
      };
    }
    exports$1.ClientPaths = {
      typeUrl: "/ibc.core.connection.v1.ClientPaths",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.paths) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientPaths();
        if (Array.isArray(object?.paths))
          obj.paths = object.paths.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientPaths();
        message.paths = object.paths?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseConnectionPaths() {
      return {
        clientId: "",
        paths: []
      };
    }
    exports$1.ConnectionPaths = {
      typeUrl: "/ibc.core.connection.v1.ConnectionPaths",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.paths) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConnectionPaths();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object?.paths))
          obj.paths = object.paths.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConnectionPaths();
        message.clientId = object.clientId ?? "";
        message.paths = object.paths?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseVersion() {
      return {
        identifier: "",
        features: []
      };
    }
    exports$1.Version = {
      typeUrl: "/ibc.core.connection.v1.Version",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifier !== "") {
          writer.uint32(10).string(message.identifier);
        }
        for (const v of message.features) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifier = reader.string();
              break;
            case 2:
              message.features.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVersion();
        if ((0, helpers_1.isSet)(object.identifier))
          obj.identifier = String(object.identifier);
        if (Array.isArray(object?.features))
          obj.features = object.features.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifier !== void 0 && (obj.identifier = message.identifier);
        if (message.features) {
          obj.features = message.features.map((e) => e);
        } else {
          obj.features = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVersion();
        message.identifier = object.identifier ?? "";
        message.features = object.features?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseParams15() {
      return {
        maxExpectedTimePerBlock: BigInt(0)
      };
    }
    exports$1.Params = {
      typeUrl: "/ibc.core.connection.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxExpectedTimePerBlock !== BigInt(0)) {
          writer.uint32(8).uint64(message.maxExpectedTimePerBlock);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxExpectedTimePerBlock = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if ((0, helpers_1.isSet)(object.maxExpectedTimePerBlock))
          obj.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxExpectedTimePerBlock !== void 0 && (obj.maxExpectedTimePerBlock = (message.maxExpectedTimePerBlock || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        if (object.maxExpectedTimePerBlock !== void 0 && object.maxExpectedTimePerBlock !== null) {
          message.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/ibc/core/connection/v1/tx.js
var require_tx12 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/connection/v1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgUpdateParamsResponse = exports$1.MsgUpdateParams = exports$1.MsgConnectionOpenConfirmResponse = exports$1.MsgConnectionOpenConfirm = exports$1.MsgConnectionOpenAckResponse = exports$1.MsgConnectionOpenAck = exports$1.MsgConnectionOpenTryResponse = exports$1.MsgConnectionOpenTry = exports$1.MsgConnectionOpenInitResponse = exports$1.MsgConnectionOpenInit = exports$1.protobufPackage = void 0;
    var connection_1 = require_connection();
    var any_1 = require_any();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.connection.v1";
    function createBaseMsgConnectionOpenInit() {
      return {
        clientId: "",
        counterparty: connection_1.Counterparty.fromPartial({}),
        version: void 0,
        delayPeriod: BigInt(0),
        signer: ""
      };
    }
    exports$1.MsgConnectionOpenInit = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(32).uint64(message.delayPeriod);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.delayPeriod = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenInit();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenInit();
        message.clientId = object.clientId ?? "";
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.version !== void 0 && object.version !== null) {
          message.version = connection_1.Version.fromPartial(object.version);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenInitResponse() {
      return {};
    }
    exports$1.MsgConnectionOpenInitResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInitResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenInitResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenInitResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenTry() {
      return {
        clientId: "",
        previousConnectionId: "",
        clientState: void 0,
        counterparty: connection_1.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0),
        counterpartyVersions: [],
        proofHeight: client_1.Height.fromPartial({}),
        proofInit: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
      };
    }
    exports$1.MsgConnectionOpenTry = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.previousConnectionId !== "") {
          writer.uint32(18).string(message.previousConnectionId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        for (const v of message.counterpartyVersions) {
          connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(66).bytes(message.proofInit);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(74).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(82).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(98).string(message.signer);
        }
        if (message.hostConsensusStateProof.length !== 0) {
          writer.uint32(106).bytes(message.hostConsensusStateProof);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.previousConnectionId = reader.string();
              break;
            case 3:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            case 6:
              message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));
              break;
            case 7:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofInit = reader.bytes();
              break;
            case 9:
              message.proofClient = reader.bytes();
              break;
            case 10:
              message.proofConsensus = reader.bytes();
              break;
            case 11:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 12:
              message.signer = reader.string();
              break;
            case 13:
              message.hostConsensusStateProof = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenTry();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.previousConnectionId))
          obj.previousConnectionId = String(object.previousConnectionId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if (Array.isArray(object?.counterpartyVersions))
          obj.counterpartyVersions = object.counterpartyVersions.map((e) => connection_1.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofClient))
          obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus))
          obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight))
          obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof))
          obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.previousConnectionId !== void 0 && (obj.previousConnectionId = message.previousConnectionId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        if (message.counterpartyVersions) {
          obj.counterpartyVersions = message.counterpartyVersions.map((e) => e ? connection_1.Version.toJSON(e) : void 0);
        } else {
          obj.counterpartyVersions = [];
        }
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.hostConsensusStateProof !== void 0 && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== void 0 ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenTry();
        message.clientId = object.clientId ?? "";
        message.previousConnectionId = object.previousConnectionId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        message.counterpartyVersions = object.counterpartyVersions?.map((e) => connection_1.Version.fromPartial(e)) || [];
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.proofInit = object.proofInit ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== void 0 && object.consensusHeight !== null) {
          message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        }
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgConnectionOpenTryResponse() {
      return {};
    }
    exports$1.MsgConnectionOpenTryResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTryResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenTryResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenTryResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenAck() {
      return {
        connectionId: "",
        counterpartyConnectionId: "",
        version: void 0,
        clientState: void 0,
        proofHeight: client_1.Height.fromPartial({}),
        proofTry: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
      };
    }
    exports$1.MsgConnectionOpenAck = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.counterpartyConnectionId !== "") {
          writer.uint32(18).string(message.counterpartyConnectionId);
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(50).bytes(message.proofTry);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(58).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(66).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(82).string(message.signer);
        }
        if (message.hostConsensusStateProof.length !== 0) {
          writer.uint32(90).bytes(message.hostConsensusStateProof);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.counterpartyConnectionId = reader.string();
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.proofTry = reader.bytes();
              break;
            case 7:
              message.proofClient = reader.bytes();
              break;
            case 8:
              message.proofConsensus = reader.bytes();
              break;
            case 9:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 10:
              message.signer = reader.string();
              break;
            case 11:
              message.hostConsensusStateProof = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenAck();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.counterpartyConnectionId))
          obj.counterpartyConnectionId = String(object.counterpartyConnectionId);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofTry))
          obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofClient))
          obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus))
          obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight))
          obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof))
          obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.counterpartyConnectionId !== void 0 && (obj.counterpartyConnectionId = message.counterpartyConnectionId);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofTry !== void 0 && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.hostConsensusStateProof !== void 0 && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== void 0 ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenAck();
        message.connectionId = object.connectionId ?? "";
        message.counterpartyConnectionId = object.counterpartyConnectionId ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = connection_1.Version.fromPartial(object.version);
        }
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.proofTry = object.proofTry ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== void 0 && object.consensusHeight !== null) {
          message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        }
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgConnectionOpenAckResponse() {
      return {};
    }
    exports$1.MsgConnectionOpenAckResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAckResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenAckResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirm() {
      return {
        connectionId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports$1.MsgConnectionOpenConfirm = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(18).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.proofAck = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenConfirm();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.proofAck))
          obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.proofAck !== void 0 && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenConfirm();
        message.connectionId = object.connectionId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirmResponse() {
      return {};
    }
    exports$1.MsgConnectionOpenConfirmResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirmResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenConfirmResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenConfirmResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams17() {
      return {
        signer: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports$1.MsgUpdateParams = {
      typeUrl: "/ibc.core.connection.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams17();
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams17();
        message.signer = object.signer ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse17() {
      return {};
    }
    exports$1.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse17();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse17();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this);
        this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this);
        this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this);
        this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
        this.UpdateConnectionParams = this.UpdateConnectionParams.bind(this);
      }
      ConnectionOpenInit(request) {
        const data2 = exports$1.MsgConnectionOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", data2);
        return promise.then((data3) => exports$1.MsgConnectionOpenInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionOpenTry(request) {
        const data2 = exports$1.MsgConnectionOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", data2);
        return promise.then((data3) => exports$1.MsgConnectionOpenTryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionOpenAck(request) {
        const data2 = exports$1.MsgConnectionOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", data2);
        return promise.then((data3) => exports$1.MsgConnectionOpenAckResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionOpenConfirm(request) {
        const data2 = exports$1.MsgConnectionOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", data2);
        return promise.then((data3) => exports$1.MsgConnectionOpenConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateConnectionParams(request) {
        const data2 = exports$1.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "UpdateConnectionParams", data2);
        return promise.then((data3) => exports$1.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/ibc/messages.js
var require_messages7 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/ibc/messages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ibcTypes = void 0;
    exports$1.isMsgTransferEncodeObject = isMsgTransferEncodeObject;
    var tx_1 = require_tx9();
    var tx_2 = require_tx10();
    var tx_3 = require_tx11();
    var tx_4 = require_tx12();
    exports$1.ibcTypes = [
      ["/ibc.applications.transfer.v1.MsgTransfer", tx_1.MsgTransfer],
      ["/ibc.core.channel.v1.MsgAcknowledgement", tx_2.MsgAcknowledgement],
      ["/ibc.core.channel.v1.MsgChannelCloseConfirm", tx_2.MsgChannelCloseConfirm],
      ["/ibc.core.channel.v1.MsgChannelCloseInit", tx_2.MsgChannelCloseInit],
      ["/ibc.core.channel.v1.MsgChannelOpenAck", tx_2.MsgChannelOpenAck],
      ["/ibc.core.channel.v1.MsgChannelOpenConfirm", tx_2.MsgChannelOpenConfirm],
      ["/ibc.core.channel.v1.MsgChannelOpenInit", tx_2.MsgChannelOpenInit],
      ["/ibc.core.channel.v1.MsgChannelOpenTry", tx_2.MsgChannelOpenTry],
      ["/ibc.core.channel.v1.MsgRecvPacket", tx_2.MsgRecvPacket],
      ["/ibc.core.channel.v1.MsgTimeout", tx_2.MsgTimeout],
      ["/ibc.core.channel.v1.MsgTimeoutOnClose", tx_2.MsgTimeoutOnClose],
      ["/ibc.core.client.v1.MsgCreateClient", tx_3.MsgCreateClient],
      ["/ibc.core.client.v1.MsgSubmitMisbehaviour", tx_3.MsgSubmitMisbehaviour],
      ["/ibc.core.client.v1.MsgUpdateClient", tx_3.MsgUpdateClient],
      ["/ibc.core.client.v1.MsgUpgradeClient", tx_3.MsgUpgradeClient],
      ["/ibc.core.connection.v1.MsgConnectionOpenAck", tx_4.MsgConnectionOpenAck],
      ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", tx_4.MsgConnectionOpenConfirm],
      ["/ibc.core.connection.v1.MsgConnectionOpenInit", tx_4.MsgConnectionOpenInit],
      ["/ibc.core.connection.v1.MsgConnectionOpenTry", tx_4.MsgConnectionOpenTry]
    ];
    function isMsgTransferEncodeObject(object) {
      return object.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js
var require_transfer = __commonJS({
  "../../node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = exports$1.DenomTrace = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseDenomTrace() {
      return {
        path: "",
        baseDenom: ""
      };
    }
    exports$1.DenomTrace = {
      typeUrl: "/ibc.applications.transfer.v1.DenomTrace",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.path !== "") {
          writer.uint32(10).string(message.path);
        }
        if (message.baseDenom !== "") {
          writer.uint32(18).string(message.baseDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomTrace();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.path = reader.string();
              break;
            case 2:
              message.baseDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomTrace();
        if ((0, helpers_1.isSet)(object.path))
          obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.baseDenom))
          obj.baseDenom = String(object.baseDenom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.path !== void 0 && (obj.path = message.path);
        message.baseDenom !== void 0 && (obj.baseDenom = message.baseDenom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDenomTrace();
        message.path = object.path ?? "";
        message.baseDenom = object.baseDenom ?? "";
        return message;
      }
    };
    function createBaseParams15() {
      return {
        sendEnabled: false,
        receiveEnabled: false
      };
    }
    exports$1.Params = {
      typeUrl: "/ibc.applications.transfer.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sendEnabled === true) {
          writer.uint32(8).bool(message.sendEnabled);
        }
        if (message.receiveEnabled === true) {
          writer.uint32(16).bool(message.receiveEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled = reader.bool();
              break;
            case 2:
              message.receiveEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if ((0, helpers_1.isSet)(object.sendEnabled))
          obj.sendEnabled = Boolean(object.sendEnabled);
        if ((0, helpers_1.isSet)(object.receiveEnabled))
          obj.receiveEnabled = Boolean(object.receiveEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sendEnabled !== void 0 && (obj.sendEnabled = message.sendEnabled);
        message.receiveEnabled !== void 0 && (obj.receiveEnabled = message.receiveEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        message.sendEnabled = object.sendEnabled ?? false;
        message.receiveEnabled = object.receiveEnabled ?? false;
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js
var require_query7 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryTotalEscrowForDenomResponse = exports$1.QueryTotalEscrowForDenomRequest = exports$1.QueryEscrowAddressResponse = exports$1.QueryEscrowAddressRequest = exports$1.QueryDenomHashResponse = exports$1.QueryDenomHashRequest = exports$1.QueryParamsResponse = exports$1.QueryParamsRequest = exports$1.QueryDenomTracesResponse = exports$1.QueryDenomTracesRequest = exports$1.QueryDenomTraceResponse = exports$1.QueryDenomTraceRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var transfer_1 = require_transfer();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseQueryDenomTraceRequest() {
      return {
        hash: ""
      };
    }
    exports$1.QueryDenomTraceRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTraceRequest();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTraceRequest();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseQueryDenomTraceResponse() {
      return {
        denomTrace: void 0
      };
    }
    exports$1.QueryDenomTraceResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denomTrace !== void 0) {
          transfer_1.DenomTrace.encode(message.denomTrace, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTrace = transfer_1.DenomTrace.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTraceResponse();
        if ((0, helpers_1.isSet)(object.denomTrace))
          obj.denomTrace = transfer_1.DenomTrace.fromJSON(object.denomTrace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denomTrace !== void 0 && (obj.denomTrace = message.denomTrace ? transfer_1.DenomTrace.toJSON(message.denomTrace) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTraceResponse();
        if (object.denomTrace !== void 0 && object.denomTrace !== null) {
          message.denomTrace = transfer_1.DenomTrace.fromPartial(object.denomTrace);
        }
        return message;
      }
    };
    function createBaseQueryDenomTracesRequest() {
      return {
        pagination: void 0
      };
    }
    exports$1.QueryDenomTracesRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTracesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTracesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomTracesResponse() {
      return {
        denomTraces: [],
        pagination: void 0
      };
    }
    exports$1.QueryDenomTracesResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomTraces) {
          transfer_1.DenomTrace.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTraces.push(transfer_1.DenomTrace.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTracesResponse();
        if (Array.isArray(object?.denomTraces))
          obj.denomTraces = object.denomTraces.map((e) => transfer_1.DenomTrace.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomTraces) {
          obj.denomTraces = message.denomTraces.map((e) => e ? transfer_1.DenomTrace.toJSON(e) : void 0);
        } else {
          obj.denomTraces = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTracesResponse();
        message.denomTraces = object.denomTraces?.map((e) => transfer_1.DenomTrace.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest18() {
      return {};
    }
    exports$1.QueryParamsRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest18();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest18();
        return message;
      }
    };
    function createBaseQueryParamsResponse18() {
      return {
        params: void 0
      };
    }
    exports$1.QueryParamsResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          transfer_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = transfer_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse18();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = transfer_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? transfer_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse18();
        if (object.params !== void 0 && object.params !== null) {
          message.params = transfer_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryDenomHashRequest() {
      return {
        trace: ""
      };
    }
    exports$1.QueryDenomHashRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.trace !== "") {
          writer.uint32(10).string(message.trace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.trace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomHashRequest();
        if ((0, helpers_1.isSet)(object.trace))
          obj.trace = String(object.trace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.trace !== void 0 && (obj.trace = message.trace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomHashRequest();
        message.trace = object.trace ?? "";
        return message;
      }
    };
    function createBaseQueryDenomHashResponse() {
      return {
        hash: ""
      };
    }
    exports$1.QueryDenomHashResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomHashResponse();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomHashResponse();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseQueryEscrowAddressRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports$1.QueryEscrowAddressRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryEscrowAddressRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryEscrowAddressRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryEscrowAddressResponse() {
      return {
        escrowAddress: ""
      };
    }
    exports$1.QueryEscrowAddressResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.escrowAddress !== "") {
          writer.uint32(10).string(message.escrowAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.escrowAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryEscrowAddressResponse();
        if ((0, helpers_1.isSet)(object.escrowAddress))
          obj.escrowAddress = String(object.escrowAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.escrowAddress !== void 0 && (obj.escrowAddress = message.escrowAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryEscrowAddressResponse();
        message.escrowAddress = object.escrowAddress ?? "";
        return message;
      }
    };
    function createBaseQueryTotalEscrowForDenomRequest() {
      return {
        denom: ""
      };
    }
    exports$1.QueryTotalEscrowForDenomRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryTotalEscrowForDenomRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalEscrowForDenomRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalEscrowForDenomRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalEscrowForDenomRequest();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryTotalEscrowForDenomResponse() {
      return {
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports$1.QueryTotalEscrowForDenomResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalEscrowForDenomResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalEscrowForDenomResponse();
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalEscrowForDenomResponse();
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.DenomTraces = this.DenomTraces.bind(this);
        this.DenomTrace = this.DenomTrace.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomHash = this.DenomHash.bind(this);
        this.EscrowAddress = this.EscrowAddress.bind(this);
        this.TotalEscrowForDenom = this.TotalEscrowForDenom.bind(this);
      }
      DenomTraces(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports$1.QueryDenomTracesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", data2);
        return promise.then((data3) => exports$1.QueryDenomTracesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomTrace(request) {
        const data2 = exports$1.QueryDenomTraceRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", data2);
        return promise.then((data3) => exports$1.QueryDenomTraceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports$1.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "Params", data2);
        return promise.then((data3) => exports$1.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomHash(request) {
        const data2 = exports$1.QueryDenomHashRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", data2);
        return promise.then((data3) => exports$1.QueryDenomHashResponse.decode(new binary_1.BinaryReader(data3)));
      }
      EscrowAddress(request) {
        const data2 = exports$1.QueryEscrowAddressRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", data2);
        return promise.then((data3) => exports$1.QueryEscrowAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TotalEscrowForDenom(request) {
        const data2 = exports$1.QueryTotalEscrowForDenomRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "TotalEscrowForDenom", data2);
        return promise.then((data3) => exports$1.QueryTotalEscrowForDenomResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/cosmjs-types/ibc/core/channel/v1/query.js
var require_query8 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/channel/v1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryChannelParamsResponse = exports$1.QueryChannelParamsRequest = exports$1.QueryUpgradeResponse = exports$1.QueryUpgradeRequest = exports$1.QueryUpgradeErrorResponse = exports$1.QueryUpgradeErrorRequest = exports$1.QueryNextSequenceSendResponse = exports$1.QueryNextSequenceSendRequest = exports$1.QueryNextSequenceReceiveResponse = exports$1.QueryNextSequenceReceiveRequest = exports$1.QueryUnreceivedAcksResponse = exports$1.QueryUnreceivedAcksRequest = exports$1.QueryUnreceivedPacketsResponse = exports$1.QueryUnreceivedPacketsRequest = exports$1.QueryPacketAcknowledgementsResponse = exports$1.QueryPacketAcknowledgementsRequest = exports$1.QueryPacketAcknowledgementResponse = exports$1.QueryPacketAcknowledgementRequest = exports$1.QueryPacketReceiptResponse = exports$1.QueryPacketReceiptRequest = exports$1.QueryPacketCommitmentsResponse = exports$1.QueryPacketCommitmentsRequest = exports$1.QueryPacketCommitmentResponse = exports$1.QueryPacketCommitmentRequest = exports$1.QueryChannelConsensusStateResponse = exports$1.QueryChannelConsensusStateRequest = exports$1.QueryChannelClientStateResponse = exports$1.QueryChannelClientStateRequest = exports$1.QueryConnectionChannelsResponse = exports$1.QueryConnectionChannelsRequest = exports$1.QueryChannelsResponse = exports$1.QueryChannelsRequest = exports$1.QueryChannelResponse = exports$1.QueryChannelRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var channel_1 = require_channel();
    var client_1 = require_client();
    var any_1 = require_any();
    var upgrade_1 = require_upgrade2();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.channel.v1";
    function createBaseQueryChannelRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports$1.QueryChannelRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryChannelResponse() {
      return {
        channel: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryChannelResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelResponse();
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelResponse();
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelsRequest() {
      return {
        pagination: void 0
      };
    }
    exports$1.QueryChannelsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryChannelsResponse() {
      return {
        channels: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryChannelsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelsResponse();
        if (Array.isArray(object?.channels))
          obj.channels = object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelsResponse();
        message.channels = object.channels?.map((e) => channel_1.IdentifiedChannel.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryConnectionChannelsRequest() {
      return {
        connection: "",
        pagination: void 0
      };
    }
    exports$1.QueryConnectionChannelsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== "") {
          writer.uint32(10).string(message.connection);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionChannelsRequest();
        if ((0, helpers_1.isSet)(object.connection))
          obj.connection = String(object.connection);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionChannelsRequest();
        message.connection = object.connection ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConnectionChannelsResponse() {
      return {
        channels: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryConnectionChannelsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionChannelsResponse();
        if (Array.isArray(object?.channels))
          obj.channels = object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionChannelsResponse();
        message.channels = object.channels?.map((e) => channel_1.IdentifiedChannel.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryChannelClientStateRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports$1.QueryChannelClientStateRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelClientStateRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelClientStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryChannelClientStateResponse() {
      return {
        identifiedClientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryChannelClientStateResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState))
          obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelClientStateResponse();
        if (object.identifiedClientState !== void 0 && object.identifiedClientState !== null) {
          message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateRequest() {
      return {
        portId: "",
        channelId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports$1.QueryChannelConsensusStateRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(32).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.revisionNumber = reader.uint64();
              break;
            case 4:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelConsensusStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateResponse() {
      return {
        consensusState: void 0,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryChannelConsensusStateResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports$1.QueryPacketCommitmentRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentResponse() {
      return {
        commitment: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryPacketCommitmentResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commitment.length !== 0) {
          writer.uint32(10).bytes(message.commitment);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitment = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentResponse();
        if ((0, helpers_1.isSet)(object.commitment))
          obj.commitment = (0, helpers_1.bytesFromBase64)(object.commitment);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commitment !== void 0 && (obj.commitment = (0, helpers_1.base64FromBytes)(message.commitment !== void 0 ? message.commitment : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentResponse();
        message.commitment = object.commitment ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsRequest() {
      return {
        portId: "",
        channelId: "",
        pagination: void 0
      };
    }
    exports$1.QueryPacketCommitmentsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsResponse() {
      return {
        commitments: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryPacketCommitmentsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.commitments) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitments.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentsResponse();
        if (Array.isArray(object?.commitments))
          obj.commitments = object.commitments.map((e) => channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.commitments) {
          obj.commitments = message.commitments.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.commitments = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentsResponse();
        message.commitments = object.commitments?.map((e) => channel_1.PacketState.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryPacketReceiptRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports$1.QueryPacketReceiptRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketReceiptRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketReceiptRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketReceiptResponse() {
      return {
        received: false,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryPacketReceiptResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.received === true) {
          writer.uint32(16).bool(message.received);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.received = reader.bool();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketReceiptResponse();
        if ((0, helpers_1.isSet)(object.received))
          obj.received = Boolean(object.received);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.received !== void 0 && (obj.received = message.received);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketReceiptResponse();
        message.received = object.received ?? false;
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports$1.QueryPacketAcknowledgementRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementResponse() {
      return {
        acknowledgement: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryPacketAcknowledgementResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.acknowledgement.length !== 0) {
          writer.uint32(10).bytes(message.acknowledgement);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgement = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.acknowledgement))
          obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.acknowledgement !== void 0 && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementResponse();
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsRequest() {
      return {
        portId: "",
        channelId: "",
        pagination: void 0,
        packetCommitmentSequences: []
      };
    }
    exports$1.QueryPacketAcknowledgementsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.packetCommitmentSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if (Array.isArray(object?.packetCommitmentSequences))
          obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.packetCommitmentSequences = object.packetCommitmentSequences?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsResponse() {
      return {
        acknowledgements: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryPacketAcknowledgementsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.acknowledgements) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgements.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementsResponse();
        if (Array.isArray(object?.acknowledgements))
          obj.acknowledgements = object.acknowledgements.map((e) => channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.acknowledgements) {
          obj.acknowledgements = message.acknowledgements.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.acknowledgements = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementsResponse();
        message.acknowledgements = object.acknowledgements?.map((e) => channel_1.PacketState.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsRequest() {
      return {
        portId: "",
        channelId: "",
        packetCommitmentSequences: []
      };
    }
    exports$1.QueryUnreceivedPacketsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetCommitmentSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedPacketsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object?.packetCommitmentSequences))
          obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnreceivedPacketsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetCommitmentSequences = object.packetCommitmentSequences?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsResponse() {
      return {
        sequences: [],
        height: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryUnreceivedPacketsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedPacketsResponse();
        if (Array.isArray(object?.sequences))
          obj.sequences = object.sequences.map((e) => BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnreceivedPacketsResponse();
        message.sequences = object.sequences?.map((e) => BigInt(e.toString())) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksRequest() {
      return {
        portId: "",
        channelId: "",
        packetAckSequences: []
      };
    }
    exports$1.QueryUnreceivedAcksRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetAckSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetAckSequences.push(reader.uint64());
                }
              } else {
                message.packetAckSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedAcksRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object?.packetAckSequences))
          obj.packetAckSequences = object.packetAckSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetAckSequences) {
          obj.packetAckSequences = message.packetAckSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetAckSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnreceivedAcksRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetAckSequences = object.packetAckSequences?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksResponse() {
      return {
        sequences: [],
        height: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryUnreceivedAcksResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedAcksResponse();
        if (Array.isArray(object?.sequences))
          obj.sequences = object.sequences.map((e) => BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnreceivedAcksResponse();
        message.sequences = object.sequences?.map((e) => BigInt(e.toString())) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports$1.QueryNextSequenceReceiveRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceReceiveRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceReceiveRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveResponse() {
      return {
        nextSequenceReceive: BigInt(0),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryNextSequenceReceiveResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextSequenceReceive !== BigInt(0)) {
          writer.uint32(8).uint64(message.nextSequenceReceive);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextSequenceReceive = reader.uint64();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceReceiveResponse();
        if ((0, helpers_1.isSet)(object.nextSequenceReceive))
          obj.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextSequenceReceive !== void 0 && (obj.nextSequenceReceive = (message.nextSequenceReceive || BigInt(0)).toString());
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceReceiveResponse();
        if (object.nextSequenceReceive !== void 0 && object.nextSequenceReceive !== null) {
          message.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryNextSequenceSendRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports$1.QueryNextSequenceSendRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceSendRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceSendRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceSendRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryNextSequenceSendResponse() {
      return {
        nextSequenceSend: BigInt(0),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryNextSequenceSendResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextSequenceSend !== BigInt(0)) {
          writer.uint32(8).uint64(message.nextSequenceSend);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextSequenceSend = reader.uint64();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceSendResponse();
        if ((0, helpers_1.isSet)(object.nextSequenceSend))
          obj.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextSequenceSend !== void 0 && (obj.nextSequenceSend = (message.nextSequenceSend || BigInt(0)).toString());
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceSendResponse();
        if (object.nextSequenceSend !== void 0 && object.nextSequenceSend !== null) {
          message.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryUpgradeErrorRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports$1.QueryUpgradeErrorRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeErrorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeErrorRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeErrorRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryUpgradeErrorResponse() {
      return {
        errorReceipt: upgrade_1.ErrorReceipt.fromPartial({}),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryUpgradeErrorResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.errorReceipt !== void 0) {
          upgrade_1.ErrorReceipt.encode(message.errorReceipt, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeErrorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.errorReceipt = upgrade_1.ErrorReceipt.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeErrorResponse();
        if ((0, helpers_1.isSet)(object.errorReceipt))
          obj.errorReceipt = upgrade_1.ErrorReceipt.fromJSON(object.errorReceipt);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.errorReceipt !== void 0 && (obj.errorReceipt = message.errorReceipt ? upgrade_1.ErrorReceipt.toJSON(message.errorReceipt) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeErrorResponse();
        if (object.errorReceipt !== void 0 && object.errorReceipt !== null) {
          message.errorReceipt = upgrade_1.ErrorReceipt.fromPartial(object.errorReceipt);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryUpgradeRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports$1.QueryUpgradeRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryUpgradeResponse() {
      return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryUpgradeResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeResponse();
        if ((0, helpers_1.isSet)(object.upgrade))
          obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgrade !== void 0 && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeResponse();
        if (object.upgrade !== void 0 && object.upgrade !== null) {
          message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelParamsRequest() {
      return {};
    }
    exports$1.QueryChannelParamsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryChannelParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryChannelParamsRequest();
        return message;
      }
    };
    function createBaseQueryChannelParamsResponse() {
      return {
        params: void 0
      };
    }
    exports$1.QueryChannelParamsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Channel = this.Channel.bind(this);
        this.Channels = this.Channels.bind(this);
        this.ConnectionChannels = this.ConnectionChannels.bind(this);
        this.ChannelClientState = this.ChannelClientState.bind(this);
        this.ChannelConsensusState = this.ChannelConsensusState.bind(this);
        this.PacketCommitment = this.PacketCommitment.bind(this);
        this.PacketCommitments = this.PacketCommitments.bind(this);
        this.PacketReceipt = this.PacketReceipt.bind(this);
        this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this);
        this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this);
        this.UnreceivedPackets = this.UnreceivedPackets.bind(this);
        this.UnreceivedAcks = this.UnreceivedAcks.bind(this);
        this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
        this.NextSequenceSend = this.NextSequenceSend.bind(this);
        this.UpgradeError = this.UpgradeError.bind(this);
        this.Upgrade = this.Upgrade.bind(this);
        this.ChannelParams = this.ChannelParams.bind(this);
      }
      Channel(request) {
        const data2 = exports$1.QueryChannelRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channel", data2);
        return promise.then((data3) => exports$1.QueryChannelResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Channels(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports$1.QueryChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channels", data2);
        return promise.then((data3) => exports$1.QueryChannelsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionChannels(request) {
        const data2 = exports$1.QueryConnectionChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", data2);
        return promise.then((data3) => exports$1.QueryConnectionChannelsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelClientState(request) {
        const data2 = exports$1.QueryChannelClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", data2);
        return promise.then((data3) => exports$1.QueryChannelClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelConsensusState(request) {
        const data2 = exports$1.QueryChannelConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", data2);
        return promise.then((data3) => exports$1.QueryChannelConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketCommitment(request) {
        const data2 = exports$1.QueryPacketCommitmentRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", data2);
        return promise.then((data3) => exports$1.QueryPacketCommitmentResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketCommitments(request) {
        const data2 = exports$1.QueryPacketCommitmentsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", data2);
        return promise.then((data3) => exports$1.QueryPacketCommitmentsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketReceipt(request) {
        const data2 = exports$1.QueryPacketReceiptRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", data2);
        return promise.then((data3) => exports$1.QueryPacketReceiptResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketAcknowledgement(request) {
        const data2 = exports$1.QueryPacketAcknowledgementRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", data2);
        return promise.then((data3) => exports$1.QueryPacketAcknowledgementResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketAcknowledgements(request) {
        const data2 = exports$1.QueryPacketAcknowledgementsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", data2);
        return promise.then((data3) => exports$1.QueryPacketAcknowledgementsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnreceivedPackets(request) {
        const data2 = exports$1.QueryUnreceivedPacketsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", data2);
        return promise.then((data3) => exports$1.QueryUnreceivedPacketsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnreceivedAcks(request) {
        const data2 = exports$1.QueryUnreceivedAcksRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", data2);
        return promise.then((data3) => exports$1.QueryUnreceivedAcksResponse.decode(new binary_1.BinaryReader(data3)));
      }
      NextSequenceReceive(request) {
        const data2 = exports$1.QueryNextSequenceReceiveRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", data2);
        return promise.then((data3) => exports$1.QueryNextSequenceReceiveResponse.decode(new binary_1.BinaryReader(data3)));
      }
      NextSequenceSend(request) {
        const data2 = exports$1.QueryNextSequenceSendRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceSend", data2);
        return promise.then((data3) => exports$1.QueryNextSequenceSendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradeError(request) {
        const data2 = exports$1.QueryUpgradeErrorRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UpgradeError", data2);
        return promise.then((data3) => exports$1.QueryUpgradeErrorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Upgrade(request) {
        const data2 = exports$1.QueryUpgradeRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Upgrade", data2);
        return promise.then((data3) => exports$1.QueryUpgradeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelParams(request = {}) {
        const data2 = exports$1.QueryChannelParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelParams", data2);
        return promise.then((data3) => exports$1.QueryChannelParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/cosmjs-types/ibc/core/client/v1/query.js
var require_query9 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/client/v1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryVerifyMembershipResponse = exports$1.QueryVerifyMembershipRequest = exports$1.QueryUpgradedConsensusStateResponse = exports$1.QueryUpgradedConsensusStateRequest = exports$1.QueryUpgradedClientStateResponse = exports$1.QueryUpgradedClientStateRequest = exports$1.QueryClientParamsResponse = exports$1.QueryClientParamsRequest = exports$1.QueryClientStatusResponse = exports$1.QueryClientStatusRequest = exports$1.QueryConsensusStateHeightsResponse = exports$1.QueryConsensusStateHeightsRequest = exports$1.QueryConsensusStatesResponse = exports$1.QueryConsensusStatesRequest = exports$1.QueryConsensusStateResponse = exports$1.QueryConsensusStateRequest = exports$1.QueryClientStatesResponse = exports$1.QueryClientStatesRequest = exports$1.QueryClientStateResponse = exports$1.QueryClientStateRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var client_1 = require_client();
    var commitment_1 = require_commitment();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.client.v1";
    function createBaseQueryClientStateRequest() {
      return {
        clientId: ""
      };
    }
    exports$1.QueryClientStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStateRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStateRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientStateResponse() {
      return {
        clientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryClientStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStateResponse();
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStateResponse();
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryClientStatesRequest() {
      return {
        pagination: void 0
      };
    }
    exports$1.QueryClientStatesRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryClientStatesResponse() {
      return {
        clientStates: [],
        pagination: void 0
      };
    }
    exports$1.QueryClientStatesResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.clientStates) {
          client_1.IdentifiedClientState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientStates.push(client_1.IdentifiedClientState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatesResponse();
        if (Array.isArray(object?.clientStates))
          obj.clientStates = object.clientStates.map((e) => client_1.IdentifiedClientState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.clientStates) {
          obj.clientStates = message.clientStates.map((e) => e ? client_1.IdentifiedClientState.toJSON(e) : void 0);
        } else {
          obj.clientStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatesResponse();
        message.clientStates = object.clientStates?.map((e) => client_1.IdentifiedClientState.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateRequest() {
      return {
        clientId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0),
        latestHeight: false
      };
    }
    exports$1.QueryConsensusStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        if (message.latestHeight === true) {
          writer.uint32(32).bool(message.latestHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            case 4:
              message.latestHeight = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        if ((0, helpers_1.isSet)(object.latestHeight))
          obj.latestHeight = Boolean(object.latestHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateRequest();
        message.clientId = object.clientId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        message.latestHeight = object.latestHeight ?? false;
        return message;
      }
    };
    function createBaseQueryConsensusStateResponse() {
      return {
        consensusState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryConsensusStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStatesRequest() {
      return {
        clientId: "",
        pagination: void 0
      };
    }
    exports$1.QueryConsensusStatesRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStatesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStatesRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStatesRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStatesResponse() {
      return {
        consensusStates: [],
        pagination: void 0
      };
    }
    exports$1.QueryConsensusStatesResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStatesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.consensusStates) {
          client_1.ConsensusStateWithHeight.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStates.push(client_1.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStatesResponse();
        if (Array.isArray(object?.consensusStates))
          obj.consensusStates = object.consensusStates.map((e) => client_1.ConsensusStateWithHeight.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? client_1.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStatesResponse();
        message.consensusStates = object.consensusStates?.map((e) => client_1.ConsensusStateWithHeight.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateHeightsRequest() {
      return {
        clientId: "",
        pagination: void 0
      };
    }
    exports$1.QueryConsensusStateHeightsRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateHeightsRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateHeightsRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateHeightsResponse() {
      return {
        consensusStateHeights: [],
        pagination: void 0
      };
    }
    exports$1.QueryConsensusStateHeightsResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.consensusStateHeights) {
          client_1.Height.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStateHeights.push(client_1.Height.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateHeightsResponse();
        if (Array.isArray(object?.consensusStateHeights))
          obj.consensusStateHeights = object.consensusStateHeights.map((e) => client_1.Height.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStateHeights) {
          obj.consensusStateHeights = message.consensusStateHeights.map((e) => e ? client_1.Height.toJSON(e) : void 0);
        } else {
          obj.consensusStateHeights = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateHeightsResponse();
        message.consensusStateHeights = object.consensusStateHeights?.map((e) => client_1.Height.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryClientStatusRequest() {
      return {
        clientId: ""
      };
    }
    exports$1.QueryClientStatusRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatusRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatusRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatusRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientStatusResponse() {
      return {
        status: ""
      };
    }
    exports$1.QueryClientStatusResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatusResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatusResponse();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = String(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatusResponse();
        message.status = object.status ?? "";
        return message;
      }
    };
    function createBaseQueryClientParamsRequest() {
      return {};
    }
    exports$1.QueryClientParamsRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryClientParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryClientParamsRequest();
        return message;
      }
    };
    function createBaseQueryClientParamsResponse() {
      return {
        params: void 0
      };
    }
    exports$1.QueryClientParamsResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateRequest() {
      return {};
    }
    exports$1.QueryUpgradedClientStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryUpgradedClientStateRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryUpgradedClientStateRequest();
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateResponse() {
      return {
        upgradedClientState: void 0
      };
    }
    exports$1.QueryUpgradedClientStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradedClientStateResponse();
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedClientStateResponse();
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateRequest2() {
      return {};
    }
    exports$1.QueryUpgradedConsensusStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryUpgradedConsensusStateRequest2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryUpgradedConsensusStateRequest2();
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateResponse2() {
      return {
        upgradedConsensusState: void 0
      };
    }
    exports$1.QueryUpgradedConsensusStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedConsensusState !== void 0) {
          any_1.Any.encode(message.upgradedConsensusState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedConsensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradedConsensusStateResponse2();
        if ((0, helpers_1.isSet)(object.upgradedConsensusState))
          obj.upgradedConsensusState = any_1.Any.fromJSON(object.upgradedConsensusState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradedConsensusState !== void 0 && (obj.upgradedConsensusState = message.upgradedConsensusState ? any_1.Any.toJSON(message.upgradedConsensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedConsensusStateResponse2();
        if (object.upgradedConsensusState !== void 0 && object.upgradedConsensusState !== null) {
          message.upgradedConsensusState = any_1.Any.fromPartial(object.upgradedConsensusState);
        }
        return message;
      }
    };
    function createBaseQueryVerifyMembershipRequest() {
      return {
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        merklePath: commitment_1.MerklePath.fromPartial({}),
        value: new Uint8Array(),
        timeDelay: BigInt(0),
        blockDelay: BigInt(0)
      };
    }
    exports$1.QueryVerifyMembershipRequest = {
      typeUrl: "/ibc.core.client.v1.QueryVerifyMembershipRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.merklePath !== void 0) {
          commitment_1.MerklePath.encode(message.merklePath, writer.uint32(34).fork()).ldelim();
        }
        if (message.value.length !== 0) {
          writer.uint32(42).bytes(message.value);
        }
        if (message.timeDelay !== BigInt(0)) {
          writer.uint32(48).uint64(message.timeDelay);
        }
        if (message.blockDelay !== BigInt(0)) {
          writer.uint32(56).uint64(message.blockDelay);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVerifyMembershipRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.merklePath = commitment_1.MerklePath.decode(reader, reader.uint32());
              break;
            case 5:
              message.value = reader.bytes();
              break;
            case 6:
              message.timeDelay = reader.uint64();
              break;
            case 7:
              message.blockDelay = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVerifyMembershipRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.merklePath))
          obj.merklePath = commitment_1.MerklePath.fromJSON(object.merklePath);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.timeDelay))
          obj.timeDelay = BigInt(object.timeDelay.toString());
        if ((0, helpers_1.isSet)(object.blockDelay))
          obj.blockDelay = BigInt(object.blockDelay.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.merklePath !== void 0 && (obj.merklePath = message.merklePath ? commitment_1.MerklePath.toJSON(message.merklePath) : void 0);
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.timeDelay !== void 0 && (obj.timeDelay = (message.timeDelay || BigInt(0)).toString());
        message.blockDelay !== void 0 && (obj.blockDelay = (message.blockDelay || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVerifyMembershipRequest();
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.merklePath !== void 0 && object.merklePath !== null) {
          message.merklePath = commitment_1.MerklePath.fromPartial(object.merklePath);
        }
        message.value = object.value ?? new Uint8Array();
        if (object.timeDelay !== void 0 && object.timeDelay !== null) {
          message.timeDelay = BigInt(object.timeDelay.toString());
        }
        if (object.blockDelay !== void 0 && object.blockDelay !== null) {
          message.blockDelay = BigInt(object.blockDelay.toString());
        }
        return message;
      }
    };
    function createBaseQueryVerifyMembershipResponse() {
      return {
        success: false
      };
    }
    exports$1.QueryVerifyMembershipResponse = {
      typeUrl: "/ibc.core.client.v1.QueryVerifyMembershipResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.success === true) {
          writer.uint32(8).bool(message.success);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVerifyMembershipResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.success = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVerifyMembershipResponse();
        if ((0, helpers_1.isSet)(object.success))
          obj.success = Boolean(object.success);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.success !== void 0 && (obj.success = message.success);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVerifyMembershipResponse();
        message.success = object.success ?? false;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ClientState = this.ClientState.bind(this);
        this.ClientStates = this.ClientStates.bind(this);
        this.ConsensusState = this.ConsensusState.bind(this);
        this.ConsensusStates = this.ConsensusStates.bind(this);
        this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this);
        this.ClientStatus = this.ClientStatus.bind(this);
        this.ClientParams = this.ClientParams.bind(this);
        this.UpgradedClientState = this.UpgradedClientState.bind(this);
        this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
        this.VerifyMembership = this.VerifyMembership.bind(this);
      }
      ClientState(request) {
        const data2 = exports$1.QueryClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientState", data2);
        return promise.then((data3) => exports$1.QueryClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientStates(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports$1.QueryClientStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStates", data2);
        return promise.then((data3) => exports$1.QueryClientStatesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConsensusState(request) {
        const data2 = exports$1.QueryConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", data2);
        return promise.then((data3) => exports$1.QueryConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConsensusStates(request) {
        const data2 = exports$1.QueryConsensusStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", data2);
        return promise.then((data3) => exports$1.QueryConsensusStatesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConsensusStateHeights(request) {
        const data2 = exports$1.QueryConsensusStateHeightsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", data2);
        return promise.then((data3) => exports$1.QueryConsensusStateHeightsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientStatus(request) {
        const data2 = exports$1.QueryClientStatusRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", data2);
        return promise.then((data3) => exports$1.QueryClientStatusResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientParams(request = {}) {
        const data2 = exports$1.QueryClientParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientParams", data2);
        return promise.then((data3) => exports$1.QueryClientParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradedClientState(request = {}) {
        const data2 = exports$1.QueryUpgradedClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", data2);
        return promise.then((data3) => exports$1.QueryUpgradedClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradedConsensusState(request = {}) {
        const data2 = exports$1.QueryUpgradedConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", data2);
        return promise.then((data3) => exports$1.QueryUpgradedConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      VerifyMembership(request) {
        const data2 = exports$1.QueryVerifyMembershipRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "VerifyMembership", data2);
        return promise.then((data3) => exports$1.QueryVerifyMembershipResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/cosmjs-types/ibc/core/connection/v1/query.js
var require_query10 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/connection/v1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryConnectionParamsResponse = exports$1.QueryConnectionParamsRequest = exports$1.QueryConnectionConsensusStateResponse = exports$1.QueryConnectionConsensusStateRequest = exports$1.QueryConnectionClientStateResponse = exports$1.QueryConnectionClientStateRequest = exports$1.QueryClientConnectionsResponse = exports$1.QueryClientConnectionsRequest = exports$1.QueryConnectionsResponse = exports$1.QueryConnectionsRequest = exports$1.QueryConnectionResponse = exports$1.QueryConnectionRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var connection_1 = require_connection();
    var client_1 = require_client();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.core.connection.v1";
    function createBaseQueryConnectionRequest() {
      return {
        connectionId: ""
      };
    }
    exports$1.QueryConnectionRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
      }
    };
    function createBaseQueryConnectionResponse() {
      return {
        connection: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryConnectionResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== void 0) {
          connection_1.ConnectionEnd.encode(message.connection, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = connection_1.ConnectionEnd.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionResponse();
        if ((0, helpers_1.isSet)(object.connection))
          obj.connection = connection_1.ConnectionEnd.fromJSON(object.connection);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection ? connection_1.ConnectionEnd.toJSON(message.connection) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionResponse();
        if (object.connection !== void 0 && object.connection !== null) {
          message.connection = connection_1.ConnectionEnd.fromPartial(object.connection);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionsRequest() {
      return {
        pagination: void 0
      };
    }
    exports$1.QueryConnectionsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConnectionsResponse() {
      return {
        connections: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryConnectionsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.connections) {
          connection_1.IdentifiedConnection.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connections.push(connection_1.IdentifiedConnection.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionsResponse();
        if (Array.isArray(object?.connections))
          obj.connections = object.connections.map((e) => connection_1.IdentifiedConnection.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.connections) {
          obj.connections = message.connections.map((e) => e ? connection_1.IdentifiedConnection.toJSON(e) : void 0);
        } else {
          obj.connections = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionsResponse();
        message.connections = object.connections?.map((e) => connection_1.IdentifiedConnection.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryClientConnectionsRequest() {
      return {
        clientId: ""
      };
    }
    exports$1.QueryClientConnectionsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientConnectionsRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientConnectionsRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientConnectionsResponse() {
      return {
        connectionPaths: [],
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryClientConnectionsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.connectionPaths) {
          writer.uint32(10).string(v);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionPaths.push(reader.string());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientConnectionsResponse();
        if (Array.isArray(object?.connectionPaths))
          obj.connectionPaths = object.connectionPaths.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.connectionPaths) {
          obj.connectionPaths = message.connectionPaths.map((e) => e);
        } else {
          obj.connectionPaths = [];
        }
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientConnectionsResponse();
        message.connectionPaths = object.connectionPaths?.map((e) => e) || [];
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionClientStateRequest() {
      return {
        connectionId: ""
      };
    }
    exports$1.QueryConnectionClientStateRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionClientStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionClientStateRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
      }
    };
    function createBaseQueryConnectionClientStateResponse() {
      return {
        identifiedClientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryConnectionClientStateResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState))
          obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionClientStateResponse();
        if (object.identifiedClientState !== void 0 && object.identifiedClientState !== null) {
          message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateRequest() {
      return {
        connectionId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports$1.QueryConnectionConsensusStateRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionConsensusStateRequest();
        message.connectionId = object.connectionId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateResponse() {
      return {
        consensusState: void 0,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports$1.QueryConnectionConsensusStateResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionParamsRequest() {
      return {};
    }
    exports$1.QueryConnectionParamsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryConnectionParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryConnectionParamsRequest();
        return message;
      }
    };
    function createBaseQueryConnectionParamsResponse() {
      return {
        params: void 0
      };
    }
    exports$1.QueryConnectionParamsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Connection = this.Connection.bind(this);
        this.Connections = this.Connections.bind(this);
        this.ClientConnections = this.ClientConnections.bind(this);
        this.ConnectionClientState = this.ConnectionClientState.bind(this);
        this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this);
        this.ConnectionParams = this.ConnectionParams.bind(this);
      }
      Connection(request) {
        const data2 = exports$1.QueryConnectionRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connection", data2);
        return promise.then((data3) => exports$1.QueryConnectionResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Connections(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports$1.QueryConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connections", data2);
        return promise.then((data3) => exports$1.QueryConnectionsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientConnections(request) {
        const data2 = exports$1.QueryClientConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", data2);
        return promise.then((data3) => exports$1.QueryClientConnectionsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionClientState(request) {
        const data2 = exports$1.QueryConnectionClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", data2);
        return promise.then((data3) => exports$1.QueryConnectionClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionConsensusState(request) {
        const data2 = exports$1.QueryConnectionConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", data2);
        return promise.then((data3) => exports$1.QueryConnectionConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionParams(request = {}) {
        const data2 = exports$1.QueryConnectionParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", data2);
        return promise.then((data3) => exports$1.QueryConnectionParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/cosmjs-types/tendermint/crypto/proof.js
var require_proof = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/crypto/proof.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ProofOps = exports$1.ProofOp = exports$1.DominoOp = exports$1.ValueOp = exports$1.Proof = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "tendermint.crypto";
    function createBaseProof() {
      return {
        total: BigInt(0),
        index: BigInt(0),
        leafHash: new Uint8Array(),
        aunts: []
      };
    }
    exports$1.Proof = {
      typeUrl: "/tendermint.crypto.Proof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== BigInt(0)) {
          writer.uint32(8).int64(message.total);
        }
        if (message.index !== BigInt(0)) {
          writer.uint32(16).int64(message.index);
        }
        if (message.leafHash.length !== 0) {
          writer.uint32(26).bytes(message.leafHash);
        }
        for (const v of message.aunts) {
          writer.uint32(34).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.int64();
              break;
            case 2:
              message.index = reader.int64();
              break;
            case 3:
              message.leafHash = reader.bytes();
              break;
            case 4:
              message.aunts.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProof();
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        if ((0, helpers_1.isSet)(object.index))
          obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.leafHash))
          obj.leafHash = (0, helpers_1.bytesFromBase64)(object.leafHash);
        if (Array.isArray(object?.aunts))
          obj.aunts = object.aunts.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        message.index !== void 0 && (obj.index = (message.index || BigInt(0)).toString());
        message.leafHash !== void 0 && (obj.leafHash = (0, helpers_1.base64FromBytes)(message.leafHash !== void 0 ? message.leafHash : new Uint8Array()));
        if (message.aunts) {
          obj.aunts = message.aunts.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.aunts = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProof();
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        if (object.index !== void 0 && object.index !== null) {
          message.index = BigInt(object.index.toString());
        }
        message.leafHash = object.leafHash ?? new Uint8Array();
        message.aunts = object.aunts?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseValueOp() {
      return {
        key: new Uint8Array(),
        proof: void 0
      };
    }
    exports$1.ValueOp = {
      typeUrl: "/tendermint.crypto.ValueOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.proof !== void 0) {
          exports$1.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValueOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.proof = exports$1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValueOp();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = exports$1.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? exports$1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValueOp();
        message.key = object.key ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = exports$1.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
    function createBaseDominoOp() {
      return {
        key: "",
        input: "",
        output: ""
      };
    }
    exports$1.DominoOp = {
      typeUrl: "/tendermint.crypto.DominoOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.input !== "") {
          writer.uint32(18).string(message.input);
        }
        if (message.output !== "") {
          writer.uint32(26).string(message.output);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDominoOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.input = reader.string();
              break;
            case 3:
              message.output = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDominoOp();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.input))
          obj.input = String(object.input);
        if ((0, helpers_1.isSet)(object.output))
          obj.output = String(object.output);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.input !== void 0 && (obj.input = message.input);
        message.output !== void 0 && (obj.output = message.output);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDominoOp();
        message.key = object.key ?? "";
        message.input = object.input ?? "";
        message.output = object.output ?? "";
        return message;
      }
    };
    function createBaseProofOp3() {
      return {
        type: "",
        key: new Uint8Array(),
        data: new Uint8Array()
      };
    }
    exports$1.ProofOp = {
      typeUrl: "/tendermint.crypto.ProofOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.key.length !== 0) {
          writer.uint32(18).bytes(message.key);
        }
        if (message.data.length !== 0) {
          writer.uint32(26).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOp3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.key = reader.bytes();
              break;
            case 3:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofOp3();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofOp3();
        message.type = object.type ?? "";
        message.key = object.key ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProofOps3() {
      return {
        ops: []
      };
    }
    exports$1.ProofOps = {
      typeUrl: "/tendermint.crypto.ProofOps",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.ops) {
          exports$1.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOps3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ops.push(exports$1.ProofOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofOps3();
        if (Array.isArray(object?.ops))
          obj.ops = object.ops.map((e) => exports$1.ProofOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.ops) {
          obj.ops = message.ops.map((e) => e ? exports$1.ProofOp.toJSON(e) : void 0);
        } else {
          obj.ops = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofOps3();
        message.ops = object.ops?.map((e) => exports$1.ProofOp.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/tendermint/version/types.js
var require_types2 = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/version/types.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Consensus = exports$1.App = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "tendermint.version";
    function createBaseApp() {
      return {
        protocol: BigInt(0),
        software: ""
      };
    }
    exports$1.App = {
      typeUrl: "/tendermint.version.App",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.protocol !== BigInt(0)) {
          writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
          writer.uint32(18).string(message.software);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = reader.uint64();
              break;
            case 2:
              message.software = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseApp();
        if ((0, helpers_1.isSet)(object.protocol))
          obj.protocol = BigInt(object.protocol.toString());
        if ((0, helpers_1.isSet)(object.software))
          obj.software = String(object.software);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = (message.protocol || BigInt(0)).toString());
        message.software !== void 0 && (obj.software = message.software);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseApp();
        if (object.protocol !== void 0 && object.protocol !== null) {
          message.protocol = BigInt(object.protocol.toString());
        }
        message.software = object.software ?? "";
        return message;
      }
    };
    function createBaseConsensus2() {
      return {
        block: BigInt(0),
        app: BigInt(0)
      };
    }
    exports$1.Consensus = {
      typeUrl: "/tendermint.version.Consensus",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== BigInt(0)) {
          writer.uint32(8).uint64(message.block);
        }
        if (message.app !== BigInt(0)) {
          writer.uint32(16).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensus2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = reader.uint64();
              break;
            case 2:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensus2();
        if ((0, helpers_1.isSet)(object.block))
          obj.block = BigInt(object.block.toString());
        if ((0, helpers_1.isSet)(object.app))
          obj.app = BigInt(object.app.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = (message.block || BigInt(0)).toString());
        message.app !== void 0 && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensus2();
        if (object.block !== void 0 && object.block !== null) {
          message.block = BigInt(object.block.toString());
        }
        if (object.app !== void 0 && object.app !== null) {
          message.app = BigInt(object.app.toString());
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/tendermint/crypto/keys.js
var require_keys4 = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/crypto/keys.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.PublicKey = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "tendermint.crypto";
    function createBasePublicKey2() {
      return {
        ed25519: void 0,
        secp256k1: void 0
      };
    }
    exports$1.PublicKey = {
      typeUrl: "/tendermint.crypto.PublicKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.ed25519 !== void 0) {
          writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== void 0) {
          writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicKey2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ed25519 = reader.bytes();
              break;
            case 2:
              message.secp256k1 = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePublicKey2();
        if ((0, helpers_1.isSet)(object.ed25519))
          obj.ed25519 = (0, helpers_1.bytesFromBase64)(object.ed25519);
        if ((0, helpers_1.isSet)(object.secp256k1))
          obj.secp256k1 = (0, helpers_1.bytesFromBase64)(object.secp256k1);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.ed25519 !== void 0 && (obj.ed25519 = message.ed25519 !== void 0 ? (0, helpers_1.base64FromBytes)(message.ed25519) : void 0);
        message.secp256k1 !== void 0 && (obj.secp256k1 = message.secp256k1 !== void 0 ? (0, helpers_1.base64FromBytes)(message.secp256k1) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePublicKey2();
        message.ed25519 = object.ed25519 ?? void 0;
        message.secp256k1 = object.secp256k1 ?? void 0;
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/validator.js
var require_validator = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/validator.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SimpleValidator = exports$1.Validator = exports$1.ValidatorSet = exports$1.blockIDFlagToJSON = exports$1.blockIDFlagFromJSON = exports$1.BlockIDFlag = exports$1.protobufPackage = void 0;
    var keys_1 = require_keys4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "tendermint.types";
    var BlockIDFlag;
    (function(BlockIDFlag2) {
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
      BlockIDFlag2[BlockIDFlag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BlockIDFlag || (exports$1.BlockIDFlag = BlockIDFlag = {}));
    function blockIDFlagFromJSON2(object) {
      switch (object) {
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
          return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
          return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
          return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
          return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BlockIDFlag.UNRECOGNIZED;
      }
    }
    exports$1.blockIDFlagFromJSON = blockIDFlagFromJSON2;
    function blockIDFlagToJSON2(object) {
      switch (object) {
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
          return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
          return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
          return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
          return "BLOCK_ID_FLAG_NIL";
        case BlockIDFlag.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.blockIDFlagToJSON = blockIDFlagToJSON2;
    function createBaseValidatorSet2() {
      return {
        validators: [],
        proposer: void 0,
        totalVotingPower: BigInt(0)
      };
    }
    exports$1.ValidatorSet = {
      typeUrl: "/tendermint.types.ValidatorSet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          exports$1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.proposer !== void 0) {
          exports$1.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSet2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(exports$1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.proposer = exports$1.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSet2();
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => exports$1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = exports$1.Validator.fromJSON(object.proposer);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports$1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer ? exports$1.Validator.toJSON(message.proposer) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSet2();
        message.validators = object.validators?.map((e) => exports$1.Validator.fromPartial(e)) || [];
        if (object.proposer !== void 0 && object.proposer !== null) {
          message.proposer = exports$1.Validator.fromPartial(object.proposer);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        return message;
      }
    };
    function createBaseValidator5() {
      return {
        address: new Uint8Array(),
        pubKey: keys_1.PublicKey.fromPartial({}),
        votingPower: BigInt(0),
        proposerPriority: BigInt(0)
      };
    }
    exports$1.Validator = {
      typeUrl: "/tendermint.types.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.votingPower);
        }
        if (message.proposerPriority !== BigInt(0)) {
          writer.uint32(32).int64(message.proposerPriority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator5();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 2:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPower = reader.int64();
              break;
            case 4:
              message.proposerPriority = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator5();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower))
          obj.votingPower = BigInt(object.votingPower.toString());
        if ((0, helpers_1.isSet)(object.proposerPriority))
          obj.proposerPriority = BigInt(object.proposerPriority.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== void 0 ? message.address : new Uint8Array()));
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        message.proposerPriority !== void 0 && (obj.proposerPriority = (message.proposerPriority || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator5();
        message.address = object.address ?? new Uint8Array();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.votingPower !== void 0 && object.votingPower !== null) {
          message.votingPower = BigInt(object.votingPower.toString());
        }
        if (object.proposerPriority !== void 0 && object.proposerPriority !== null) {
          message.proposerPriority = BigInt(object.proposerPriority.toString());
        }
        return message;
      }
    };
    function createBaseSimpleValidator() {
      return {
        pubKey: void 0,
        votingPower: BigInt(0)
      };
    }
    exports$1.SimpleValidator = {
      typeUrl: "/tendermint.types.SimpleValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.votingPower !== BigInt(0)) {
          writer.uint32(16).int64(message.votingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimpleValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.votingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimpleValidator();
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower))
          obj.votingPower = BigInt(object.votingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimpleValidator();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.votingPower !== void 0 && object.votingPower !== null) {
          message.votingPower = BigInt(object.votingPower.toString());
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/types.js
var require_types3 = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/types.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.TxProof = exports$1.BlockMeta = exports$1.LightBlock = exports$1.SignedHeader = exports$1.Proposal = exports$1.ExtendedCommitSig = exports$1.ExtendedCommit = exports$1.CommitSig = exports$1.Commit = exports$1.Vote = exports$1.Data = exports$1.Header = exports$1.BlockID = exports$1.Part = exports$1.PartSetHeader = exports$1.signedMsgTypeToJSON = exports$1.signedMsgTypeFromJSON = exports$1.SignedMsgType = exports$1.protobufPackage = void 0;
    var proof_1 = require_proof();
    var types_1 = require_types2();
    var timestamp_1 = require_timestamp();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "tendermint.types";
    var SignedMsgType;
    (function(SignedMsgType2) {
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
      SignedMsgType2[SignedMsgType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignedMsgType || (exports$1.SignedMsgType = SignedMsgType = {}));
    function signedMsgTypeFromJSON2(object) {
      switch (object) {
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
          return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
          return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
          return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
          return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignedMsgType.UNRECOGNIZED;
      }
    }
    exports$1.signedMsgTypeFromJSON = signedMsgTypeFromJSON2;
    function signedMsgTypeToJSON2(object) {
      switch (object) {
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
          return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
          return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
          return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
          return "SIGNED_MSG_TYPE_PROPOSAL";
        case SignedMsgType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.signedMsgTypeToJSON = signedMsgTypeToJSON2;
    function createBasePartSetHeader2() {
      return {
        total: 0,
        hash: new Uint8Array()
      };
    }
    exports$1.PartSetHeader = {
      typeUrl: "/tendermint.types.PartSetHeader",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== 0) {
          writer.uint32(8).uint32(message.total);
        }
        if (message.hash.length !== 0) {
          writer.uint32(18).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePartSetHeader2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.uint32();
              break;
            case 2:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePartSetHeader2();
        if ((0, helpers_1.isSet)(object.total))
          obj.total = Number(object.total);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = Math.round(message.total));
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePartSetHeader2();
        message.total = object.total ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        return message;
      }
    };
    function createBasePart() {
      return {
        index: 0,
        bytes: new Uint8Array(),
        proof: proof_1.Proof.fromPartial({})
      };
    }
    exports$1.Part = {
      typeUrl: "/tendermint.types.Part",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.bytes.length !== 0) {
          writer.uint32(18).bytes(message.bytes);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePart();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.bytes = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePart();
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.bytes))
          obj.bytes = (0, helpers_1.bytesFromBase64)(object.bytes);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.bytes !== void 0 && (obj.bytes = (0, helpers_1.base64FromBytes)(message.bytes !== void 0 ? message.bytes : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePart();
        message.index = object.index ?? 0;
        message.bytes = object.bytes ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = proof_1.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
    function createBaseBlockID2() {
      return {
        hash: new Uint8Array(),
        partSetHeader: exports$1.PartSetHeader.fromPartial({})
      };
    }
    exports$1.BlockID = {
      typeUrl: "/tendermint.types.BlockID",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.partSetHeader !== void 0) {
          exports$1.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockID2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.partSetHeader = exports$1.PartSetHeader.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockID2();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.partSetHeader))
          obj.partSetHeader = exports$1.PartSetHeader.fromJSON(object.partSetHeader);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.partSetHeader !== void 0 && (obj.partSetHeader = message.partSetHeader ? exports$1.PartSetHeader.toJSON(message.partSetHeader) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockID2();
        message.hash = object.hash ?? new Uint8Array();
        if (object.partSetHeader !== void 0 && object.partSetHeader !== null) {
          message.partSetHeader = exports$1.PartSetHeader.fromPartial(object.partSetHeader);
        }
        return message;
      }
    };
    function createBaseHeader3() {
      return {
        version: types_1.Consensus.fromPartial({}),
        chainId: "",
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        lastBlockId: exports$1.BlockID.fromPartial({}),
        lastCommitHash: new Uint8Array(),
        dataHash: new Uint8Array(),
        validatorsHash: new Uint8Array(),
        nextValidatorsHash: new Uint8Array(),
        consensusHash: new Uint8Array(),
        appHash: new Uint8Array(),
        lastResultsHash: new Uint8Array(),
        evidenceHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports$1.Header = {
      typeUrl: "/tendermint.types.Header",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== void 0) {
          types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.lastBlockId !== void 0) {
          exports$1.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.lastCommitHash.length !== 0) {
          writer.uint32(50).bytes(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(58).bytes(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
          writer.uint32(66).bytes(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(74).bytes(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
          writer.uint32(82).bytes(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
          writer.uint32(90).bytes(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
          writer.uint32(98).bytes(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
          writer.uint32(106).bytes(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(114).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = types_1.Consensus.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.lastBlockId = exports$1.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.lastCommitHash = reader.bytes();
              break;
            case 7:
              message.dataHash = reader.bytes();
              break;
            case 8:
              message.validatorsHash = reader.bytes();
              break;
            case 9:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 10:
              message.consensusHash = reader.bytes();
              break;
            case 11:
              message.appHash = reader.bytes();
              break;
            case 12:
              message.lastResultsHash = reader.bytes();
              break;
            case 13:
              message.evidenceHash = reader.bytes();
              break;
            case 14:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeader3();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = types_1.Consensus.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.lastBlockId))
          obj.lastBlockId = exports$1.BlockID.fromJSON(object.lastBlockId);
        if ((0, helpers_1.isSet)(object.lastCommitHash))
          obj.lastCommitHash = (0, helpers_1.bytesFromBase64)(object.lastCommitHash);
        if ((0, helpers_1.isSet)(object.dataHash))
          obj.dataHash = (0, helpers_1.bytesFromBase64)(object.dataHash);
        if ((0, helpers_1.isSet)(object.validatorsHash))
          obj.validatorsHash = (0, helpers_1.bytesFromBase64)(object.validatorsHash);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.consensusHash))
          obj.consensusHash = (0, helpers_1.bytesFromBase64)(object.consensusHash);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        if ((0, helpers_1.isSet)(object.lastResultsHash))
          obj.lastResultsHash = (0, helpers_1.bytesFromBase64)(object.lastResultsHash);
        if ((0, helpers_1.isSet)(object.evidenceHash))
          obj.evidenceHash = (0, helpers_1.bytesFromBase64)(object.evidenceHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.lastBlockId !== void 0 && (obj.lastBlockId = message.lastBlockId ? exports$1.BlockID.toJSON(message.lastBlockId) : void 0);
        message.lastCommitHash !== void 0 && (obj.lastCommitHash = (0, helpers_1.base64FromBytes)(message.lastCommitHash !== void 0 ? message.lastCommitHash : new Uint8Array()));
        message.dataHash !== void 0 && (obj.dataHash = (0, helpers_1.base64FromBytes)(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.validatorsHash !== void 0 && (obj.validatorsHash = (0, helpers_1.base64FromBytes)(message.validatorsHash !== void 0 ? message.validatorsHash : new Uint8Array()));
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.consensusHash !== void 0 && (obj.consensusHash = (0, helpers_1.base64FromBytes)(message.consensusHash !== void 0 ? message.consensusHash : new Uint8Array()));
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        message.lastResultsHash !== void 0 && (obj.lastResultsHash = (0, helpers_1.base64FromBytes)(message.lastResultsHash !== void 0 ? message.lastResultsHash : new Uint8Array()));
        message.evidenceHash !== void 0 && (obj.evidenceHash = (0, helpers_1.base64FromBytes)(message.evidenceHash !== void 0 ? message.evidenceHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeader3();
        if (object.version !== void 0 && object.version !== null) {
          message.version = types_1.Consensus.fromPartial(object.version);
        }
        message.chainId = object.chainId ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.lastBlockId !== void 0 && object.lastBlockId !== null) {
          message.lastBlockId = exports$1.BlockID.fromPartial(object.lastBlockId);
        }
        message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();
        message.dataHash = object.dataHash ?? new Uint8Array();
        message.validatorsHash = object.validatorsHash ?? new Uint8Array();
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.consensusHash = object.consensusHash ?? new Uint8Array();
        message.appHash = object.appHash ?? new Uint8Array();
        message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();
        message.evidenceHash = object.evidenceHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseData2() {
      return {
        txs: []
      };
    }
    exports$1.Data = {
      typeUrl: "/tendermint.types.Data",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseData2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseData2();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseData2();
        message.txs = object.txs?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseVote5() {
      return {
        type: 0,
        height: BigInt(0),
        round: 0,
        blockId: exports$1.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        validatorAddress: new Uint8Array(),
        validatorIndex: 0,
        signature: new Uint8Array(),
        extension: new Uint8Array(),
        extensionSignature: new Uint8Array()
      };
    }
    exports$1.Vote = {
      typeUrl: "/tendermint.types.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports$1.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(50).bytes(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
          writer.uint32(56).int32(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
          writer.uint32(66).bytes(message.signature);
        }
        if (message.extension.length !== 0) {
          writer.uint32(74).bytes(message.extension);
        }
        if (message.extensionSignature.length !== 0) {
          writer.uint32(82).bytes(message.extensionSignature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote5();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.blockId = exports$1.BlockID.decode(reader, reader.uint32());
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.validatorAddress = reader.bytes();
              break;
            case 7:
              message.validatorIndex = reader.int32();
              break;
            case 8:
              message.signature = reader.bytes();
              break;
            case 9:
              message.extension = reader.bytes();
              break;
            case 10:
              message.extensionSignature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote5();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = signedMsgTypeFromJSON2(object.type);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports$1.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.validatorIndex))
          obj.validatorIndex = Number(object.validatorIndex);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        if ((0, helpers_1.isSet)(object.extension))
          obj.extension = (0, helpers_1.bytesFromBase64)(object.extension);
        if ((0, helpers_1.isSet)(object.extensionSignature))
          obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON2(message.type));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports$1.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.validatorIndex !== void 0 && (obj.validatorIndex = Math.round(message.validatorIndex));
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        message.extension !== void 0 && (obj.extension = (0, helpers_1.base64FromBytes)(message.extension !== void 0 ? message.extension : new Uint8Array()));
        message.extensionSignature !== void 0 && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== void 0 ? message.extensionSignature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote5();
        message.type = object.type ?? 0;
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports$1.BlockID.fromPartial(object.blockId);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        message.validatorIndex = object.validatorIndex ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        message.extension = object.extension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseCommit2() {
      return {
        height: BigInt(0),
        round: 0,
        blockId: exports$1.BlockID.fromPartial({}),
        signatures: []
      };
    }
    exports$1.Commit = {
      typeUrl: "/tendermint.types.Commit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports$1.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports$1.CommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommit2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports$1.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.signatures.push(exports$1.CommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommit2();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports$1.BlockID.fromJSON(object.blockId);
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => exports$1.CommitSig.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports$1.BlockID.toJSON(message.blockId) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports$1.CommitSig.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommit2();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports$1.BlockID.fromPartial(object.blockId);
        }
        message.signatures = object.signatures?.map((e) => exports$1.CommitSig.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCommitSig2() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
      };
    }
    exports$1.CommitSig = {
      typeUrl: "/tendermint.types.CommitSig",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitSig2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitSig2();
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitSig2();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseExtendedCommit() {
      return {
        height: BigInt(0),
        round: 0,
        blockId: exports$1.BlockID.fromPartial({}),
        extendedSignatures: []
      };
    }
    exports$1.ExtendedCommit = {
      typeUrl: "/tendermint.types.ExtendedCommit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports$1.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.extendedSignatures) {
          exports$1.ExtendedCommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports$1.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.extendedSignatures.push(exports$1.ExtendedCommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommit();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports$1.BlockID.fromJSON(object.blockId);
        if (Array.isArray(object?.extendedSignatures))
          obj.extendedSignatures = object.extendedSignatures.map((e) => exports$1.ExtendedCommitSig.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports$1.BlockID.toJSON(message.blockId) : void 0);
        if (message.extendedSignatures) {
          obj.extendedSignatures = message.extendedSignatures.map((e) => e ? exports$1.ExtendedCommitSig.toJSON(e) : void 0);
        } else {
          obj.extendedSignatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedCommit();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports$1.BlockID.fromPartial(object.blockId);
        }
        message.extendedSignatures = object.extendedSignatures?.map((e) => exports$1.ExtendedCommitSig.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseExtendedCommitSig() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array(),
        extension: new Uint8Array(),
        extensionSignature: new Uint8Array()
      };
    }
    exports$1.ExtendedCommitSig = {
      typeUrl: "/tendermint.types.ExtendedCommitSig",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        if (message.extension.length !== 0) {
          writer.uint32(42).bytes(message.extension);
        }
        if (message.extensionSignature.length !== 0) {
          writer.uint32(50).bytes(message.extensionSignature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommitSig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            case 5:
              message.extension = reader.bytes();
              break;
            case 6:
              message.extensionSignature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommitSig();
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        if ((0, helpers_1.isSet)(object.extension))
          obj.extension = (0, helpers_1.bytesFromBase64)(object.extension);
        if ((0, helpers_1.isSet)(object.extensionSignature))
          obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        message.extension !== void 0 && (obj.extension = (0, helpers_1.base64FromBytes)(message.extension !== void 0 ? message.extension : new Uint8Array()));
        message.extensionSignature !== void 0 && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== void 0 ? message.extensionSignature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedCommitSig();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        message.extension = object.extension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProposal4() {
      return {
        type: 0,
        height: BigInt(0),
        round: 0,
        polRound: 0,
        blockId: exports$1.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
      };
    }
    exports$1.Proposal = {
      typeUrl: "/tendermint.types.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.polRound !== 0) {
          writer.uint32(32).int32(message.polRound);
        }
        if (message.blockId !== void 0) {
          exports$1.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(58).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.polRound = reader.int32();
              break;
            case 5:
              message.blockId = exports$1.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal4();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = signedMsgTypeFromJSON2(object.type);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.polRound))
          obj.polRound = Number(object.polRound);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports$1.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON2(message.type));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.polRound !== void 0 && (obj.polRound = Math.round(message.polRound));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports$1.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal4();
        message.type = object.type ?? 0;
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        message.polRound = object.polRound ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports$1.BlockID.fromPartial(object.blockId);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSignedHeader2() {
      return {
        header: void 0,
        commit: void 0
      };
    }
    exports$1.SignedHeader = {
      typeUrl: "/tendermint.types.SignedHeader",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          exports$1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports$1.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignedHeader2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = exports$1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.commit = exports$1.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignedHeader2();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = exports$1.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports$1.Commit.fromJSON(object.commit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? exports$1.Header.toJSON(message.header) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports$1.Commit.toJSON(message.commit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignedHeader2();
        if (object.header !== void 0 && object.header !== null) {
          message.header = exports$1.Header.fromPartial(object.header);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports$1.Commit.fromPartial(object.commit);
        }
        return message;
      }
    };
    function createBaseLightBlock2() {
      return {
        signedHeader: void 0,
        validatorSet: void 0
      };
    }
    exports$1.LightBlock = {
      typeUrl: "/tendermint.types.LightBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== void 0) {
          exports$1.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightBlock2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = exports$1.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLightBlock2();
        if ((0, helpers_1.isSet)(object.signedHeader))
          obj.signedHeader = exports$1.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet))
          obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? exports$1.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLightBlock2();
        if (object.signedHeader !== void 0 && object.signedHeader !== null) {
          message.signedHeader = exports$1.SignedHeader.fromPartial(object.signedHeader);
        }
        if (object.validatorSet !== void 0 && object.validatorSet !== null) {
          message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        }
        return message;
      }
    };
    function createBaseBlockMeta() {
      return {
        blockId: exports$1.BlockID.fromPartial({}),
        blockSize: BigInt(0),
        header: exports$1.Header.fromPartial({}),
        numTxs: BigInt(0)
      };
    }
    exports$1.BlockMeta = {
      typeUrl: "/tendermint.types.BlockMeta",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockId !== void 0) {
          exports$1.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockSize !== BigInt(0)) {
          writer.uint32(16).int64(message.blockSize);
        }
        if (message.header !== void 0) {
          exports$1.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        }
        if (message.numTxs !== BigInt(0)) {
          writer.uint32(32).int64(message.numTxs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockId = exports$1.BlockID.decode(reader, reader.uint32());
              break;
            case 2:
              message.blockSize = reader.int64();
              break;
            case 3:
              message.header = exports$1.Header.decode(reader, reader.uint32());
              break;
            case 4:
              message.numTxs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockMeta();
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports$1.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.blockSize))
          obj.blockSize = BigInt(object.blockSize.toString());
        if ((0, helpers_1.isSet)(object.header))
          obj.header = exports$1.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.numTxs))
          obj.numTxs = BigInt(object.numTxs.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports$1.BlockID.toJSON(message.blockId) : void 0);
        message.blockSize !== void 0 && (obj.blockSize = (message.blockSize || BigInt(0)).toString());
        message.header !== void 0 && (obj.header = message.header ? exports$1.Header.toJSON(message.header) : void 0);
        message.numTxs !== void 0 && (obj.numTxs = (message.numTxs || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockMeta();
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports$1.BlockID.fromPartial(object.blockId);
        }
        if (object.blockSize !== void 0 && object.blockSize !== null) {
          message.blockSize = BigInt(object.blockSize.toString());
        }
        if (object.header !== void 0 && object.header !== null) {
          message.header = exports$1.Header.fromPartial(object.header);
        }
        if (object.numTxs !== void 0 && object.numTxs !== null) {
          message.numTxs = BigInt(object.numTxs.toString());
        }
        return message;
      }
    };
    function createBaseTxProof() {
      return {
        rootHash: new Uint8Array(),
        data: new Uint8Array(),
        proof: void 0
      };
    }
    exports$1.TxProof = {
      typeUrl: "/tendermint.types.TxProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rootHash.length !== 0) {
          writer.uint32(10).bytes(message.rootHash);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rootHash = reader.bytes();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxProof();
        if ((0, helpers_1.isSet)(object.rootHash))
          obj.rootHash = (0, helpers_1.bytesFromBase64)(object.rootHash);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rootHash !== void 0 && (obj.rootHash = (0, helpers_1.base64FromBytes)(message.rootHash !== void 0 ? message.rootHash : new Uint8Array()));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxProof();
        message.rootHash = object.rootHash ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = proof_1.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js
var require_tendermint = __commonJS({
  "../../node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Fraction = exports$1.Header = exports$1.Misbehaviour = exports$1.ConsensusState = exports$1.ClientState = exports$1.protobufPackage = void 0;
    var duration_1 = require_duration();
    var client_1 = require_client();
    var proofs_1 = require_proofs();
    var timestamp_1 = require_timestamp();
    var commitment_1 = require_commitment();
    var types_1 = require_types3();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "ibc.lightclients.tendermint.v1";
    function createBaseClientState() {
      return {
        chainId: "",
        trustLevel: exports$1.Fraction.fromPartial({}),
        trustingPeriod: duration_1.Duration.fromPartial({}),
        unbondingPeriod: duration_1.Duration.fromPartial({}),
        maxClockDrift: duration_1.Duration.fromPartial({}),
        frozenHeight: client_1.Height.fromPartial({}),
        latestHeight: client_1.Height.fromPartial({}),
        proofSpecs: [],
        upgradePath: [],
        allowUpdateAfterExpiry: false,
        allowUpdateAfterMisbehaviour: false
      };
    }
    exports$1.ClientState = {
      typeUrl: "/ibc.lightclients.tendermint.v1.ClientState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.chainId !== "") {
          writer.uint32(10).string(message.chainId);
        }
        if (message.trustLevel !== void 0) {
          exports$1.Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustingPeriod !== void 0) {
          duration_1.Duration.encode(message.trustingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.unbondingPeriod !== void 0) {
          duration_1.Duration.encode(message.unbondingPeriod, writer.uint32(34).fork()).ldelim();
        }
        if (message.maxClockDrift !== void 0) {
          duration_1.Duration.encode(message.maxClockDrift, writer.uint32(42).fork()).ldelim();
        }
        if (message.frozenHeight !== void 0) {
          client_1.Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.latestHeight !== void 0) {
          client_1.Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.proofSpecs) {
          proofs_1.ProofSpec.encode(v, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.upgradePath) {
          writer.uint32(74).string(v);
        }
        if (message.allowUpdateAfterExpiry === true) {
          writer.uint32(80).bool(message.allowUpdateAfterExpiry);
        }
        if (message.allowUpdateAfterMisbehaviour === true) {
          writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chainId = reader.string();
              break;
            case 2:
              message.trustLevel = exports$1.Fraction.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.unbondingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 5:
              message.maxClockDrift = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 6:
              message.frozenHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.latestHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofSpecs.push(proofs_1.ProofSpec.decode(reader, reader.uint32()));
              break;
            case 9:
              message.upgradePath.push(reader.string());
              break;
            case 10:
              message.allowUpdateAfterExpiry = reader.bool();
              break;
            case 11:
              message.allowUpdateAfterMisbehaviour = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientState();
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.trustLevel))
          obj.trustLevel = exports$1.Fraction.fromJSON(object.trustLevel);
        if ((0, helpers_1.isSet)(object.trustingPeriod))
          obj.trustingPeriod = duration_1.Duration.fromJSON(object.trustingPeriod);
        if ((0, helpers_1.isSet)(object.unbondingPeriod))
          obj.unbondingPeriod = duration_1.Duration.fromJSON(object.unbondingPeriod);
        if ((0, helpers_1.isSet)(object.maxClockDrift))
          obj.maxClockDrift = duration_1.Duration.fromJSON(object.maxClockDrift);
        if ((0, helpers_1.isSet)(object.frozenHeight))
          obj.frozenHeight = client_1.Height.fromJSON(object.frozenHeight);
        if ((0, helpers_1.isSet)(object.latestHeight))
          obj.latestHeight = client_1.Height.fromJSON(object.latestHeight);
        if (Array.isArray(object?.proofSpecs))
          obj.proofSpecs = object.proofSpecs.map((e) => proofs_1.ProofSpec.fromJSON(e));
        if (Array.isArray(object?.upgradePath))
          obj.upgradePath = object.upgradePath.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.allowUpdateAfterExpiry))
          obj.allowUpdateAfterExpiry = Boolean(object.allowUpdateAfterExpiry);
        if ((0, helpers_1.isSet)(object.allowUpdateAfterMisbehaviour))
          obj.allowUpdateAfterMisbehaviour = Boolean(object.allowUpdateAfterMisbehaviour);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.trustLevel !== void 0 && (obj.trustLevel = message.trustLevel ? exports$1.Fraction.toJSON(message.trustLevel) : void 0);
        message.trustingPeriod !== void 0 && (obj.trustingPeriod = message.trustingPeriod ? duration_1.Duration.toJSON(message.trustingPeriod) : void 0);
        message.unbondingPeriod !== void 0 && (obj.unbondingPeriod = message.unbondingPeriod ? duration_1.Duration.toJSON(message.unbondingPeriod) : void 0);
        message.maxClockDrift !== void 0 && (obj.maxClockDrift = message.maxClockDrift ? duration_1.Duration.toJSON(message.maxClockDrift) : void 0);
        message.frozenHeight !== void 0 && (obj.frozenHeight = message.frozenHeight ? client_1.Height.toJSON(message.frozenHeight) : void 0);
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight ? client_1.Height.toJSON(message.latestHeight) : void 0);
        if (message.proofSpecs) {
          obj.proofSpecs = message.proofSpecs.map((e) => e ? proofs_1.ProofSpec.toJSON(e) : void 0);
        } else {
          obj.proofSpecs = [];
        }
        if (message.upgradePath) {
          obj.upgradePath = message.upgradePath.map((e) => e);
        } else {
          obj.upgradePath = [];
        }
        message.allowUpdateAfterExpiry !== void 0 && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
        message.allowUpdateAfterMisbehaviour !== void 0 && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientState();
        message.chainId = object.chainId ?? "";
        if (object.trustLevel !== void 0 && object.trustLevel !== null) {
          message.trustLevel = exports$1.Fraction.fromPartial(object.trustLevel);
        }
        if (object.trustingPeriod !== void 0 && object.trustingPeriod !== null) {
          message.trustingPeriod = duration_1.Duration.fromPartial(object.trustingPeriod);
        }
        if (object.unbondingPeriod !== void 0 && object.unbondingPeriod !== null) {
          message.unbondingPeriod = duration_1.Duration.fromPartial(object.unbondingPeriod);
        }
        if (object.maxClockDrift !== void 0 && object.maxClockDrift !== null) {
          message.maxClockDrift = duration_1.Duration.fromPartial(object.maxClockDrift);
        }
        if (object.frozenHeight !== void 0 && object.frozenHeight !== null) {
          message.frozenHeight = client_1.Height.fromPartial(object.frozenHeight);
        }
        if (object.latestHeight !== void 0 && object.latestHeight !== null) {
          message.latestHeight = client_1.Height.fromPartial(object.latestHeight);
        }
        message.proofSpecs = object.proofSpecs?.map((e) => proofs_1.ProofSpec.fromPartial(e)) || [];
        message.upgradePath = object.upgradePath?.map((e) => e) || [];
        message.allowUpdateAfterExpiry = object.allowUpdateAfterExpiry ?? false;
        message.allowUpdateAfterMisbehaviour = object.allowUpdateAfterMisbehaviour ?? false;
        return message;
      }
    };
    function createBaseConsensusState() {
      return {
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        root: commitment_1.MerkleRoot.fromPartial({}),
        nextValidatorsHash: new Uint8Array()
      };
    }
    exports$1.ConsensusState = {
      typeUrl: "/ibc.lightclients.tendermint.v1.ConsensusState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(10).fork()).ldelim();
        }
        if (message.root !== void 0) {
          commitment_1.MerkleRoot.encode(message.root, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(26).bytes(message.nextValidatorsHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.root = commitment_1.MerkleRoot.decode(reader, reader.uint32());
              break;
            case 3:
              message.nextValidatorsHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusState();
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.root))
          obj.root = commitment_1.MerkleRoot.fromJSON(object.root);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.root !== void 0 && (obj.root = message.root ? commitment_1.MerkleRoot.toJSON(message.root) : void 0);
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusState();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        if (object.root !== void 0 && object.root !== null) {
          message.root = commitment_1.MerkleRoot.fromPartial(object.root);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMisbehaviour() {
      return {
        clientId: "",
        header1: void 0,
        header2: void 0
      };
    }
    exports$1.Misbehaviour = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Misbehaviour",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.header1 !== void 0) {
          exports$1.Header.encode(message.header1, writer.uint32(18).fork()).ldelim();
        }
        if (message.header2 !== void 0) {
          exports$1.Header.encode(message.header2, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.header1 = exports$1.Header.decode(reader, reader.uint32());
              break;
            case 3:
              message.header2 = exports$1.Header.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.header1))
          obj.header1 = exports$1.Header.fromJSON(object.header1);
        if ((0, helpers_1.isSet)(object.header2))
          obj.header2 = exports$1.Header.fromJSON(object.header2);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.header1 !== void 0 && (obj.header1 = message.header1 ? exports$1.Header.toJSON(message.header1) : void 0);
        message.header2 !== void 0 && (obj.header2 = message.header2 ? exports$1.Header.toJSON(message.header2) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.header1 !== void 0 && object.header1 !== null) {
          message.header1 = exports$1.Header.fromPartial(object.header1);
        }
        if (object.header2 !== void 0 && object.header2 !== null) {
          message.header2 = exports$1.Header.fromPartial(object.header2);
        }
        return message;
      }
    };
    function createBaseHeader3() {
      return {
        signedHeader: void 0,
        validatorSet: void 0,
        trustedHeight: client_1.Height.fromPartial({}),
        trustedValidators: void 0
      };
    }
    exports$1.Header = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Header",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== void 0) {
          types_1.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustedHeight !== void 0) {
          client_1.Height.encode(message.trustedHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.trustedValidators !== void 0) {
          validator_1.ValidatorSet.encode(message.trustedValidators, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = types_1.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustedHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.trustedValidators = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeader3();
        if ((0, helpers_1.isSet)(object.signedHeader))
          obj.signedHeader = types_1.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet))
          obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        if ((0, helpers_1.isSet)(object.trustedHeight))
          obj.trustedHeight = client_1.Height.fromJSON(object.trustedHeight);
        if ((0, helpers_1.isSet)(object.trustedValidators))
          obj.trustedValidators = validator_1.ValidatorSet.fromJSON(object.trustedValidators);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? types_1.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        message.trustedHeight !== void 0 && (obj.trustedHeight = message.trustedHeight ? client_1.Height.toJSON(message.trustedHeight) : void 0);
        message.trustedValidators !== void 0 && (obj.trustedValidators = message.trustedValidators ? validator_1.ValidatorSet.toJSON(message.trustedValidators) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeader3();
        if (object.signedHeader !== void 0 && object.signedHeader !== null) {
          message.signedHeader = types_1.SignedHeader.fromPartial(object.signedHeader);
        }
        if (object.validatorSet !== void 0 && object.validatorSet !== null) {
          message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        }
        if (object.trustedHeight !== void 0 && object.trustedHeight !== null) {
          message.trustedHeight = client_1.Height.fromPartial(object.trustedHeight);
        }
        if (object.trustedValidators !== void 0 && object.trustedValidators !== null) {
          message.trustedValidators = validator_1.ValidatorSet.fromPartial(object.trustedValidators);
        }
        return message;
      }
    };
    function createBaseFraction() {
      return {
        numerator: BigInt(0),
        denominator: BigInt(0)
      };
    }
    exports$1.Fraction = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Fraction",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.numerator !== BigInt(0)) {
          writer.uint32(8).uint64(message.numerator);
        }
        if (message.denominator !== BigInt(0)) {
          writer.uint32(16).uint64(message.denominator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFraction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.numerator = reader.uint64();
              break;
            case 2:
              message.denominator = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFraction();
        if ((0, helpers_1.isSet)(object.numerator))
          obj.numerator = BigInt(object.numerator.toString());
        if ((0, helpers_1.isSet)(object.denominator))
          obj.denominator = BigInt(object.denominator.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.numerator !== void 0 && (obj.numerator = (message.numerator || BigInt(0)).toString());
        message.denominator !== void 0 && (obj.denominator = (message.denominator || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseFraction();
        if (object.numerator !== void 0 && object.numerator !== null) {
          message.numerator = BigInt(object.numerator.toString());
        }
        if (object.denominator !== void 0 && object.denominator !== null) {
          message.denominator = BigInt(object.denominator.toString());
        }
        return message;
      }
    };
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/ibc/queries.js
var require_queries7 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/ibc/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupIbcExtension = setupIbcExtension;
    var query_1 = require_query7();
    var query_2 = require_query8();
    var query_3 = require_query9();
    var query_4 = require_query10();
    var tendermint_1 = require_tendermint();
    var queryclient_1 = require_queryclient2();
    function decodeTendermintClientStateAny(clientState) {
      if (clientState?.typeUrl !== "/ibc.lightclients.tendermint.v1.ClientState") {
        throw new Error(`Unexpected client state type: ${clientState?.typeUrl}`);
      }
      return tendermint_1.ClientState.decode(clientState.value);
    }
    function decodeTendermintConsensusStateAny(clientState) {
      if (clientState?.typeUrl !== "/ibc.lightclients.tendermint.v1.ConsensusState") {
        throw new Error(`Unexpected client state type: ${clientState?.typeUrl}`);
      }
      return tendermint_1.ConsensusState.decode(clientState.value);
    }
    function setupIbcExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const channelQueryService = new query_2.QueryClientImpl(rpc);
      const clientQueryService = new query_3.QueryClientImpl(rpc);
      const connectionQueryService = new query_4.QueryClientImpl(rpc);
      const transferQueryService = new query_1.QueryClientImpl(rpc);
      return {
        ibc: {
          channel: {
            channel: async (portId, channelId) => channelQueryService.Channel({
              portId,
              channelId
            }),
            channels: async (paginationKey) => channelQueryService.Channels({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allChannels: async () => {
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.Channels({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_2.QueryChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({
              connection,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnectionChannels: async (connection) => {
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.ConnectionChannels({
                  connection,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_2.QueryConnectionChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            clientState: async (portId, channelId) => channelQueryService.ChannelClientState({
              portId,
              channelId
            }),
            consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({
              portId,
              channelId,
              revisionNumber: BigInt(revisionNumber),
              revisionHeight: BigInt(revisionHeight)
            }),
            packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({
              channelId,
              portId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allPacketCommitments: async (portId, channelId) => {
              const commitments = [];
              let response;
              let key;
              do {
                response = await channelQueryService.PacketCommitments({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                commitments.push(...response.commitments);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketCommitmentsResponse.fromPartial({
                commitments,
                height: response.height
              });
            },
            packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgements: async (portId, channelId, paginationKey) => {
              const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                portId,
                channelId,
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return channelQueryService.PacketAcknowledgements(request);
            },
            allPacketAcknowledgements: async (portId, channelId) => {
              const acknowledgements = [];
              let response;
              let key;
              do {
                const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                response = await channelQueryService.PacketAcknowledgements(request);
                acknowledgements.push(...response.acknowledgements);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketAcknowledgementsResponse.fromPartial({
                acknowledgements,
                height: response.height
              });
            },
            unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({
              portId,
              channelId,
              packetCommitmentSequences: packetCommitmentSequences.map((s) => BigInt(s))
            }),
            unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({
              portId,
              channelId,
              packetAckSequences: packetAckSequences.map((s) => BigInt(s))
            }),
            nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({
              portId,
              channelId
            })
          },
          client: {
            state: async (clientId) => clientQueryService.ClientState({ clientId }),
            states: async (paginationKey) => clientQueryService.ClientStates({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allStates: async () => {
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_3.QueryClientStatesResponse.fromPartial({
                clientStates
              });
            },
            consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
              clientId,
              revisionHeight: consensusHeight !== void 0 ? BigInt(consensusHeight) : void 0,
              latestHeight: consensusHeight === void 0
            })),
            consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({
              clientId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConsensusStates: async (clientId) => {
              const consensusStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ConsensusStates({
                  clientId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                consensusStates.push(...response.consensusStates);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_3.QueryConsensusStatesResponse.fromPartial({
                consensusStates
              });
            },
            params: async () => clientQueryService.ClientParams({}),
            stateTm: async (clientId) => {
              const response = await clientQueryService.ClientState({ clientId });
              return decodeTendermintClientStateAny(response.clientState);
            },
            statesTm: async (paginationKey) => {
              const { clientStates } = await clientQueryService.ClientStates({
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            allStatesTm: async () => {
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            consensusStateTm: async (clientId, consensusHeight) => {
              const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                clientId,
                revisionHeight: consensusHeight?.revisionHeight,
                revisionNumber: consensusHeight?.revisionNumber,
                latestHeight: consensusHeight === void 0
              }));
              return decodeTendermintConsensusStateAny(response.consensusState);
            }
          },
          connection: {
            connection: async (connectionId) => connectionQueryService.Connection({
              connectionId
            }),
            connections: async (paginationKey) => connectionQueryService.Connections({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnections: async () => {
              const connections = [];
              let response;
              let key;
              do {
                response = await connectionQueryService.Connections({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                connections.push(...response.connections);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_4.QueryConnectionsResponse.fromPartial({
                connections,
                height: response.height
              });
            },
            clientConnections: async (clientId) => connectionQueryService.ClientConnections({
              clientId
            }),
            clientState: async (connectionId) => connectionQueryService.ConnectionClientState({
              connectionId
            }),
            consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
              connectionId,
              revisionHeight: BigInt(revisionHeight)
            }))
          },
          transfer: {
            denomTrace: async (hash2) => transferQueryService.DenomTrace({ hash: hash2 }),
            denomTraces: async (paginationKey) => transferQueryService.DenomTraces({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allDenomTraces: async () => {
              const denomTraces = [];
              let response;
              let key;
              do {
                response = await transferQueryService.DenomTraces({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                denomTraces.push(...response.denomTraces);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_1.QueryDenomTracesResponse.fromPartial({
                denomTraces
              });
            },
            params: async () => transferQueryService.Params({})
          }
        }
      };
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js
var require_mint = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = exports$1.Minter = exports$1.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseMinter2() {
      return {
        inflation: "",
        annualProvisions: ""
      };
    }
    exports$1.Minter = {
      typeUrl: "/cosmos.mint.v1beta1.Minter",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation !== "") {
          writer.uint32(10).string(message.inflation);
        }
        if (message.annualProvisions !== "") {
          writer.uint32(18).string(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMinter2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.string();
              break;
            case 2:
              message.annualProvisions = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMinter2();
        if ((0, helpers_1.isSet)(object.inflation))
          obj.inflation = String(object.inflation);
        if ((0, helpers_1.isSet)(object.annualProvisions))
          obj.annualProvisions = String(object.annualProvisions);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = message.inflation);
        message.annualProvisions !== void 0 && (obj.annualProvisions = message.annualProvisions);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMinter2();
        message.inflation = object.inflation ?? "";
        message.annualProvisions = object.annualProvisions ?? "";
        return message;
      }
    };
    function createBaseParams15() {
      return {
        mintDenom: "",
        inflationRateChange: "",
        inflationMax: "",
        inflationMin: "",
        goalBonded: "",
        blocksPerYear: BigInt(0)
      };
    }
    exports$1.Params = {
      typeUrl: "/cosmos.mint.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mintDenom !== "") {
          writer.uint32(10).string(message.mintDenom);
        }
        if (message.inflationRateChange !== "") {
          writer.uint32(18).string(message.inflationRateChange);
        }
        if (message.inflationMax !== "") {
          writer.uint32(26).string(message.inflationMax);
        }
        if (message.inflationMin !== "") {
          writer.uint32(34).string(message.inflationMin);
        }
        if (message.goalBonded !== "") {
          writer.uint32(42).string(message.goalBonded);
        }
        if (message.blocksPerYear !== BigInt(0)) {
          writer.uint32(48).uint64(message.blocksPerYear);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mintDenom = reader.string();
              break;
            case 2:
              message.inflationRateChange = reader.string();
              break;
            case 3:
              message.inflationMax = reader.string();
              break;
            case 4:
              message.inflationMin = reader.string();
              break;
            case 5:
              message.goalBonded = reader.string();
              break;
            case 6:
              message.blocksPerYear = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if ((0, helpers_1.isSet)(object.mintDenom))
          obj.mintDenom = String(object.mintDenom);
        if ((0, helpers_1.isSet)(object.inflationRateChange))
          obj.inflationRateChange = String(object.inflationRateChange);
        if ((0, helpers_1.isSet)(object.inflationMax))
          obj.inflationMax = String(object.inflationMax);
        if ((0, helpers_1.isSet)(object.inflationMin))
          obj.inflationMin = String(object.inflationMin);
        if ((0, helpers_1.isSet)(object.goalBonded))
          obj.goalBonded = String(object.goalBonded);
        if ((0, helpers_1.isSet)(object.blocksPerYear))
          obj.blocksPerYear = BigInt(object.blocksPerYear.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mintDenom !== void 0 && (obj.mintDenom = message.mintDenom);
        message.inflationRateChange !== void 0 && (obj.inflationRateChange = message.inflationRateChange);
        message.inflationMax !== void 0 && (obj.inflationMax = message.inflationMax);
        message.inflationMin !== void 0 && (obj.inflationMin = message.inflationMin);
        message.goalBonded !== void 0 && (obj.goalBonded = message.goalBonded);
        message.blocksPerYear !== void 0 && (obj.blocksPerYear = (message.blocksPerYear || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        message.mintDenom = object.mintDenom ?? "";
        message.inflationRateChange = object.inflationRateChange ?? "";
        message.inflationMax = object.inflationMax ?? "";
        message.inflationMin = object.inflationMin ?? "";
        message.goalBonded = object.goalBonded ?? "";
        if (object.blocksPerYear !== void 0 && object.blocksPerYear !== null) {
          message.blocksPerYear = BigInt(object.blocksPerYear.toString());
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js
var require_query11 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryAnnualProvisionsResponse = exports$1.QueryAnnualProvisionsRequest = exports$1.QueryInflationResponse = exports$1.QueryInflationRequest = exports$1.QueryParamsResponse = exports$1.QueryParamsRequest = exports$1.protobufPackage = void 0;
    var mint_1 = require_mint();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseQueryParamsRequest18() {
      return {};
    }
    exports$1.QueryParamsRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest18();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest18();
        return message;
      }
    };
    function createBaseQueryParamsResponse18() {
      return {
        params: mint_1.Params.fromPartial({})
      };
    }
    exports$1.QueryParamsResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          mint_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = mint_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse18();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = mint_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? mint_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse18();
        if (object.params !== void 0 && object.params !== null) {
          message.params = mint_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryInflationRequest2() {
      return {};
    }
    exports$1.QueryInflationRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryInflationRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryInflationRequest2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryInflationRequest2();
        return message;
      }
    };
    function createBaseQueryInflationResponse2() {
      return {
        inflation: new Uint8Array()
      };
    }
    exports$1.QueryInflationResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryInflationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation.length !== 0) {
          writer.uint32(10).bytes(message.inflation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryInflationResponse2();
        if ((0, helpers_1.isSet)(object.inflation))
          obj.inflation = (0, helpers_1.bytesFromBase64)(object.inflation);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = (0, helpers_1.base64FromBytes)(message.inflation !== void 0 ? message.inflation : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryInflationResponse2();
        message.inflation = object.inflation ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsRequest2() {
      return {};
    }
    exports$1.QueryAnnualProvisionsRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryAnnualProvisionsRequest2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryAnnualProvisionsRequest2();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsResponse2() {
      return {
        annualProvisions: new Uint8Array()
      };
    }
    exports$1.QueryAnnualProvisionsResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.annualProvisions.length !== 0) {
          writer.uint32(10).bytes(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.annualProvisions = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAnnualProvisionsResponse2();
        if ((0, helpers_1.isSet)(object.annualProvisions))
          obj.annualProvisions = (0, helpers_1.bytesFromBase64)(object.annualProvisions);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.annualProvisions !== void 0 && (obj.annualProvisions = (0, helpers_1.base64FromBytes)(message.annualProvisions !== void 0 ? message.annualProvisions : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAnnualProvisionsResponse2();
        message.annualProvisions = object.annualProvisions ?? new Uint8Array();
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Inflation = this.Inflation.bind(this);
        this.AnnualProvisions = this.AnnualProvisions.bind(this);
      }
      Params(request = {}) {
        const data2 = exports$1.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports$1.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Inflation(request = {}) {
        const data2 = exports$1.QueryInflationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", data2);
        return promise.then((data3) => exports$1.QueryInflationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AnnualProvisions(request = {}) {
        const data2 = exports$1.QueryAnnualProvisionsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", data2);
        return promise.then((data3) => exports$1.QueryAnnualProvisionsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/mint/queries.js
var require_queries8 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/mint/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupMintExtension = setupMintExtension;
    var utils_1 = require_build3();
    var query_1 = require_query11();
    var queryclient_1 = require_queryclient2();
    function setupMintExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        mint: {
          params: async () => {
            const { params } = await queryService.Params({});
            (0, utils_1.assert)(params);
            return {
              blocksPerYear: params.blocksPerYear,
              goalBonded: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.goalBonded),
              inflationMin: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMin),
              inflationMax: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMax),
              inflationRateChange: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
              mintDenom: params.mintDenom
            };
          },
          inflation: async () => {
            const { inflation } = await queryService.Inflation({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(inflation);
          },
          annualProvisions: async () => {
            const { annualProvisions } = await queryService.AnnualProvisions({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(annualProvisions);
          }
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js
var require_aminomessages10 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isAminoMsgUnjail = isAminoMsgUnjail;
    exports$1.createSlashingAminoConverters = createSlashingAminoConverters;
    function isAminoMsgUnjail(msg) {
      return msg.type === "cosmos-sdk/MsgUnjail";
    }
    function createSlashingAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js
var require_slashing = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = exports$1.ValidatorSigningInfo = exports$1.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseValidatorSigningInfo2() {
      return {
        address: "",
        startHeight: BigInt(0),
        indexOffset: BigInt(0),
        jailedUntil: timestamp_1.Timestamp.fromPartial({}),
        tombstoned: false,
        missedBlocksCounter: BigInt(0)
      };
    }
    exports$1.ValidatorSigningInfo = {
      typeUrl: "/cosmos.slashing.v1beta1.ValidatorSigningInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.startHeight !== BigInt(0)) {
          writer.uint32(16).int64(message.startHeight);
        }
        if (message.indexOffset !== BigInt(0)) {
          writer.uint32(24).int64(message.indexOffset);
        }
        if (message.jailedUntil !== void 0) {
          timestamp_1.Timestamp.encode(message.jailedUntil, writer.uint32(34).fork()).ldelim();
        }
        if (message.tombstoned === true) {
          writer.uint32(40).bool(message.tombstoned);
        }
        if (message.missedBlocksCounter !== BigInt(0)) {
          writer.uint32(48).int64(message.missedBlocksCounter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSigningInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.startHeight = reader.int64();
              break;
            case 3:
              message.indexOffset = reader.int64();
              break;
            case 4:
              message.jailedUntil = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.tombstoned = reader.bool();
              break;
            case 6:
              message.missedBlocksCounter = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSigningInfo2();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.startHeight))
          obj.startHeight = BigInt(object.startHeight.toString());
        if ((0, helpers_1.isSet)(object.indexOffset))
          obj.indexOffset = BigInt(object.indexOffset.toString());
        if ((0, helpers_1.isSet)(object.jailedUntil))
          obj.jailedUntil = (0, helpers_1.fromJsonTimestamp)(object.jailedUntil);
        if ((0, helpers_1.isSet)(object.tombstoned))
          obj.tombstoned = Boolean(object.tombstoned);
        if ((0, helpers_1.isSet)(object.missedBlocksCounter))
          obj.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.startHeight !== void 0 && (obj.startHeight = (message.startHeight || BigInt(0)).toString());
        message.indexOffset !== void 0 && (obj.indexOffset = (message.indexOffset || BigInt(0)).toString());
        message.jailedUntil !== void 0 && (obj.jailedUntil = (0, helpers_1.fromTimestamp)(message.jailedUntil).toISOString());
        message.tombstoned !== void 0 && (obj.tombstoned = message.tombstoned);
        message.missedBlocksCounter !== void 0 && (obj.missedBlocksCounter = (message.missedBlocksCounter || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSigningInfo2();
        message.address = object.address ?? "";
        if (object.startHeight !== void 0 && object.startHeight !== null) {
          message.startHeight = BigInt(object.startHeight.toString());
        }
        if (object.indexOffset !== void 0 && object.indexOffset !== null) {
          message.indexOffset = BigInt(object.indexOffset.toString());
        }
        if (object.jailedUntil !== void 0 && object.jailedUntil !== null) {
          message.jailedUntil = timestamp_1.Timestamp.fromPartial(object.jailedUntil);
        }
        message.tombstoned = object.tombstoned ?? false;
        if (object.missedBlocksCounter !== void 0 && object.missedBlocksCounter !== null) {
          message.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        }
        return message;
      }
    };
    function createBaseParams15() {
      return {
        signedBlocksWindow: BigInt(0),
        minSignedPerWindow: new Uint8Array(),
        downtimeJailDuration: duration_1.Duration.fromPartial({}),
        slashFractionDoubleSign: new Uint8Array(),
        slashFractionDowntime: new Uint8Array()
      };
    }
    exports$1.Params = {
      typeUrl: "/cosmos.slashing.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedBlocksWindow !== BigInt(0)) {
          writer.uint32(8).int64(message.signedBlocksWindow);
        }
        if (message.minSignedPerWindow.length !== 0) {
          writer.uint32(18).bytes(message.minSignedPerWindow);
        }
        if (message.downtimeJailDuration !== void 0) {
          duration_1.Duration.encode(message.downtimeJailDuration, writer.uint32(26).fork()).ldelim();
        }
        if (message.slashFractionDoubleSign.length !== 0) {
          writer.uint32(34).bytes(message.slashFractionDoubleSign);
        }
        if (message.slashFractionDowntime.length !== 0) {
          writer.uint32(42).bytes(message.slashFractionDowntime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedBlocksWindow = reader.int64();
              break;
            case 2:
              message.minSignedPerWindow = reader.bytes();
              break;
            case 3:
              message.downtimeJailDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.slashFractionDoubleSign = reader.bytes();
              break;
            case 5:
              message.slashFractionDowntime = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if ((0, helpers_1.isSet)(object.signedBlocksWindow))
          obj.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        if ((0, helpers_1.isSet)(object.minSignedPerWindow))
          obj.minSignedPerWindow = (0, helpers_1.bytesFromBase64)(object.minSignedPerWindow);
        if ((0, helpers_1.isSet)(object.downtimeJailDuration))
          obj.downtimeJailDuration = duration_1.Duration.fromJSON(object.downtimeJailDuration);
        if ((0, helpers_1.isSet)(object.slashFractionDoubleSign))
          obj.slashFractionDoubleSign = (0, helpers_1.bytesFromBase64)(object.slashFractionDoubleSign);
        if ((0, helpers_1.isSet)(object.slashFractionDowntime))
          obj.slashFractionDowntime = (0, helpers_1.bytesFromBase64)(object.slashFractionDowntime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedBlocksWindow !== void 0 && (obj.signedBlocksWindow = (message.signedBlocksWindow || BigInt(0)).toString());
        message.minSignedPerWindow !== void 0 && (obj.minSignedPerWindow = (0, helpers_1.base64FromBytes)(message.minSignedPerWindow !== void 0 ? message.minSignedPerWindow : new Uint8Array()));
        message.downtimeJailDuration !== void 0 && (obj.downtimeJailDuration = message.downtimeJailDuration ? duration_1.Duration.toJSON(message.downtimeJailDuration) : void 0);
        message.slashFractionDoubleSign !== void 0 && (obj.slashFractionDoubleSign = (0, helpers_1.base64FromBytes)(message.slashFractionDoubleSign !== void 0 ? message.slashFractionDoubleSign : new Uint8Array()));
        message.slashFractionDowntime !== void 0 && (obj.slashFractionDowntime = (0, helpers_1.base64FromBytes)(message.slashFractionDowntime !== void 0 ? message.slashFractionDowntime : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        if (object.signedBlocksWindow !== void 0 && object.signedBlocksWindow !== null) {
          message.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        }
        message.minSignedPerWindow = object.minSignedPerWindow ?? new Uint8Array();
        if (object.downtimeJailDuration !== void 0 && object.downtimeJailDuration !== null) {
          message.downtimeJailDuration = duration_1.Duration.fromPartial(object.downtimeJailDuration);
        }
        message.slashFractionDoubleSign = object.slashFractionDoubleSign ?? new Uint8Array();
        message.slashFractionDowntime = object.slashFractionDowntime ?? new Uint8Array();
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js
var require_query12 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QuerySigningInfosResponse = exports$1.QuerySigningInfosRequest = exports$1.QuerySigningInfoResponse = exports$1.QuerySigningInfoRequest = exports$1.QueryParamsResponse = exports$1.QueryParamsRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var slashing_1 = require_slashing();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseQueryParamsRequest18() {
      return {};
    }
    exports$1.QueryParamsRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest18();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest18();
        return message;
      }
    };
    function createBaseQueryParamsResponse18() {
      return {
        params: slashing_1.Params.fromPartial({})
      };
    }
    exports$1.QueryParamsResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          slashing_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = slashing_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse18();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = slashing_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? slashing_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse18();
        if (object.params !== void 0 && object.params !== null) {
          message.params = slashing_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfoRequest2() {
      return {
        consAddress: ""
      };
    }
    exports$1.QuerySigningInfoRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consAddress !== "") {
          writer.uint32(10).string(message.consAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfoRequest2();
        if ((0, helpers_1.isSet)(object.consAddress))
          obj.consAddress = String(object.consAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consAddress !== void 0 && (obj.consAddress = message.consAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfoRequest2();
        message.consAddress = object.consAddress ?? "";
        return message;
      }
    };
    function createBaseQuerySigningInfoResponse2() {
      return {
        valSigningInfo: slashing_1.ValidatorSigningInfo.fromPartial({})
      };
    }
    exports$1.QuerySigningInfoResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.valSigningInfo !== void 0) {
          slashing_1.ValidatorSigningInfo.encode(message.valSigningInfo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.valSigningInfo = slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfoResponse2();
        if ((0, helpers_1.isSet)(object.valSigningInfo))
          obj.valSigningInfo = slashing_1.ValidatorSigningInfo.fromJSON(object.valSigningInfo);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.valSigningInfo !== void 0 && (obj.valSigningInfo = message.valSigningInfo ? slashing_1.ValidatorSigningInfo.toJSON(message.valSigningInfo) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfoResponse2();
        if (object.valSigningInfo !== void 0 && object.valSigningInfo !== null) {
          message.valSigningInfo = slashing_1.ValidatorSigningInfo.fromPartial(object.valSigningInfo);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfosRequest2() {
      return {
        pagination: void 0
      };
    }
    exports$1.QuerySigningInfosRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfosRequest2();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfosRequest2();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfosResponse2() {
      return {
        info: [],
        pagination: void 0
      };
    }
    exports$1.QuerySigningInfosResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.info) {
          slashing_1.ValidatorSigningInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info.push(slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfosResponse2();
        if (Array.isArray(object?.info))
          obj.info = object.info.map((e) => slashing_1.ValidatorSigningInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.info) {
          obj.info = message.info.map((e) => e ? slashing_1.ValidatorSigningInfo.toJSON(e) : void 0);
        } else {
          obj.info = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfosResponse2();
        message.info = object.info?.map((e) => slashing_1.ValidatorSigningInfo.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.SigningInfo = this.SigningInfo.bind(this);
        this.SigningInfos = this.SigningInfos.bind(this);
      }
      Params(request = {}) {
        const data2 = exports$1.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports$1.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SigningInfo(request) {
        const data2 = exports$1.QuerySigningInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", data2);
        return promise.then((data3) => exports$1.QuerySigningInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SigningInfos(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports$1.QuerySigningInfosRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", data2);
        return promise.then((data3) => exports$1.QuerySigningInfosResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/slashing/queries.js
var require_queries9 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/slashing/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupSlashingExtension = setupSlashingExtension;
    var query_1 = require_query12();
    var queryclient_1 = require_queryclient2();
    function setupSlashingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        slashing: {
          signingInfo: async (consAddress) => {
            const response = await queryService.SigningInfo({
              consAddress
            });
            return response;
          },
          signingInfos: async (paginationKey) => {
            const response = await queryService.SigningInfos({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js
var require_aminomessages11 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.protoDecimalToJson = protoDecimalToJson;
    exports$1.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
    exports$1.isAminoMsgEditValidator = isAminoMsgEditValidator;
    exports$1.isAminoMsgDelegate = isAminoMsgDelegate;
    exports$1.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
    exports$1.isAminoMsgUndelegate = isAminoMsgUndelegate;
    exports$1.isAminoMsgCancelUnbondingDelegation = isAminoMsgCancelUnbondingDelegation;
    exports$1.createStakingAminoConverters = createStakingAminoConverters;
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    function protoDecimalToJson(decimal) {
      const parsed = math_1.Decimal.fromAtomics(decimal, 18);
      const [whole, fractional] = parsed.toString().split(".");
      return `${whole}.${(fractional ?? "").padEnd(18, "0")}`;
    }
    function jsonDecimalToProto(decimal) {
      const parsed = math_1.Decimal.fromUserInput(decimal, 18);
      return parsed.atomics;
    }
    function isAminoMsgCreateValidator(msg) {
      return msg.type === "cosmos-sdk/MsgCreateValidator";
    }
    function isAminoMsgEditValidator(msg) {
      return msg.type === "cosmos-sdk/MsgEditValidator";
    }
    function isAminoMsgDelegate(msg) {
      return msg.type === "cosmos-sdk/MsgDelegate";
    }
    function isAminoMsgBeginRedelegate(msg) {
      return msg.type === "cosmos-sdk/MsgBeginRedelegate";
    }
    function isAminoMsgUndelegate(msg) {
      return msg.type === "cosmos-sdk/MsgUndelegate";
    }
    function isAminoMsgCancelUnbondingDelegation(msg) {
      return msg.type === "cosmos-sdk/MsgCancelUnbondingDelegation";
    }
    function createStakingAminoConverters() {
      return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
          aminoType: "cosmos-sdk/MsgBeginRedelegate",
          toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_src_address: validatorSrcAddress,
              validator_dst_address: validatorDstAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorSrcAddress: validator_src_address,
            validatorDstAddress: validator_dst_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
          aminoType: "cosmos-sdk/MsgCreateValidator",
          toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
            (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
            (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              commission: {
                rate: protoDecimalToJson(commission.rate),
                max_rate: protoDecimalToJson(commission.maxRate),
                max_change_rate: protoDecimalToJson(commission.maxChangeRate)
              },
              min_self_delegation: minSelfDelegation,
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              pubkey: (0, proto_signing_1.decodePubkey)(pubkey),
              value
            };
          },
          fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value }) => {
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                securityContact: description.security_contact,
                details: description.details
              },
              commission: {
                rate: jsonDecimalToProto(commission.rate),
                maxRate: jsonDecimalToProto(commission.max_rate),
                maxChangeRate: jsonDecimalToProto(commission.max_change_rate)
              },
              minSelfDelegation: min_self_delegation,
              delegatorAddress: delegator_address,
              validatorAddress: validator_address,
              pubkey: (0, proto_signing_1.encodePubkey)(pubkey),
              value
            };
          }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
          aminoType: "cosmos-sdk/MsgDelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
          aminoType: "cosmos-sdk/MsgEditValidator",
          toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              // empty string in the protobuf document means "do not change"
              commission_rate: commissionRate ? protoDecimalToJson(commissionRate) : void 0,
              // empty string in the protobuf document means "do not change"
              min_self_delegation: minSelfDelegation ? minSelfDelegation : void 0,
              validator_address: validatorAddress
            };
          },
          fromAmino: ({ description, commission_rate, min_self_delegation, validator_address }) => ({
            description: {
              moniker: description.moniker,
              identity: description.identity,
              website: description.website,
              securityContact: description.security_contact,
              details: description.details
            },
            // empty string in the protobuf document means "do not change"
            commissionRate: commission_rate ? jsonDecimalToProto(commission_rate) : "",
            // empty string in the protobuf document means "do not change"
            minSelfDelegation: min_self_delegation ?? "",
            validatorAddress: validator_address
          })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
          aminoType: "cosmos-sdk/MsgUndelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation": {
          aminoType: "cosmos-sdk/MsgCancelUnbondingDelegation",
          toAmino: ({ delegatorAddress, validatorAddress, amount, creationHeight }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount,
              creation_height: creationHeight.toString()
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount, creation_height }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount,
            creationHeight: BigInt(creation_height)
          })
        }
      };
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/params.js
var require_params = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/params.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ABCIParams = exports$1.HashedParams = exports$1.VersionParams = exports$1.ValidatorParams = exports$1.EvidenceParams = exports$1.BlockParams = exports$1.ConsensusParams = exports$1.protobufPackage = void 0;
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "tendermint.types";
    function createBaseConsensusParams2() {
      return {
        block: void 0,
        evidence: void 0,
        validator: void 0,
        version: void 0,
        abci: void 0
      };
    }
    exports$1.ConsensusParams = {
      typeUrl: "/tendermint.types.ConsensusParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== void 0) {
          exports$1.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          exports$1.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== void 0) {
          exports$1.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== void 0) {
          exports$1.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        if (message.abci !== void 0) {
          exports$1.ABCIParams.encode(message.abci, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusParams2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = exports$1.BlockParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.evidence = exports$1.EvidenceParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.validator = exports$1.ValidatorParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.version = exports$1.VersionParams.decode(reader, reader.uint32());
              break;
            case 5:
              message.abci = exports$1.ABCIParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusParams2();
        if ((0, helpers_1.isSet)(object.block))
          obj.block = exports$1.BlockParams.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.evidence))
          obj.evidence = exports$1.EvidenceParams.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports$1.ValidatorParams.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = exports$1.VersionParams.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.abci))
          obj.abci = exports$1.ABCIParams.fromJSON(object.abci);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block ? exports$1.BlockParams.toJSON(message.block) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? exports$1.EvidenceParams.toJSON(message.evidence) : void 0);
        message.validator !== void 0 && (obj.validator = message.validator ? exports$1.ValidatorParams.toJSON(message.validator) : void 0);
        message.version !== void 0 && (obj.version = message.version ? exports$1.VersionParams.toJSON(message.version) : void 0);
        message.abci !== void 0 && (obj.abci = message.abci ? exports$1.ABCIParams.toJSON(message.abci) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusParams2();
        if (object.block !== void 0 && object.block !== null) {
          message.block = exports$1.BlockParams.fromPartial(object.block);
        }
        if (object.evidence !== void 0 && object.evidence !== null) {
          message.evidence = exports$1.EvidenceParams.fromPartial(object.evidence);
        }
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports$1.ValidatorParams.fromPartial(object.validator);
        }
        if (object.version !== void 0 && object.version !== null) {
          message.version = exports$1.VersionParams.fromPartial(object.version);
        }
        if (object.abci !== void 0 && object.abci !== null) {
          message.abci = exports$1.ABCIParams.fromPartial(object.abci);
        }
        return message;
      }
    };
    function createBaseBlockParams2() {
      return {
        maxBytes: BigInt(0),
        maxGas: BigInt(0)
      };
    }
    exports$1.BlockParams = {
      typeUrl: "/tendermint.types.BlockParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.maxBytes);
        }
        if (message.maxGas !== BigInt(0)) {
          writer.uint32(16).int64(message.maxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockParams2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxBytes = reader.int64();
              break;
            case 2:
              message.maxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockParams2();
        if ((0, helpers_1.isSet)(object.maxBytes))
          obj.maxBytes = BigInt(object.maxBytes.toString());
        if ((0, helpers_1.isSet)(object.maxGas))
          obj.maxGas = BigInt(object.maxGas.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        message.maxGas !== void 0 && (obj.maxGas = (message.maxGas || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockParams2();
        if (object.maxBytes !== void 0 && object.maxBytes !== null) {
          message.maxBytes = BigInt(object.maxBytes.toString());
        }
        if (object.maxGas !== void 0 && object.maxGas !== null) {
          message.maxGas = BigInt(object.maxGas.toString());
        }
        return message;
      }
    };
    function createBaseEvidenceParams2() {
      return {
        maxAgeNumBlocks: BigInt(0),
        maxAgeDuration: duration_1.Duration.fromPartial({}),
        maxBytes: BigInt(0)
      };
    }
    exports$1.EvidenceParams = {
      typeUrl: "/tendermint.types.EvidenceParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxAgeNumBlocks !== BigInt(0)) {
          writer.uint32(8).int64(message.maxAgeNumBlocks);
        }
        if (message.maxAgeDuration !== void 0) {
          duration_1.Duration.encode(message.maxAgeDuration, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxBytes !== BigInt(0)) {
          writer.uint32(24).int64(message.maxBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceParams2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxAgeNumBlocks = reader.int64();
              break;
            case 2:
              message.maxAgeDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxBytes = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidenceParams2();
        if ((0, helpers_1.isSet)(object.maxAgeNumBlocks))
          obj.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        if ((0, helpers_1.isSet)(object.maxAgeDuration))
          obj.maxAgeDuration = duration_1.Duration.fromJSON(object.maxAgeDuration);
        if ((0, helpers_1.isSet)(object.maxBytes))
          obj.maxBytes = BigInt(object.maxBytes.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxAgeNumBlocks !== void 0 && (obj.maxAgeNumBlocks = (message.maxAgeNumBlocks || BigInt(0)).toString());
        message.maxAgeDuration !== void 0 && (obj.maxAgeDuration = message.maxAgeDuration ? duration_1.Duration.toJSON(message.maxAgeDuration) : void 0);
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidenceParams2();
        if (object.maxAgeNumBlocks !== void 0 && object.maxAgeNumBlocks !== null) {
          message.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        }
        if (object.maxAgeDuration !== void 0 && object.maxAgeDuration !== null) {
          message.maxAgeDuration = duration_1.Duration.fromPartial(object.maxAgeDuration);
        }
        if (object.maxBytes !== void 0 && object.maxBytes !== null) {
          message.maxBytes = BigInt(object.maxBytes.toString());
        }
        return message;
      }
    };
    function createBaseValidatorParams2() {
      return {
        pubKeyTypes: []
      };
    }
    exports$1.ValidatorParams = {
      typeUrl: "/tendermint.types.ValidatorParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pubKeyTypes) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorParams2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKeyTypes.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorParams2();
        if (Array.isArray(object?.pubKeyTypes))
          obj.pubKeyTypes = object.pubKeyTypes.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pubKeyTypes) {
          obj.pubKeyTypes = message.pubKeyTypes.map((e) => e);
        } else {
          obj.pubKeyTypes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorParams2();
        message.pubKeyTypes = object.pubKeyTypes?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseVersionParams2() {
      return {
        app: BigInt(0)
      };
    }
    exports$1.VersionParams = {
      typeUrl: "/tendermint.types.VersionParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.app !== BigInt(0)) {
          writer.uint32(8).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersionParams2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVersionParams2();
        if ((0, helpers_1.isSet)(object.app))
          obj.app = BigInt(object.app.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.app !== void 0 && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVersionParams2();
        if (object.app !== void 0 && object.app !== null) {
          message.app = BigInt(object.app.toString());
        }
        return message;
      }
    };
    function createBaseHashedParams() {
      return {
        blockMaxBytes: BigInt(0),
        blockMaxGas: BigInt(0)
      };
    }
    exports$1.HashedParams = {
      typeUrl: "/tendermint.types.HashedParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockMaxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.blockMaxBytes);
        }
        if (message.blockMaxGas !== BigInt(0)) {
          writer.uint32(16).int64(message.blockMaxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHashedParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockMaxBytes = reader.int64();
              break;
            case 2:
              message.blockMaxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHashedParams();
        if ((0, helpers_1.isSet)(object.blockMaxBytes))
          obj.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        if ((0, helpers_1.isSet)(object.blockMaxGas))
          obj.blockMaxGas = BigInt(object.blockMaxGas.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockMaxBytes !== void 0 && (obj.blockMaxBytes = (message.blockMaxBytes || BigInt(0)).toString());
        message.blockMaxGas !== void 0 && (obj.blockMaxGas = (message.blockMaxGas || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHashedParams();
        if (object.blockMaxBytes !== void 0 && object.blockMaxBytes !== null) {
          message.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        }
        if (object.blockMaxGas !== void 0 && object.blockMaxGas !== null) {
          message.blockMaxGas = BigInt(object.blockMaxGas.toString());
        }
        return message;
      }
    };
    function createBaseABCIParams2() {
      return {
        voteExtensionsEnableHeight: BigInt(0)
      };
    }
    exports$1.ABCIParams = {
      typeUrl: "/tendermint.types.ABCIParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteExtensionsEnableHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.voteExtensionsEnableHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseABCIParams2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteExtensionsEnableHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseABCIParams2();
        if ((0, helpers_1.isSet)(object.voteExtensionsEnableHeight))
          obj.voteExtensionsEnableHeight = BigInt(object.voteExtensionsEnableHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteExtensionsEnableHeight !== void 0 && (obj.voteExtensionsEnableHeight = (message.voteExtensionsEnableHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseABCIParams2();
        if (object.voteExtensionsEnableHeight !== void 0 && object.voteExtensionsEnableHeight !== null) {
          message.voteExtensionsEnableHeight = BigInt(object.voteExtensionsEnableHeight.toString());
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/tendermint/abci/types.js
var require_types4 = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/abci/types.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ResponsePrepareProposal = exports$1.ResponseApplySnapshotChunk = exports$1.ResponseLoadSnapshotChunk = exports$1.ResponseOfferSnapshot = exports$1.ResponseListSnapshots = exports$1.ResponseCommit = exports$1.ResponseCheckTx = exports$1.ResponseQuery = exports$1.ResponseInitChain = exports$1.ResponseInfo = exports$1.ResponseFlush = exports$1.ResponseEcho = exports$1.ResponseException = exports$1.Response = exports$1.RequestFinalizeBlock = exports$1.RequestVerifyVoteExtension = exports$1.RequestExtendVote = exports$1.RequestProcessProposal = exports$1.RequestPrepareProposal = exports$1.RequestApplySnapshotChunk = exports$1.RequestLoadSnapshotChunk = exports$1.RequestOfferSnapshot = exports$1.RequestListSnapshots = exports$1.RequestCommit = exports$1.RequestCheckTx = exports$1.RequestQuery = exports$1.RequestInitChain = exports$1.RequestInfo = exports$1.RequestFlush = exports$1.RequestEcho = exports$1.Request = exports$1.misbehaviorTypeToJSON = exports$1.misbehaviorTypeFromJSON = exports$1.MisbehaviorType = exports$1.responseVerifyVoteExtension_VerifyStatusToJSON = exports$1.responseVerifyVoteExtension_VerifyStatusFromJSON = exports$1.ResponseVerifyVoteExtension_VerifyStatus = exports$1.responseProcessProposal_ProposalStatusToJSON = exports$1.responseProcessProposal_ProposalStatusFromJSON = exports$1.ResponseProcessProposal_ProposalStatus = exports$1.responseApplySnapshotChunk_ResultToJSON = exports$1.responseApplySnapshotChunk_ResultFromJSON = exports$1.ResponseApplySnapshotChunk_Result = exports$1.responseOfferSnapshot_ResultToJSON = exports$1.responseOfferSnapshot_ResultFromJSON = exports$1.ResponseOfferSnapshot_Result = exports$1.checkTxTypeToJSON = exports$1.checkTxTypeFromJSON = exports$1.CheckTxType = exports$1.protobufPackage = void 0;
    exports$1.Snapshot = exports$1.Misbehavior = exports$1.ExtendedVoteInfo = exports$1.VoteInfo = exports$1.ValidatorUpdate = exports$1.Validator = exports$1.TxResult = exports$1.ExecTxResult = exports$1.EventAttribute = exports$1.Event = exports$1.ExtendedCommitInfo = exports$1.CommitInfo = exports$1.ResponseFinalizeBlock = exports$1.ResponseVerifyVoteExtension = exports$1.ResponseExtendVote = exports$1.ResponseProcessProposal = void 0;
    var timestamp_1 = require_timestamp();
    var params_1 = require_params();
    var proof_1 = require_proof();
    var keys_1 = require_keys4();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "tendermint.abci";
    var CheckTxType;
    (function(CheckTxType2) {
      CheckTxType2[CheckTxType2["NEW"] = 0] = "NEW";
      CheckTxType2[CheckTxType2["RECHECK"] = 1] = "RECHECK";
      CheckTxType2[CheckTxType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CheckTxType || (exports$1.CheckTxType = CheckTxType = {}));
    function checkTxTypeFromJSON2(object) {
      switch (object) {
        case 0:
        case "NEW":
          return CheckTxType.NEW;
        case 1:
        case "RECHECK":
          return CheckTxType.RECHECK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return CheckTxType.UNRECOGNIZED;
      }
    }
    exports$1.checkTxTypeFromJSON = checkTxTypeFromJSON2;
    function checkTxTypeToJSON2(object) {
      switch (object) {
        case CheckTxType.NEW:
          return "NEW";
        case CheckTxType.RECHECK:
          return "RECHECK";
        case CheckTxType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.checkTxTypeToJSON = checkTxTypeToJSON2;
    var ResponseOfferSnapshot_Result;
    (function(ResponseOfferSnapshot_Result2) {
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ABORT"] = 2] = "ABORT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT"] = 3] = "REJECT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_SENDER"] = 5] = "REJECT_SENDER";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseOfferSnapshot_Result || (exports$1.ResponseOfferSnapshot_Result = ResponseOfferSnapshot_Result = {}));
    function responseOfferSnapshot_ResultFromJSON2(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseOfferSnapshot_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseOfferSnapshot_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseOfferSnapshot_Result.ABORT;
        case 3:
        case "REJECT":
          return ResponseOfferSnapshot_Result.REJECT;
        case 4:
        case "REJECT_FORMAT":
          return ResponseOfferSnapshot_Result.REJECT_FORMAT;
        case 5:
        case "REJECT_SENDER":
          return ResponseOfferSnapshot_Result.REJECT_SENDER;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseOfferSnapshot_Result.UNRECOGNIZED;
      }
    }
    exports$1.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON2;
    function responseOfferSnapshot_ResultToJSON2(object) {
      switch (object) {
        case ResponseOfferSnapshot_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseOfferSnapshot_Result.ACCEPT:
          return "ACCEPT";
        case ResponseOfferSnapshot_Result.ABORT:
          return "ABORT";
        case ResponseOfferSnapshot_Result.REJECT:
          return "REJECT";
        case ResponseOfferSnapshot_Result.REJECT_FORMAT:
          return "REJECT_FORMAT";
        case ResponseOfferSnapshot_Result.REJECT_SENDER:
          return "REJECT_SENDER";
        case ResponseOfferSnapshot_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON2;
    var ResponseApplySnapshotChunk_Result;
    (function(ResponseApplySnapshotChunk_Result2) {
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ABORT"] = 2] = "ABORT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY"] = 3] = "RETRY";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseApplySnapshotChunk_Result || (exports$1.ResponseApplySnapshotChunk_Result = ResponseApplySnapshotChunk_Result = {}));
    function responseApplySnapshotChunk_ResultFromJSON2(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseApplySnapshotChunk_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseApplySnapshotChunk_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseApplySnapshotChunk_Result.ABORT;
        case 3:
        case "RETRY":
          return ResponseApplySnapshotChunk_Result.RETRY;
        case 4:
        case "RETRY_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;
        case 5:
        case "REJECT_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;
      }
    }
    exports$1.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON2;
    function responseApplySnapshotChunk_ResultToJSON2(object) {
      switch (object) {
        case ResponseApplySnapshotChunk_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseApplySnapshotChunk_Result.ACCEPT:
          return "ACCEPT";
        case ResponseApplySnapshotChunk_Result.ABORT:
          return "ABORT";
        case ResponseApplySnapshotChunk_Result.RETRY:
          return "RETRY";
        case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:
          return "RETRY_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:
          return "REJECT_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON2;
    var ResponseProcessProposal_ProposalStatus;
    (function(ResponseProcessProposal_ProposalStatus2) {
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["ACCEPT"] = 1] = "ACCEPT";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["REJECT"] = 2] = "REJECT";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseProcessProposal_ProposalStatus || (exports$1.ResponseProcessProposal_ProposalStatus = ResponseProcessProposal_ProposalStatus = {}));
    function responseProcessProposal_ProposalStatusFromJSON2(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseProcessProposal_ProposalStatus.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseProcessProposal_ProposalStatus.ACCEPT;
        case 2:
        case "REJECT":
          return ResponseProcessProposal_ProposalStatus.REJECT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseProcessProposal_ProposalStatus.UNRECOGNIZED;
      }
    }
    exports$1.responseProcessProposal_ProposalStatusFromJSON = responseProcessProposal_ProposalStatusFromJSON2;
    function responseProcessProposal_ProposalStatusToJSON2(object) {
      switch (object) {
        case ResponseProcessProposal_ProposalStatus.UNKNOWN:
          return "UNKNOWN";
        case ResponseProcessProposal_ProposalStatus.ACCEPT:
          return "ACCEPT";
        case ResponseProcessProposal_ProposalStatus.REJECT:
          return "REJECT";
        case ResponseProcessProposal_ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.responseProcessProposal_ProposalStatusToJSON = responseProcessProposal_ProposalStatusToJSON2;
    var ResponseVerifyVoteExtension_VerifyStatus;
    (function(ResponseVerifyVoteExtension_VerifyStatus2) {
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["ACCEPT"] = 1] = "ACCEPT";
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["REJECT"] = 2] = "REJECT";
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseVerifyVoteExtension_VerifyStatus || (exports$1.ResponseVerifyVoteExtension_VerifyStatus = ResponseVerifyVoteExtension_VerifyStatus = {}));
    function responseVerifyVoteExtension_VerifyStatusFromJSON2(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseVerifyVoteExtension_VerifyStatus.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseVerifyVoteExtension_VerifyStatus.ACCEPT;
        case 2:
        case "REJECT":
          return ResponseVerifyVoteExtension_VerifyStatus.REJECT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseVerifyVoteExtension_VerifyStatus.UNRECOGNIZED;
      }
    }
    exports$1.responseVerifyVoteExtension_VerifyStatusFromJSON = responseVerifyVoteExtension_VerifyStatusFromJSON2;
    function responseVerifyVoteExtension_VerifyStatusToJSON2(object) {
      switch (object) {
        case ResponseVerifyVoteExtension_VerifyStatus.UNKNOWN:
          return "UNKNOWN";
        case ResponseVerifyVoteExtension_VerifyStatus.ACCEPT:
          return "ACCEPT";
        case ResponseVerifyVoteExtension_VerifyStatus.REJECT:
          return "REJECT";
        case ResponseVerifyVoteExtension_VerifyStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.responseVerifyVoteExtension_VerifyStatusToJSON = responseVerifyVoteExtension_VerifyStatusToJSON2;
    var MisbehaviorType;
    (function(MisbehaviorType2) {
      MisbehaviorType2[MisbehaviorType2["UNKNOWN"] = 0] = "UNKNOWN";
      MisbehaviorType2[MisbehaviorType2["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
      MisbehaviorType2[MisbehaviorType2["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
      MisbehaviorType2[MisbehaviorType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MisbehaviorType || (exports$1.MisbehaviorType = MisbehaviorType = {}));
    function misbehaviorTypeFromJSON2(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return MisbehaviorType.UNKNOWN;
        case 1:
        case "DUPLICATE_VOTE":
          return MisbehaviorType.DUPLICATE_VOTE;
        case 2:
        case "LIGHT_CLIENT_ATTACK":
          return MisbehaviorType.LIGHT_CLIENT_ATTACK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return MisbehaviorType.UNRECOGNIZED;
      }
    }
    exports$1.misbehaviorTypeFromJSON = misbehaviorTypeFromJSON2;
    function misbehaviorTypeToJSON2(object) {
      switch (object) {
        case MisbehaviorType.UNKNOWN:
          return "UNKNOWN";
        case MisbehaviorType.DUPLICATE_VOTE:
          return "DUPLICATE_VOTE";
        case MisbehaviorType.LIGHT_CLIENT_ATTACK:
          return "LIGHT_CLIENT_ATTACK";
        case MisbehaviorType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.misbehaviorTypeToJSON = misbehaviorTypeToJSON2;
    function createBaseRequest() {
      return {
        echo: void 0,
        flush: void 0,
        info: void 0,
        initChain: void 0,
        query: void 0,
        checkTx: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0,
        prepareProposal: void 0,
        processProposal: void 0,
        extendVote: void 0,
        verifyVoteExtension: void 0,
        finalizeBlock: void 0
      };
    }
    exports$1.Request = {
      typeUrl: "/tendermint.abci.Request",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.echo !== void 0) {
          exports$1.RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports$1.RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports$1.RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports$1.RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports$1.RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports$1.RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports$1.RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports$1.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports$1.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports$1.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports$1.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.prepareProposal !== void 0) {
          exports$1.RequestPrepareProposal.encode(message.prepareProposal, writer.uint32(130).fork()).ldelim();
        }
        if (message.processProposal !== void 0) {
          exports$1.RequestProcessProposal.encode(message.processProposal, writer.uint32(138).fork()).ldelim();
        }
        if (message.extendVote !== void 0) {
          exports$1.RequestExtendVote.encode(message.extendVote, writer.uint32(146).fork()).ldelim();
        }
        if (message.verifyVoteExtension !== void 0) {
          exports$1.RequestVerifyVoteExtension.encode(message.verifyVoteExtension, writer.uint32(154).fork()).ldelim();
        }
        if (message.finalizeBlock !== void 0) {
          exports$1.RequestFinalizeBlock.encode(message.finalizeBlock, writer.uint32(162).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.echo = exports$1.RequestEcho.decode(reader, reader.uint32());
              break;
            case 2:
              message.flush = exports$1.RequestFlush.decode(reader, reader.uint32());
              break;
            case 3:
              message.info = exports$1.RequestInfo.decode(reader, reader.uint32());
              break;
            case 5:
              message.initChain = exports$1.RequestInitChain.decode(reader, reader.uint32());
              break;
            case 6:
              message.query = exports$1.RequestQuery.decode(reader, reader.uint32());
              break;
            case 8:
              message.checkTx = exports$1.RequestCheckTx.decode(reader, reader.uint32());
              break;
            case 11:
              message.commit = exports$1.RequestCommit.decode(reader, reader.uint32());
              break;
            case 12:
              message.listSnapshots = exports$1.RequestListSnapshots.decode(reader, reader.uint32());
              break;
            case 13:
              message.offerSnapshot = exports$1.RequestOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 14:
              message.loadSnapshotChunk = exports$1.RequestLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 15:
              message.applySnapshotChunk = exports$1.RequestApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.prepareProposal = exports$1.RequestPrepareProposal.decode(reader, reader.uint32());
              break;
            case 17:
              message.processProposal = exports$1.RequestProcessProposal.decode(reader, reader.uint32());
              break;
            case 18:
              message.extendVote = exports$1.RequestExtendVote.decode(reader, reader.uint32());
              break;
            case 19:
              message.verifyVoteExtension = exports$1.RequestVerifyVoteExtension.decode(reader, reader.uint32());
              break;
            case 20:
              message.finalizeBlock = exports$1.RequestFinalizeBlock.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequest();
        if ((0, helpers_1.isSet)(object.echo))
          obj.echo = exports$1.RequestEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush))
          obj.flush = exports$1.RequestFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = exports$1.RequestInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain))
          obj.initChain = exports$1.RequestInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query))
          obj.query = exports$1.RequestQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.checkTx))
          obj.checkTx = exports$1.RequestCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports$1.RequestCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots))
          obj.listSnapshots = exports$1.RequestListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot))
          obj.offerSnapshot = exports$1.RequestOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk))
          obj.loadSnapshotChunk = exports$1.RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk))
          obj.applySnapshotChunk = exports$1.RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal))
          obj.prepareProposal = exports$1.RequestPrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal))
          obj.processProposal = exports$1.RequestProcessProposal.fromJSON(object.processProposal);
        if ((0, helpers_1.isSet)(object.extendVote))
          obj.extendVote = exports$1.RequestExtendVote.fromJSON(object.extendVote);
        if ((0, helpers_1.isSet)(object.verifyVoteExtension))
          obj.verifyVoteExtension = exports$1.RequestVerifyVoteExtension.fromJSON(object.verifyVoteExtension);
        if ((0, helpers_1.isSet)(object.finalizeBlock))
          obj.finalizeBlock = exports$1.RequestFinalizeBlock.fromJSON(object.finalizeBlock);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.echo !== void 0 && (obj.echo = message.echo ? exports$1.RequestEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports$1.RequestFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports$1.RequestInfo.toJSON(message.info) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports$1.RequestInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports$1.RequestQuery.toJSON(message.query) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports$1.RequestCheckTx.toJSON(message.checkTx) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports$1.RequestCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports$1.RequestListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports$1.RequestOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports$1.RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports$1.RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        message.prepareProposal !== void 0 && (obj.prepareProposal = message.prepareProposal ? exports$1.RequestPrepareProposal.toJSON(message.prepareProposal) : void 0);
        message.processProposal !== void 0 && (obj.processProposal = message.processProposal ? exports$1.RequestProcessProposal.toJSON(message.processProposal) : void 0);
        message.extendVote !== void 0 && (obj.extendVote = message.extendVote ? exports$1.RequestExtendVote.toJSON(message.extendVote) : void 0);
        message.verifyVoteExtension !== void 0 && (obj.verifyVoteExtension = message.verifyVoteExtension ? exports$1.RequestVerifyVoteExtension.toJSON(message.verifyVoteExtension) : void 0);
        message.finalizeBlock !== void 0 && (obj.finalizeBlock = message.finalizeBlock ? exports$1.RequestFinalizeBlock.toJSON(message.finalizeBlock) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequest();
        if (object.echo !== void 0 && object.echo !== null) {
          message.echo = exports$1.RequestEcho.fromPartial(object.echo);
        }
        if (object.flush !== void 0 && object.flush !== null) {
          message.flush = exports$1.RequestFlush.fromPartial(object.flush);
        }
        if (object.info !== void 0 && object.info !== null) {
          message.info = exports$1.RequestInfo.fromPartial(object.info);
        }
        if (object.initChain !== void 0 && object.initChain !== null) {
          message.initChain = exports$1.RequestInitChain.fromPartial(object.initChain);
        }
        if (object.query !== void 0 && object.query !== null) {
          message.query = exports$1.RequestQuery.fromPartial(object.query);
        }
        if (object.checkTx !== void 0 && object.checkTx !== null) {
          message.checkTx = exports$1.RequestCheckTx.fromPartial(object.checkTx);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports$1.RequestCommit.fromPartial(object.commit);
        }
        if (object.listSnapshots !== void 0 && object.listSnapshots !== null) {
          message.listSnapshots = exports$1.RequestListSnapshots.fromPartial(object.listSnapshots);
        }
        if (object.offerSnapshot !== void 0 && object.offerSnapshot !== null) {
          message.offerSnapshot = exports$1.RequestOfferSnapshot.fromPartial(object.offerSnapshot);
        }
        if (object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null) {
          message.loadSnapshotChunk = exports$1.RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        }
        if (object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null) {
          message.applySnapshotChunk = exports$1.RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        }
        if (object.prepareProposal !== void 0 && object.prepareProposal !== null) {
          message.prepareProposal = exports$1.RequestPrepareProposal.fromPartial(object.prepareProposal);
        }
        if (object.processProposal !== void 0 && object.processProposal !== null) {
          message.processProposal = exports$1.RequestProcessProposal.fromPartial(object.processProposal);
        }
        if (object.extendVote !== void 0 && object.extendVote !== null) {
          message.extendVote = exports$1.RequestExtendVote.fromPartial(object.extendVote);
        }
        if (object.verifyVoteExtension !== void 0 && object.verifyVoteExtension !== null) {
          message.verifyVoteExtension = exports$1.RequestVerifyVoteExtension.fromPartial(object.verifyVoteExtension);
        }
        if (object.finalizeBlock !== void 0 && object.finalizeBlock !== null) {
          message.finalizeBlock = exports$1.RequestFinalizeBlock.fromPartial(object.finalizeBlock);
        }
        return message;
      }
    };
    function createBaseRequestEcho2() {
      return {
        message: ""
      };
    }
    exports$1.RequestEcho = {
      typeUrl: "/tendermint.abci.RequestEcho",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestEcho2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestEcho2();
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestEcho2();
        message.message = object.message ?? "";
        return message;
      }
    };
    function createBaseRequestFlush2() {
      return {};
    }
    exports$1.RequestFlush = {
      typeUrl: "/tendermint.abci.RequestFlush",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestFlush2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseRequestFlush2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestFlush2();
        return message;
      }
    };
    function createBaseRequestInfo2() {
      return {
        version: "",
        blockVersion: BigInt(0),
        p2pVersion: BigInt(0),
        abciVersion: ""
      };
    }
    exports$1.RequestInfo = {
      typeUrl: "/tendermint.abci.RequestInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (message.blockVersion !== BigInt(0)) {
          writer.uint32(16).uint64(message.blockVersion);
        }
        if (message.p2pVersion !== BigInt(0)) {
          writer.uint32(24).uint64(message.p2pVersion);
        }
        if (message.abciVersion !== "") {
          writer.uint32(34).string(message.abciVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.blockVersion = reader.uint64();
              break;
            case 3:
              message.p2pVersion = reader.uint64();
              break;
            case 4:
              message.abciVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestInfo2();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.blockVersion))
          obj.blockVersion = BigInt(object.blockVersion.toString());
        if ((0, helpers_1.isSet)(object.p2pVersion))
          obj.p2pVersion = BigInt(object.p2pVersion.toString());
        if ((0, helpers_1.isSet)(object.abciVersion))
          obj.abciVersion = String(object.abciVersion);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        message.blockVersion !== void 0 && (obj.blockVersion = (message.blockVersion || BigInt(0)).toString());
        message.p2pVersion !== void 0 && (obj.p2pVersion = (message.p2pVersion || BigInt(0)).toString());
        message.abciVersion !== void 0 && (obj.abciVersion = message.abciVersion);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestInfo2();
        message.version = object.version ?? "";
        if (object.blockVersion !== void 0 && object.blockVersion !== null) {
          message.blockVersion = BigInt(object.blockVersion.toString());
        }
        if (object.p2pVersion !== void 0 && object.p2pVersion !== null) {
          message.p2pVersion = BigInt(object.p2pVersion.toString());
        }
        message.abciVersion = object.abciVersion ?? "";
        return message;
      }
    };
    function createBaseRequestInitChain2() {
      return {
        time: timestamp_1.Timestamp.fromPartial({}),
        chainId: "",
        consensusParams: void 0,
        validators: [],
        appStateBytes: new Uint8Array(),
        initialHeight: BigInt(0)
      };
    }
    exports$1.RequestInitChain = {
      typeUrl: "/tendermint.abci.RequestInitChain",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.consensusParams !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports$1.ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.appStateBytes.length !== 0) {
          writer.uint32(42).bytes(message.appStateBytes);
        }
        if (message.initialHeight !== BigInt(0)) {
          writer.uint32(48).int64(message.initialHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInitChain2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.validators.push(exports$1.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 5:
              message.appStateBytes = reader.bytes();
              break;
            case 6:
              message.initialHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestInitChain2();
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.consensusParams))
          obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => exports$1.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appStateBytes))
          obj.appStateBytes = (0, helpers_1.bytesFromBase64)(object.appStateBytes);
        if ((0, helpers_1.isSet)(object.initialHeight))
          obj.initialHeight = BigInt(object.initialHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports$1.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appStateBytes !== void 0 && (obj.appStateBytes = (0, helpers_1.base64FromBytes)(message.appStateBytes !== void 0 ? message.appStateBytes : new Uint8Array()));
        message.initialHeight !== void 0 && (obj.initialHeight = (message.initialHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestInitChain2();
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.chainId = object.chainId ?? "";
        if (object.consensusParams !== void 0 && object.consensusParams !== null) {
          message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        }
        message.validators = object.validators?.map((e) => exports$1.ValidatorUpdate.fromPartial(e)) || [];
        message.appStateBytes = object.appStateBytes ?? new Uint8Array();
        if (object.initialHeight !== void 0 && object.initialHeight !== null) {
          message.initialHeight = BigInt(object.initialHeight.toString());
        }
        return message;
      }
    };
    function createBaseRequestQuery2() {
      return {
        data: new Uint8Array(),
        path: "",
        height: BigInt(0),
        prove: false
      };
    }
    exports$1.RequestQuery = {
      typeUrl: "/tendermint.abci.RequestQuery",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.path !== "") {
          writer.uint32(18).string(message.path);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.prove === true) {
          writer.uint32(32).bool(message.prove);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestQuery2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.path = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.prove = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestQuery2();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.path))
          obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.prove))
          obj.prove = Boolean(object.prove);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.path !== void 0 && (obj.path = message.path);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.prove !== void 0 && (obj.prove = message.prove);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestQuery2();
        message.data = object.data ?? new Uint8Array();
        message.path = object.path ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.prove = object.prove ?? false;
        return message;
      }
    };
    function createBaseRequestCheckTx2() {
      return {
        tx: new Uint8Array(),
        type: 0
      };
    }
    exports$1.RequestCheckTx = {
      typeUrl: "/tendermint.abci.RequestCheckTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx.length !== 0) {
          writer.uint32(10).bytes(message.tx);
        }
        if (message.type !== 0) {
          writer.uint32(16).int32(message.type);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCheckTx2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = reader.bytes();
              break;
            case 2:
              message.type = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestCheckTx2();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.type))
          obj.type = checkTxTypeFromJSON2(object.type);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.type !== void 0 && (obj.type = checkTxTypeToJSON2(message.type));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestCheckTx2();
        message.tx = object.tx ?? new Uint8Array();
        message.type = object.type ?? 0;
        return message;
      }
    };
    function createBaseRequestCommit2() {
      return {};
    }
    exports$1.RequestCommit = {
      typeUrl: "/tendermint.abci.RequestCommit",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCommit2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseRequestCommit2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestCommit2();
        return message;
      }
    };
    function createBaseRequestListSnapshots2() {
      return {};
    }
    exports$1.RequestListSnapshots = {
      typeUrl: "/tendermint.abci.RequestListSnapshots",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestListSnapshots2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseRequestListSnapshots2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestListSnapshots2();
        return message;
      }
    };
    function createBaseRequestOfferSnapshot2() {
      return {
        snapshot: void 0,
        appHash: new Uint8Array()
      };
    }
    exports$1.RequestOfferSnapshot = {
      typeUrl: "/tendermint.abci.RequestOfferSnapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.snapshot !== void 0) {
          exports$1.Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(18).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestOfferSnapshot2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshot = exports$1.Snapshot.decode(reader, reader.uint32());
              break;
            case 2:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestOfferSnapshot2();
        if ((0, helpers_1.isSet)(object.snapshot))
          obj.snapshot = exports$1.Snapshot.fromJSON(object.snapshot);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.snapshot !== void 0 && (obj.snapshot = message.snapshot ? exports$1.Snapshot.toJSON(message.snapshot) : void 0);
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestOfferSnapshot2();
        if (object.snapshot !== void 0 && object.snapshot !== null) {
          message.snapshot = exports$1.Snapshot.fromPartial(object.snapshot);
        }
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestLoadSnapshotChunk2() {
      return {
        height: BigInt(0),
        format: 0,
        chunk: 0
      };
    }
    exports$1.RequestLoadSnapshotChunk = {
      typeUrl: "/tendermint.abci.RequestLoadSnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunk !== 0) {
          writer.uint32(24).uint32(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestLoadSnapshotChunk2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunk = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestLoadSnapshotChunk2();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format))
          obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = Number(object.chunk);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunk !== void 0 && (obj.chunk = Math.round(message.chunk));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestLoadSnapshotChunk2();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.format = object.format ?? 0;
        message.chunk = object.chunk ?? 0;
        return message;
      }
    };
    function createBaseRequestApplySnapshotChunk2() {
      return {
        index: 0,
        chunk: new Uint8Array(),
        sender: ""
      };
    }
    exports$1.RequestApplySnapshotChunk = {
      typeUrl: "/tendermint.abci.RequestApplySnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.chunk.length !== 0) {
          writer.uint32(18).bytes(message.chunk);
        }
        if (message.sender !== "") {
          writer.uint32(26).string(message.sender);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestApplySnapshotChunk2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.chunk = reader.bytes();
              break;
            case 3:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestApplySnapshotChunk2();
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.chunk !== void 0 && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        message.sender !== void 0 && (obj.sender = message.sender);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestApplySnapshotChunk2();
        message.index = object.index ?? 0;
        message.chunk = object.chunk ?? new Uint8Array();
        message.sender = object.sender ?? "";
        return message;
      }
    };
    function createBaseRequestPrepareProposal2() {
      return {
        maxTxBytes: BigInt(0),
        txs: [],
        localLastCommit: exports$1.ExtendedCommitInfo.fromPartial({}),
        misbehavior: [],
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports$1.RequestPrepareProposal = {
      typeUrl: "/tendermint.abci.RequestPrepareProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxTxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.maxTxBytes);
        }
        for (const v of message.txs) {
          writer.uint32(18).bytes(v);
        }
        if (message.localLastCommit !== void 0) {
          exports$1.ExtendedCommitInfo.encode(message.localLastCommit, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports$1.Misbehavior.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestPrepareProposal2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxTxBytes = reader.int64();
              break;
            case 2:
              message.txs.push(reader.bytes());
              break;
            case 3:
              message.localLastCommit = exports$1.ExtendedCommitInfo.decode(reader, reader.uint32());
              break;
            case 4:
              message.misbehavior.push(exports$1.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestPrepareProposal2();
        if ((0, helpers_1.isSet)(object.maxTxBytes))
          obj.maxTxBytes = BigInt(object.maxTxBytes.toString());
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.localLastCommit))
          obj.localLastCommit = exports$1.ExtendedCommitInfo.fromJSON(object.localLastCommit);
        if (Array.isArray(object?.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports$1.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxTxBytes !== void 0 && (obj.maxTxBytes = (message.maxTxBytes || BigInt(0)).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.localLastCommit !== void 0 && (obj.localLastCommit = message.localLastCommit ? exports$1.ExtendedCommitInfo.toJSON(message.localLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports$1.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestPrepareProposal2();
        if (object.maxTxBytes !== void 0 && object.maxTxBytes !== null) {
          message.maxTxBytes = BigInt(object.maxTxBytes.toString());
        }
        message.txs = object.txs?.map((e) => e) || [];
        if (object.localLastCommit !== void 0 && object.localLastCommit !== null) {
          message.localLastCommit = exports$1.ExtendedCommitInfo.fromPartial(object.localLastCommit);
        }
        message.misbehavior = object.misbehavior?.map((e) => exports$1.Misbehavior.fromPartial(e)) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestProcessProposal2() {
      return {
        txs: [],
        proposedLastCommit: exports$1.CommitInfo.fromPartial({}),
        misbehavior: [],
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports$1.RequestProcessProposal = {
      typeUrl: "/tendermint.abci.RequestProcessProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        if (message.proposedLastCommit !== void 0) {
          exports$1.CommitInfo.encode(message.proposedLastCommit, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports$1.Misbehavior.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestProcessProposal2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            case 2:
              message.proposedLastCommit = exports$1.CommitInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.misbehavior.push(exports$1.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestProcessProposal2();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.proposedLastCommit))
          obj.proposedLastCommit = exports$1.CommitInfo.fromJSON(object.proposedLastCommit);
        if (Array.isArray(object?.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports$1.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.proposedLastCommit !== void 0 && (obj.proposedLastCommit = message.proposedLastCommit ? exports$1.CommitInfo.toJSON(message.proposedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports$1.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestProcessProposal2();
        message.txs = object.txs?.map((e) => e) || [];
        if (object.proposedLastCommit !== void 0 && object.proposedLastCommit !== null) {
          message.proposedLastCommit = exports$1.CommitInfo.fromPartial(object.proposedLastCommit);
        }
        message.misbehavior = object.misbehavior?.map((e) => exports$1.Misbehavior.fromPartial(e)) || [];
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestExtendVote2() {
      return {
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        txs: [],
        proposedLastCommit: exports$1.CommitInfo.fromPartial({}),
        misbehavior: [],
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports$1.RequestExtendVote = {
      typeUrl: "/tendermint.abci.RequestExtendVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.txs) {
          writer.uint32(34).bytes(v);
        }
        if (message.proposedLastCommit !== void 0) {
          exports$1.CommitInfo.encode(message.proposedLastCommit, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports$1.Misbehavior.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestExtendVote2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.txs.push(reader.bytes());
              break;
            case 5:
              message.proposedLastCommit = exports$1.CommitInfo.decode(reader, reader.uint32());
              break;
            case 6:
              message.misbehavior.push(exports$1.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestExtendVote2();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.proposedLastCommit))
          obj.proposedLastCommit = exports$1.CommitInfo.fromJSON(object.proposedLastCommit);
        if (Array.isArray(object?.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports$1.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.proposedLastCommit !== void 0 && (obj.proposedLastCommit = message.proposedLastCommit ? exports$1.CommitInfo.toJSON(message.proposedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports$1.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestExtendVote2();
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.txs = object.txs?.map((e) => e) || [];
        if (object.proposedLastCommit !== void 0 && object.proposedLastCommit !== null) {
          message.proposedLastCommit = exports$1.CommitInfo.fromPartial(object.proposedLastCommit);
        }
        message.misbehavior = object.misbehavior?.map((e) => exports$1.Misbehavior.fromPartial(e)) || [];
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestVerifyVoteExtension2() {
      return {
        hash: new Uint8Array(),
        validatorAddress: new Uint8Array(),
        height: BigInt(0),
        voteExtension: new Uint8Array()
      };
    }
    exports$1.RequestVerifyVoteExtension = {
      typeUrl: "/tendermint.abci.RequestVerifyVoteExtension",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.voteExtension.length !== 0) {
          writer.uint32(34).bytes(message.voteExtension);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestVerifyVoteExtension2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.voteExtension = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestVerifyVoteExtension2();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestVerifyVoteExtension2();
        message.hash = object.hash ?? new Uint8Array();
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestFinalizeBlock2() {
      return {
        txs: [],
        decidedLastCommit: exports$1.CommitInfo.fromPartial({}),
        misbehavior: [],
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports$1.RequestFinalizeBlock = {
      typeUrl: "/tendermint.abci.RequestFinalizeBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        if (message.decidedLastCommit !== void 0) {
          exports$1.CommitInfo.encode(message.decidedLastCommit, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports$1.Misbehavior.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestFinalizeBlock2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            case 2:
              message.decidedLastCommit = exports$1.CommitInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.misbehavior.push(exports$1.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestFinalizeBlock2();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.decidedLastCommit))
          obj.decidedLastCommit = exports$1.CommitInfo.fromJSON(object.decidedLastCommit);
        if (Array.isArray(object?.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports$1.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.decidedLastCommit !== void 0 && (obj.decidedLastCommit = message.decidedLastCommit ? exports$1.CommitInfo.toJSON(message.decidedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports$1.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestFinalizeBlock2();
        message.txs = object.txs?.map((e) => e) || [];
        if (object.decidedLastCommit !== void 0 && object.decidedLastCommit !== null) {
          message.decidedLastCommit = exports$1.CommitInfo.fromPartial(object.decidedLastCommit);
        }
        message.misbehavior = object.misbehavior?.map((e) => exports$1.Misbehavior.fromPartial(e)) || [];
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponse() {
      return {
        exception: void 0,
        echo: void 0,
        flush: void 0,
        info: void 0,
        initChain: void 0,
        query: void 0,
        checkTx: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0,
        prepareProposal: void 0,
        processProposal: void 0,
        extendVote: void 0,
        verifyVoteExtension: void 0,
        finalizeBlock: void 0
      };
    }
    exports$1.Response = {
      typeUrl: "/tendermint.abci.Response",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exception !== void 0) {
          exports$1.ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();
        }
        if (message.echo !== void 0) {
          exports$1.ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports$1.ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports$1.ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports$1.ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports$1.ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports$1.ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports$1.ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports$1.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports$1.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports$1.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports$1.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();
        }
        if (message.prepareProposal !== void 0) {
          exports$1.ResponsePrepareProposal.encode(message.prepareProposal, writer.uint32(138).fork()).ldelim();
        }
        if (message.processProposal !== void 0) {
          exports$1.ResponseProcessProposal.encode(message.processProposal, writer.uint32(146).fork()).ldelim();
        }
        if (message.extendVote !== void 0) {
          exports$1.ResponseExtendVote.encode(message.extendVote, writer.uint32(154).fork()).ldelim();
        }
        if (message.verifyVoteExtension !== void 0) {
          exports$1.ResponseVerifyVoteExtension.encode(message.verifyVoteExtension, writer.uint32(162).fork()).ldelim();
        }
        if (message.finalizeBlock !== void 0) {
          exports$1.ResponseFinalizeBlock.encode(message.finalizeBlock, writer.uint32(170).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exception = exports$1.ResponseException.decode(reader, reader.uint32());
              break;
            case 2:
              message.echo = exports$1.ResponseEcho.decode(reader, reader.uint32());
              break;
            case 3:
              message.flush = exports$1.ResponseFlush.decode(reader, reader.uint32());
              break;
            case 4:
              message.info = exports$1.ResponseInfo.decode(reader, reader.uint32());
              break;
            case 6:
              message.initChain = exports$1.ResponseInitChain.decode(reader, reader.uint32());
              break;
            case 7:
              message.query = exports$1.ResponseQuery.decode(reader, reader.uint32());
              break;
            case 9:
              message.checkTx = exports$1.ResponseCheckTx.decode(reader, reader.uint32());
              break;
            case 12:
              message.commit = exports$1.ResponseCommit.decode(reader, reader.uint32());
              break;
            case 13:
              message.listSnapshots = exports$1.ResponseListSnapshots.decode(reader, reader.uint32());
              break;
            case 14:
              message.offerSnapshot = exports$1.ResponseOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 15:
              message.loadSnapshotChunk = exports$1.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.applySnapshotChunk = exports$1.ResponseApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            case 17:
              message.prepareProposal = exports$1.ResponsePrepareProposal.decode(reader, reader.uint32());
              break;
            case 18:
              message.processProposal = exports$1.ResponseProcessProposal.decode(reader, reader.uint32());
              break;
            case 19:
              message.extendVote = exports$1.ResponseExtendVote.decode(reader, reader.uint32());
              break;
            case 20:
              message.verifyVoteExtension = exports$1.ResponseVerifyVoteExtension.decode(reader, reader.uint32());
              break;
            case 21:
              message.finalizeBlock = exports$1.ResponseFinalizeBlock.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponse();
        if ((0, helpers_1.isSet)(object.exception))
          obj.exception = exports$1.ResponseException.fromJSON(object.exception);
        if ((0, helpers_1.isSet)(object.echo))
          obj.echo = exports$1.ResponseEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush))
          obj.flush = exports$1.ResponseFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = exports$1.ResponseInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain))
          obj.initChain = exports$1.ResponseInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query))
          obj.query = exports$1.ResponseQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.checkTx))
          obj.checkTx = exports$1.ResponseCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports$1.ResponseCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots))
          obj.listSnapshots = exports$1.ResponseListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot))
          obj.offerSnapshot = exports$1.ResponseOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk))
          obj.loadSnapshotChunk = exports$1.ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk))
          obj.applySnapshotChunk = exports$1.ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal))
          obj.prepareProposal = exports$1.ResponsePrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal))
          obj.processProposal = exports$1.ResponseProcessProposal.fromJSON(object.processProposal);
        if ((0, helpers_1.isSet)(object.extendVote))
          obj.extendVote = exports$1.ResponseExtendVote.fromJSON(object.extendVote);
        if ((0, helpers_1.isSet)(object.verifyVoteExtension))
          obj.verifyVoteExtension = exports$1.ResponseVerifyVoteExtension.fromJSON(object.verifyVoteExtension);
        if ((0, helpers_1.isSet)(object.finalizeBlock))
          obj.finalizeBlock = exports$1.ResponseFinalizeBlock.fromJSON(object.finalizeBlock);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exception !== void 0 && (obj.exception = message.exception ? exports$1.ResponseException.toJSON(message.exception) : void 0);
        message.echo !== void 0 && (obj.echo = message.echo ? exports$1.ResponseEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports$1.ResponseFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports$1.ResponseInfo.toJSON(message.info) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports$1.ResponseInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports$1.ResponseQuery.toJSON(message.query) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports$1.ResponseCheckTx.toJSON(message.checkTx) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports$1.ResponseCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports$1.ResponseListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports$1.ResponseOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports$1.ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports$1.ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        message.prepareProposal !== void 0 && (obj.prepareProposal = message.prepareProposal ? exports$1.ResponsePrepareProposal.toJSON(message.prepareProposal) : void 0);
        message.processProposal !== void 0 && (obj.processProposal = message.processProposal ? exports$1.ResponseProcessProposal.toJSON(message.processProposal) : void 0);
        message.extendVote !== void 0 && (obj.extendVote = message.extendVote ? exports$1.ResponseExtendVote.toJSON(message.extendVote) : void 0);
        message.verifyVoteExtension !== void 0 && (obj.verifyVoteExtension = message.verifyVoteExtension ? exports$1.ResponseVerifyVoteExtension.toJSON(message.verifyVoteExtension) : void 0);
        message.finalizeBlock !== void 0 && (obj.finalizeBlock = message.finalizeBlock ? exports$1.ResponseFinalizeBlock.toJSON(message.finalizeBlock) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponse();
        if (object.exception !== void 0 && object.exception !== null) {
          message.exception = exports$1.ResponseException.fromPartial(object.exception);
        }
        if (object.echo !== void 0 && object.echo !== null) {
          message.echo = exports$1.ResponseEcho.fromPartial(object.echo);
        }
        if (object.flush !== void 0 && object.flush !== null) {
          message.flush = exports$1.ResponseFlush.fromPartial(object.flush);
        }
        if (object.info !== void 0 && object.info !== null) {
          message.info = exports$1.ResponseInfo.fromPartial(object.info);
        }
        if (object.initChain !== void 0 && object.initChain !== null) {
          message.initChain = exports$1.ResponseInitChain.fromPartial(object.initChain);
        }
        if (object.query !== void 0 && object.query !== null) {
          message.query = exports$1.ResponseQuery.fromPartial(object.query);
        }
        if (object.checkTx !== void 0 && object.checkTx !== null) {
          message.checkTx = exports$1.ResponseCheckTx.fromPartial(object.checkTx);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports$1.ResponseCommit.fromPartial(object.commit);
        }
        if (object.listSnapshots !== void 0 && object.listSnapshots !== null) {
          message.listSnapshots = exports$1.ResponseListSnapshots.fromPartial(object.listSnapshots);
        }
        if (object.offerSnapshot !== void 0 && object.offerSnapshot !== null) {
          message.offerSnapshot = exports$1.ResponseOfferSnapshot.fromPartial(object.offerSnapshot);
        }
        if (object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null) {
          message.loadSnapshotChunk = exports$1.ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        }
        if (object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null) {
          message.applySnapshotChunk = exports$1.ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        }
        if (object.prepareProposal !== void 0 && object.prepareProposal !== null) {
          message.prepareProposal = exports$1.ResponsePrepareProposal.fromPartial(object.prepareProposal);
        }
        if (object.processProposal !== void 0 && object.processProposal !== null) {
          message.processProposal = exports$1.ResponseProcessProposal.fromPartial(object.processProposal);
        }
        if (object.extendVote !== void 0 && object.extendVote !== null) {
          message.extendVote = exports$1.ResponseExtendVote.fromPartial(object.extendVote);
        }
        if (object.verifyVoteExtension !== void 0 && object.verifyVoteExtension !== null) {
          message.verifyVoteExtension = exports$1.ResponseVerifyVoteExtension.fromPartial(object.verifyVoteExtension);
        }
        if (object.finalizeBlock !== void 0 && object.finalizeBlock !== null) {
          message.finalizeBlock = exports$1.ResponseFinalizeBlock.fromPartial(object.finalizeBlock);
        }
        return message;
      }
    };
    function createBaseResponseException() {
      return {
        error: ""
      };
    }
    exports$1.ResponseException = {
      typeUrl: "/tendermint.abci.ResponseException",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.error !== "") {
          writer.uint32(10).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseException();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseException();
        if ((0, helpers_1.isSet)(object.error))
          obj.error = String(object.error);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseException();
        message.error = object.error ?? "";
        return message;
      }
    };
    function createBaseResponseEcho2() {
      return {
        message: ""
      };
    }
    exports$1.ResponseEcho = {
      typeUrl: "/tendermint.abci.ResponseEcho",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseEcho2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseEcho2();
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseEcho2();
        message.message = object.message ?? "";
        return message;
      }
    };
    function createBaseResponseFlush2() {
      return {};
    }
    exports$1.ResponseFlush = {
      typeUrl: "/tendermint.abci.ResponseFlush",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseFlush2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseResponseFlush2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseResponseFlush2();
        return message;
      }
    };
    function createBaseResponseInfo2() {
      return {
        data: "",
        version: "",
        appVersion: BigInt(0),
        lastBlockHeight: BigInt(0),
        lastBlockAppHash: new Uint8Array()
      };
    }
    exports$1.ResponseInfo = {
      typeUrl: "/tendermint.abci.ResponseInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data !== "") {
          writer.uint32(10).string(message.data);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        if (message.appVersion !== BigInt(0)) {
          writer.uint32(24).uint64(message.appVersion);
        }
        if (message.lastBlockHeight !== BigInt(0)) {
          writer.uint32(32).int64(message.lastBlockHeight);
        }
        if (message.lastBlockAppHash.length !== 0) {
          writer.uint32(42).bytes(message.lastBlockAppHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            case 3:
              message.appVersion = reader.uint64();
              break;
            case 4:
              message.lastBlockHeight = reader.int64();
              break;
            case 5:
              message.lastBlockAppHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseInfo2();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.appVersion))
          obj.appVersion = BigInt(object.appVersion.toString());
        if ((0, helpers_1.isSet)(object.lastBlockHeight))
          obj.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        if ((0, helpers_1.isSet)(object.lastBlockAppHash))
          obj.lastBlockAppHash = (0, helpers_1.bytesFromBase64)(object.lastBlockAppHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = message.data);
        message.version !== void 0 && (obj.version = message.version);
        message.appVersion !== void 0 && (obj.appVersion = (message.appVersion || BigInt(0)).toString());
        message.lastBlockHeight !== void 0 && (obj.lastBlockHeight = (message.lastBlockHeight || BigInt(0)).toString());
        message.lastBlockAppHash !== void 0 && (obj.lastBlockAppHash = (0, helpers_1.base64FromBytes)(message.lastBlockAppHash !== void 0 ? message.lastBlockAppHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseInfo2();
        message.data = object.data ?? "";
        message.version = object.version ?? "";
        if (object.appVersion !== void 0 && object.appVersion !== null) {
          message.appVersion = BigInt(object.appVersion.toString());
        }
        if (object.lastBlockHeight !== void 0 && object.lastBlockHeight !== null) {
          message.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        }
        message.lastBlockAppHash = object.lastBlockAppHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseInitChain2() {
      return {
        consensusParams: void 0,
        validators: [],
        appHash: new Uint8Array()
      };
    }
    exports$1.ResponseInitChain = {
      typeUrl: "/tendermint.abci.ResponseInitChain",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusParams !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports$1.ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(26).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInitChain2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.validators.push(exports$1.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 3:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseInitChain2();
        if ((0, helpers_1.isSet)(object.consensusParams))
          obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => exports$1.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports$1.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseInitChain2();
        if (object.consensusParams !== void 0 && object.consensusParams !== null) {
          message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        }
        message.validators = object.validators?.map((e) => exports$1.ValidatorUpdate.fromPartial(e)) || [];
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseQuery2() {
      return {
        code: 0,
        log: "",
        info: "",
        index: BigInt(0),
        key: new Uint8Array(),
        value: new Uint8Array(),
        proofOps: void 0,
        height: BigInt(0),
        codespace: ""
      };
    }
    exports$1.ResponseQuery = {
      typeUrl: "/tendermint.abci.ResponseQuery",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.index !== BigInt(0)) {
          writer.uint32(40).int64(message.index);
        }
        if (message.key.length !== 0) {
          writer.uint32(50).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(58).bytes(message.value);
        }
        if (message.proofOps !== void 0) {
          proof_1.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(72).int64(message.height);
        }
        if (message.codespace !== "") {
          writer.uint32(82).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseQuery2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.index = reader.int64();
              break;
            case 6:
              message.key = reader.bytes();
              break;
            case 7:
              message.value = reader.bytes();
              break;
            case 8:
              message.proofOps = proof_1.ProofOps.decode(reader, reader.uint32());
              break;
            case 9:
              message.height = reader.int64();
              break;
            case 10:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseQuery2();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.index))
          obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.proofOps))
          obj.proofOps = proof_1.ProofOps.fromJSON(object.proofOps);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.index !== void 0 && (obj.index = (message.index || BigInt(0)).toString());
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.proofOps !== void 0 && (obj.proofOps = message.proofOps ? proof_1.ProofOps.toJSON(message.proofOps) : void 0);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseQuery2();
        message.code = object.code ?? 0;
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.index !== void 0 && object.index !== null) {
          message.index = BigInt(object.index.toString());
        }
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.proofOps !== void 0 && object.proofOps !== null) {
          message.proofOps = proof_1.ProofOps.fromPartial(object.proofOps);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseResponseCheckTx2() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: ""
      };
    }
    exports$1.ResponseCheckTx = {
      typeUrl: "/tendermint.abci.ResponseCheckTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports$1.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCheckTx2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports$1.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseCheckTx2();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted))
          obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used))
          obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => exports$1.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports$1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseCheckTx2();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        message.events = object.events?.map((e) => exports$1.Event.fromPartial(e)) || [];
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseResponseCommit2() {
      return {
        retainHeight: BigInt(0)
      };
    }
    exports$1.ResponseCommit = {
      typeUrl: "/tendermint.abci.ResponseCommit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.retainHeight !== BigInt(0)) {
          writer.uint32(24).int64(message.retainHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCommit2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.retainHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseCommit2();
        if ((0, helpers_1.isSet)(object.retainHeight))
          obj.retainHeight = BigInt(object.retainHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.retainHeight !== void 0 && (obj.retainHeight = (message.retainHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseCommit2();
        if (object.retainHeight !== void 0 && object.retainHeight !== null) {
          message.retainHeight = BigInt(object.retainHeight.toString());
        }
        return message;
      }
    };
    function createBaseResponseListSnapshots2() {
      return {
        snapshots: []
      };
    }
    exports$1.ResponseListSnapshots = {
      typeUrl: "/tendermint.abci.ResponseListSnapshots",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.snapshots) {
          exports$1.Snapshot.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseListSnapshots2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshots.push(exports$1.Snapshot.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseListSnapshots2();
        if (Array.isArray(object?.snapshots))
          obj.snapshots = object.snapshots.map((e) => exports$1.Snapshot.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.snapshots) {
          obj.snapshots = message.snapshots.map((e) => e ? exports$1.Snapshot.toJSON(e) : void 0);
        } else {
          obj.snapshots = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseListSnapshots2();
        message.snapshots = object.snapshots?.map((e) => exports$1.Snapshot.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseResponseOfferSnapshot2() {
      return {
        result: 0
      };
    }
    exports$1.ResponseOfferSnapshot = {
      typeUrl: "/tendermint.abci.ResponseOfferSnapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseOfferSnapshot2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseOfferSnapshot2();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseOfferSnapshot_ResultFromJSON2(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseOfferSnapshot_ResultToJSON2(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseOfferSnapshot2();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseResponseLoadSnapshotChunk2() {
      return {
        chunk: new Uint8Array()
      };
    }
    exports$1.ResponseLoadSnapshotChunk = {
      typeUrl: "/tendermint.abci.ResponseLoadSnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.chunk.length !== 0) {
          writer.uint32(10).bytes(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseLoadSnapshotChunk2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chunk = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseLoadSnapshotChunk2();
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.chunk !== void 0 && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseLoadSnapshotChunk2();
        message.chunk = object.chunk ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseApplySnapshotChunk2() {
      return {
        result: 0,
        refetchChunks: [],
        rejectSenders: []
      };
    }
    exports$1.ResponseApplySnapshotChunk = {
      typeUrl: "/tendermint.abci.ResponseApplySnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        writer.uint32(18).fork();
        for (const v of message.refetchChunks) {
          writer.uint32(v);
        }
        writer.ldelim();
        for (const v of message.rejectSenders) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseApplySnapshotChunk2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.refetchChunks.push(reader.uint32());
                }
              } else {
                message.refetchChunks.push(reader.uint32());
              }
              break;
            case 3:
              message.rejectSenders.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseApplySnapshotChunk2();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseApplySnapshotChunk_ResultFromJSON2(object.result);
        if (Array.isArray(object?.refetchChunks))
          obj.refetchChunks = object.refetchChunks.map((e) => Number(e));
        if (Array.isArray(object?.rejectSenders))
          obj.rejectSenders = object.rejectSenders.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseApplySnapshotChunk_ResultToJSON2(message.result));
        if (message.refetchChunks) {
          obj.refetchChunks = message.refetchChunks.map((e) => Math.round(e));
        } else {
          obj.refetchChunks = [];
        }
        if (message.rejectSenders) {
          obj.rejectSenders = message.rejectSenders.map((e) => e);
        } else {
          obj.rejectSenders = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseApplySnapshotChunk2();
        message.result = object.result ?? 0;
        message.refetchChunks = object.refetchChunks?.map((e) => e) || [];
        message.rejectSenders = object.rejectSenders?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseResponsePrepareProposal2() {
      return {
        txs: []
      };
    }
    exports$1.ResponsePrepareProposal = {
      typeUrl: "/tendermint.abci.ResponsePrepareProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponsePrepareProposal2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponsePrepareProposal2();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponsePrepareProposal2();
        message.txs = object.txs?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseResponseProcessProposal2() {
      return {
        status: 0
      };
    }
    exports$1.ResponseProcessProposal = {
      typeUrl: "/tendermint.abci.ResponseProcessProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== 0) {
          writer.uint32(8).int32(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseProcessProposal2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseProcessProposal2();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = responseProcessProposal_ProposalStatusFromJSON2(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = responseProcessProposal_ProposalStatusToJSON2(message.status));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseProcessProposal2();
        message.status = object.status ?? 0;
        return message;
      }
    };
    function createBaseResponseExtendVote2() {
      return {
        voteExtension: new Uint8Array()
      };
    }
    exports$1.ResponseExtendVote = {
      typeUrl: "/tendermint.abci.ResponseExtendVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteExtension.length !== 0) {
          writer.uint32(10).bytes(message.voteExtension);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseExtendVote2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteExtension = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseExtendVote2();
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseExtendVote2();
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseVerifyVoteExtension2() {
      return {
        status: 0
      };
    }
    exports$1.ResponseVerifyVoteExtension = {
      typeUrl: "/tendermint.abci.ResponseVerifyVoteExtension",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== 0) {
          writer.uint32(8).int32(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseVerifyVoteExtension2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseVerifyVoteExtension2();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = responseVerifyVoteExtension_VerifyStatusFromJSON2(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = responseVerifyVoteExtension_VerifyStatusToJSON2(message.status));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseVerifyVoteExtension2();
        message.status = object.status ?? 0;
        return message;
      }
    };
    function createBaseResponseFinalizeBlock2() {
      return {
        events: [],
        txResults: [],
        validatorUpdates: [],
        consensusParamUpdates: void 0,
        appHash: new Uint8Array()
      };
    }
    exports$1.ResponseFinalizeBlock = {
      typeUrl: "/tendermint.abci.ResponseFinalizeBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.events) {
          exports$1.Event.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.txResults) {
          exports$1.ExecTxResult.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.validatorUpdates) {
          exports$1.ValidatorUpdate.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.consensusParamUpdates !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(34).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(42).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseFinalizeBlock2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(exports$1.Event.decode(reader, reader.uint32()));
              break;
            case 2:
              message.txResults.push(exports$1.ExecTxResult.decode(reader, reader.uint32()));
              break;
            case 3:
              message.validatorUpdates.push(exports$1.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 4:
              message.consensusParamUpdates = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 5:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseFinalizeBlock2();
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => exports$1.Event.fromJSON(e));
        if (Array.isArray(object?.txResults))
          obj.txResults = object.txResults.map((e) => exports$1.ExecTxResult.fromJSON(e));
        if (Array.isArray(object?.validatorUpdates))
          obj.validatorUpdates = object.validatorUpdates.map((e) => exports$1.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.consensusParamUpdates))
          obj.consensusParamUpdates = params_1.ConsensusParams.fromJSON(object.consensusParamUpdates);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports$1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        if (message.txResults) {
          obj.txResults = message.txResults.map((e) => e ? exports$1.ExecTxResult.toJSON(e) : void 0);
        } else {
          obj.txResults = [];
        }
        if (message.validatorUpdates) {
          obj.validatorUpdates = message.validatorUpdates.map((e) => e ? exports$1.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validatorUpdates = [];
        }
        message.consensusParamUpdates !== void 0 && (obj.consensusParamUpdates = message.consensusParamUpdates ? params_1.ConsensusParams.toJSON(message.consensusParamUpdates) : void 0);
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseFinalizeBlock2();
        message.events = object.events?.map((e) => exports$1.Event.fromPartial(e)) || [];
        message.txResults = object.txResults?.map((e) => exports$1.ExecTxResult.fromPartial(e)) || [];
        message.validatorUpdates = object.validatorUpdates?.map((e) => exports$1.ValidatorUpdate.fromPartial(e)) || [];
        if (object.consensusParamUpdates !== void 0 && object.consensusParamUpdates !== null) {
          message.consensusParamUpdates = params_1.ConsensusParams.fromPartial(object.consensusParamUpdates);
        }
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseCommitInfo2() {
      return {
        round: 0,
        votes: []
      };
    }
    exports$1.CommitInfo = {
      typeUrl: "/tendermint.abci.CommitInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v of message.votes) {
          exports$1.VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports$1.VoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitInfo2();
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if (Array.isArray(object?.votes))
          obj.votes = object.votes.map((e) => exports$1.VoteInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = Math.round(message.round));
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports$1.VoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitInfo2();
        message.round = object.round ?? 0;
        message.votes = object.votes?.map((e) => exports$1.VoteInfo.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseExtendedCommitInfo2() {
      return {
        round: 0,
        votes: []
      };
    }
    exports$1.ExtendedCommitInfo = {
      typeUrl: "/tendermint.abci.ExtendedCommitInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v of message.votes) {
          exports$1.ExtendedVoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommitInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports$1.ExtendedVoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommitInfo2();
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if (Array.isArray(object?.votes))
          obj.votes = object.votes.map((e) => exports$1.ExtendedVoteInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = Math.round(message.round));
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports$1.ExtendedVoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedCommitInfo2();
        message.round = object.round ?? 0;
        message.votes = object.votes?.map((e) => exports$1.ExtendedVoteInfo.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseEvent2() {
      return {
        type: "",
        attributes: []
      };
    }
    exports$1.Event = {
      typeUrl: "/tendermint.abci.Event",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports$1.EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvent2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports$1.EventAttribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvent2();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if (Array.isArray(object?.attributes))
          obj.attributes = object.attributes.map((e) => exports$1.EventAttribute.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports$1.EventAttribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvent2();
        message.type = object.type ?? "";
        message.attributes = object.attributes?.map((e) => exports$1.EventAttribute.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseEventAttribute2() {
      return {
        key: "",
        value: "",
        index: false
      };
    }
    exports$1.EventAttribute = {
      typeUrl: "/tendermint.abci.EventAttribute",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        if (message.index === true) {
          writer.uint32(24).bool(message.index);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEventAttribute2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            case 3:
              message.index = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEventAttribute2();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = String(object.value);
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Boolean(object.index);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        message.index !== void 0 && (obj.index = message.index);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEventAttribute2();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        message.index = object.index ?? false;
        return message;
      }
    };
    function createBaseExecTxResult2() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: ""
      };
    }
    exports$1.ExecTxResult = {
      typeUrl: "/tendermint.abci.ExecTxResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports$1.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExecTxResult2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports$1.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExecTxResult2();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted))
          obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used))
          obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => exports$1.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports$1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExecTxResult2();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        message.events = object.events?.map((e) => exports$1.Event.fromPartial(e)) || [];
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseTxResult() {
      return {
        height: BigInt(0),
        index: 0,
        tx: new Uint8Array(),
        result: exports$1.ExecTxResult.fromPartial({})
      };
    }
    exports$1.TxResult = {
      typeUrl: "/tendermint.abci.TxResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.index !== 0) {
          writer.uint32(16).uint32(message.index);
        }
        if (message.tx.length !== 0) {
          writer.uint32(26).bytes(message.tx);
        }
        if (message.result !== void 0) {
          exports$1.ExecTxResult.encode(message.result, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.index = reader.uint32();
              break;
            case 3:
              message.tx = reader.bytes();
              break;
            case 4:
              message.result = exports$1.ExecTxResult.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxResult();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = exports$1.ExecTxResult.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.tx !== void 0 && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.result !== void 0 && (obj.result = message.result ? exports$1.ExecTxResult.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxResult();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.index = object.index ?? 0;
        message.tx = object.tx ?? new Uint8Array();
        if (object.result !== void 0 && object.result !== null) {
          message.result = exports$1.ExecTxResult.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseValidator5() {
      return {
        address: new Uint8Array(),
        power: BigInt(0)
      };
    }
    exports$1.Validator = {
      typeUrl: "/tendermint.abci.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.power !== BigInt(0)) {
          writer.uint32(24).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator5();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 3:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator5();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.power))
          obj.power = BigInt(object.power.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== void 0 ? message.address : new Uint8Array()));
        message.power !== void 0 && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator5();
        message.address = object.address ?? new Uint8Array();
        if (object.power !== void 0 && object.power !== null) {
          message.power = BigInt(object.power.toString());
        }
        return message;
      }
    };
    function createBaseValidatorUpdate2() {
      return {
        pubKey: keys_1.PublicKey.fromPartial({}),
        power: BigInt(0)
      };
    }
    exports$1.ValidatorUpdate = {
      typeUrl: "/tendermint.abci.ValidatorUpdate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.power !== BigInt(0)) {
          writer.uint32(16).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdate2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorUpdate2();
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.power))
          obj.power = BigInt(object.power.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.power !== void 0 && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorUpdate2();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.power !== void 0 && object.power !== null) {
          message.power = BigInt(object.power.toString());
        }
        return message;
      }
    };
    function createBaseVoteInfo2() {
      return {
        validator: exports$1.Validator.fromPartial({}),
        blockIdFlag: 0
      };
    }
    exports$1.VoteInfo = {
      typeUrl: "/tendermint.abci.VoteInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          exports$1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockIdFlag !== 0) {
          writer.uint32(24).int32(message.blockIdFlag);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVoteInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports$1.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.blockIdFlag = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVoteInfo2();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports$1.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports$1.Validator.toJSON(message.validator) : void 0);
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVoteInfo2();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports$1.Validator.fromPartial(object.validator);
        }
        message.blockIdFlag = object.blockIdFlag ?? 0;
        return message;
      }
    };
    function createBaseExtendedVoteInfo2() {
      return {
        validator: exports$1.Validator.fromPartial({}),
        voteExtension: new Uint8Array(),
        extensionSignature: new Uint8Array(),
        blockIdFlag: 0
      };
    }
    exports$1.ExtendedVoteInfo = {
      typeUrl: "/tendermint.abci.ExtendedVoteInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          exports$1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.voteExtension.length !== 0) {
          writer.uint32(26).bytes(message.voteExtension);
        }
        if (message.extensionSignature.length !== 0) {
          writer.uint32(34).bytes(message.extensionSignature);
        }
        if (message.blockIdFlag !== 0) {
          writer.uint32(40).int32(message.blockIdFlag);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedVoteInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports$1.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.voteExtension = reader.bytes();
              break;
            case 4:
              message.extensionSignature = reader.bytes();
              break;
            case 5:
              message.blockIdFlag = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedVoteInfo2();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports$1.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        if ((0, helpers_1.isSet)(object.extensionSignature))
          obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports$1.Validator.toJSON(message.validator) : void 0);
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        message.extensionSignature !== void 0 && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== void 0 ? message.extensionSignature : new Uint8Array()));
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedVoteInfo2();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports$1.Validator.fromPartial(object.validator);
        }
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        return message;
      }
    };
    function createBaseMisbehavior2() {
      return {
        type: 0,
        validator: exports$1.Validator.fromPartial({}),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        totalVotingPower: BigInt(0)
      };
    }
    exports$1.Misbehavior = {
      typeUrl: "/tendermint.abci.Misbehavior",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.validator !== void 0) {
          exports$1.Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(40).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMisbehavior2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.validator = exports$1.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMisbehavior2();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = misbehaviorTypeFromJSON2(object.type);
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports$1.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = misbehaviorTypeToJSON2(message.type));
        message.validator !== void 0 && (obj.validator = message.validator ? exports$1.Validator.toJSON(message.validator) : void 0);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMisbehavior2();
        message.type = object.type ?? 0;
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports$1.Validator.fromPartial(object.validator);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        return message;
      }
    };
    function createBaseSnapshot2() {
      return {
        height: BigInt(0),
        format: 0,
        chunks: 0,
        hash: new Uint8Array(),
        metadata: new Uint8Array()
      };
    }
    exports$1.Snapshot = {
      typeUrl: "/tendermint.abci.Snapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunks !== 0) {
          writer.uint32(24).uint32(message.chunks);
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.metadata.length !== 0) {
          writer.uint32(42).bytes(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSnapshot2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunks = reader.uint32();
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.metadata = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSnapshot2();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format))
          obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunks))
          obj.chunks = Number(object.chunks);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = (0, helpers_1.bytesFromBase64)(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunks !== void 0 && (obj.chunks = Math.round(message.chunks));
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.metadata !== void 0 && (obj.metadata = (0, helpers_1.base64FromBytes)(message.metadata !== void 0 ? message.metadata : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSnapshot2();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.format = object.format ?? 0;
        message.chunks = object.chunks ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        message.metadata = object.metadata ?? new Uint8Array();
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js
var require_staking = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ValidatorUpdates = exports$1.Pool = exports$1.RedelegationResponse = exports$1.RedelegationEntryResponse = exports$1.DelegationResponse = exports$1.Params = exports$1.Redelegation = exports$1.RedelegationEntry = exports$1.UnbondingDelegationEntry = exports$1.UnbondingDelegation = exports$1.Delegation = exports$1.DVVTriplets = exports$1.DVVTriplet = exports$1.DVPairs = exports$1.DVPair = exports$1.ValAddresses = exports$1.Validator = exports$1.Description = exports$1.Commission = exports$1.CommissionRates = exports$1.HistoricalInfo = exports$1.infractionToJSON = exports$1.infractionFromJSON = exports$1.Infraction = exports$1.bondStatusToJSON = exports$1.bondStatusFromJSON = exports$1.BondStatus = exports$1.protobufPackage = void 0;
    var types_1 = require_types3();
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    var duration_1 = require_duration();
    var coin_1 = require_coin();
    var types_2 = require_types4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.staking.v1beta1";
    var BondStatus;
    (function(BondStatus2) {
      BondStatus2[BondStatus2["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
      BondStatus2[BondStatus2["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
      BondStatus2[BondStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BondStatus || (exports$1.BondStatus = BondStatus = {}));
    function bondStatusFromJSON2(object) {
      switch (object) {
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
          return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
          return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
          return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
          return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BondStatus.UNRECOGNIZED;
      }
    }
    exports$1.bondStatusFromJSON = bondStatusFromJSON2;
    function bondStatusToJSON2(object) {
      switch (object) {
        case BondStatus.BOND_STATUS_UNSPECIFIED:
          return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
          return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
          return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
          return "BOND_STATUS_BONDED";
        case BondStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.bondStatusToJSON = bondStatusToJSON2;
    var Infraction;
    (function(Infraction2) {
      Infraction2[Infraction2["INFRACTION_UNSPECIFIED"] = 0] = "INFRACTION_UNSPECIFIED";
      Infraction2[Infraction2["INFRACTION_DOUBLE_SIGN"] = 1] = "INFRACTION_DOUBLE_SIGN";
      Infraction2[Infraction2["INFRACTION_DOWNTIME"] = 2] = "INFRACTION_DOWNTIME";
      Infraction2[Infraction2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Infraction || (exports$1.Infraction = Infraction = {}));
    function infractionFromJSON(object) {
      switch (object) {
        case 0:
        case "INFRACTION_UNSPECIFIED":
          return Infraction.INFRACTION_UNSPECIFIED;
        case 1:
        case "INFRACTION_DOUBLE_SIGN":
          return Infraction.INFRACTION_DOUBLE_SIGN;
        case 2:
        case "INFRACTION_DOWNTIME":
          return Infraction.INFRACTION_DOWNTIME;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Infraction.UNRECOGNIZED;
      }
    }
    exports$1.infractionFromJSON = infractionFromJSON;
    function infractionToJSON(object) {
      switch (object) {
        case Infraction.INFRACTION_UNSPECIFIED:
          return "INFRACTION_UNSPECIFIED";
        case Infraction.INFRACTION_DOUBLE_SIGN:
          return "INFRACTION_DOUBLE_SIGN";
        case Infraction.INFRACTION_DOWNTIME:
          return "INFRACTION_DOWNTIME";
        case Infraction.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.infractionToJSON = infractionToJSON;
    function createBaseHistoricalInfo2() {
      return {
        header: types_1.Header.fromPartial({}),
        valset: []
      };
    }
    exports$1.HistoricalInfo = {
      typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.valset) {
          exports$1.Validator.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHistoricalInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.valset.push(exports$1.Validator.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHistoricalInfo2();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = types_1.Header.fromJSON(object.header);
        if (Array.isArray(object?.valset))
          obj.valset = object.valset.map((e) => exports$1.Validator.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        if (message.valset) {
          obj.valset = message.valset.map((e) => e ? exports$1.Validator.toJSON(e) : void 0);
        } else {
          obj.valset = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHistoricalInfo2();
        if (object.header !== void 0 && object.header !== null) {
          message.header = types_1.Header.fromPartial(object.header);
        }
        message.valset = object.valset?.map((e) => exports$1.Validator.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCommissionRates2() {
      return {
        rate: "",
        maxRate: "",
        maxChangeRate: ""
      };
    }
    exports$1.CommissionRates = {
      typeUrl: "/cosmos.staking.v1beta1.CommissionRates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rate !== "") {
          writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
          writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
          writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rate = reader.string();
              break;
            case 2:
              message.maxRate = reader.string();
              break;
            case 3:
              message.maxChangeRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommissionRates2();
        if ((0, helpers_1.isSet)(object.rate))
          obj.rate = String(object.rate);
        if ((0, helpers_1.isSet)(object.maxRate))
          obj.maxRate = String(object.maxRate);
        if ((0, helpers_1.isSet)(object.maxChangeRate))
          obj.maxChangeRate = String(object.maxChangeRate);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rate !== void 0 && (obj.rate = message.rate);
        message.maxRate !== void 0 && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== void 0 && (obj.maxChangeRate = message.maxChangeRate);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommissionRates2();
        message.rate = object.rate ?? "";
        message.maxRate = object.maxRate ?? "";
        message.maxChangeRate = object.maxChangeRate ?? "";
        return message;
      }
    };
    function createBaseCommission2() {
      return {
        commissionRates: exports$1.CommissionRates.fromPartial({}),
        updateTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.Commission = {
      typeUrl: "/cosmos.staking.v1beta1.Commission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commissionRates !== void 0) {
          exports$1.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        }
        if (message.updateTime !== void 0) {
          timestamp_1.Timestamp.encode(message.updateTime, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommission2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commissionRates = exports$1.CommissionRates.decode(reader, reader.uint32());
              break;
            case 2:
              message.updateTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommission2();
        if ((0, helpers_1.isSet)(object.commissionRates))
          obj.commissionRates = exports$1.CommissionRates.fromJSON(object.commissionRates);
        if ((0, helpers_1.isSet)(object.updateTime))
          obj.updateTime = (0, helpers_1.fromJsonTimestamp)(object.updateTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commissionRates !== void 0 && (obj.commissionRates = message.commissionRates ? exports$1.CommissionRates.toJSON(message.commissionRates) : void 0);
        message.updateTime !== void 0 && (obj.updateTime = (0, helpers_1.fromTimestamp)(message.updateTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommission2();
        if (object.commissionRates !== void 0 && object.commissionRates !== null) {
          message.commissionRates = exports$1.CommissionRates.fromPartial(object.commissionRates);
        }
        if (object.updateTime !== void 0 && object.updateTime !== null) {
          message.updateTime = timestamp_1.Timestamp.fromPartial(object.updateTime);
        }
        return message;
      }
    };
    function createBaseDescription2() {
      return {
        moniker: "",
        identity: "",
        website: "",
        securityContact: "",
        details: ""
      };
    }
    exports$1.Description = {
      typeUrl: "/cosmos.staking.v1beta1.Description",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.moniker !== "") {
          writer.uint32(10).string(message.moniker);
        }
        if (message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.website !== "") {
          writer.uint32(26).string(message.website);
        }
        if (message.securityContact !== "") {
          writer.uint32(34).string(message.securityContact);
        }
        if (message.details !== "") {
          writer.uint32(42).string(message.details);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDescription2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moniker = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.website = reader.string();
              break;
            case 4:
              message.securityContact = reader.string();
              break;
            case 5:
              message.details = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDescription2();
        if ((0, helpers_1.isSet)(object.moniker))
          obj.moniker = String(object.moniker);
        if ((0, helpers_1.isSet)(object.identity))
          obj.identity = String(object.identity);
        if ((0, helpers_1.isSet)(object.website))
          obj.website = String(object.website);
        if ((0, helpers_1.isSet)(object.securityContact))
          obj.securityContact = String(object.securityContact);
        if ((0, helpers_1.isSet)(object.details))
          obj.details = String(object.details);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.moniker !== void 0 && (obj.moniker = message.moniker);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.website !== void 0 && (obj.website = message.website);
        message.securityContact !== void 0 && (obj.securityContact = message.securityContact);
        message.details !== void 0 && (obj.details = message.details);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDescription2();
        message.moniker = object.moniker ?? "";
        message.identity = object.identity ?? "";
        message.website = object.website ?? "";
        message.securityContact = object.securityContact ?? "";
        message.details = object.details ?? "";
        return message;
      }
    };
    function createBaseValidator5() {
      return {
        operatorAddress: "",
        consensusPubkey: void 0,
        jailed: false,
        status: 0,
        tokens: "",
        delegatorShares: "",
        description: exports$1.Description.fromPartial({}),
        unbondingHeight: BigInt(0),
        unbondingTime: timestamp_1.Timestamp.fromPartial({}),
        commission: exports$1.Commission.fromPartial({}),
        minSelfDelegation: "",
        unbondingOnHoldRefCount: BigInt(0),
        unbondingIds: []
      };
    }
    exports$1.Validator = {
      typeUrl: "/cosmos.staking.v1beta1.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== void 0) {
          any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        }
        if (message.jailed === true) {
          writer.uint32(24).bool(message.jailed);
        }
        if (message.status !== 0) {
          writer.uint32(32).int32(message.status);
        }
        if (message.tokens !== "") {
          writer.uint32(42).string(message.tokens);
        }
        if (message.delegatorShares !== "") {
          writer.uint32(50).string(message.delegatorShares);
        }
        if (message.description !== void 0) {
          exports$1.Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        }
        if (message.unbondingHeight !== BigInt(0)) {
          writer.uint32(64).int64(message.unbondingHeight);
        }
        if (message.unbondingTime !== void 0) {
          timestamp_1.Timestamp.encode(message.unbondingTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          exports$1.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(90).string(message.minSelfDelegation);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(96).int64(message.unbondingOnHoldRefCount);
        }
        writer.uint32(106).fork();
        for (const v of message.unbondingIds) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator5();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.jailed = reader.bool();
              break;
            case 4:
              message.status = reader.int32();
              break;
            case 5:
              message.tokens = reader.string();
              break;
            case 6:
              message.delegatorShares = reader.string();
              break;
            case 7:
              message.description = exports$1.Description.decode(reader, reader.uint32());
              break;
            case 8:
              message.unbondingHeight = reader.int64();
              break;
            case 9:
              message.unbondingTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.commission = exports$1.Commission.decode(reader, reader.uint32());
              break;
            case 11:
              message.minSelfDelegation = reader.string();
              break;
            case 12:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            case 13:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.unbondingIds.push(reader.uint64());
                }
              } else {
                message.unbondingIds.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator5();
        if ((0, helpers_1.isSet)(object.operatorAddress))
          obj.operatorAddress = String(object.operatorAddress);
        if ((0, helpers_1.isSet)(object.consensusPubkey))
          obj.consensusPubkey = any_1.Any.fromJSON(object.consensusPubkey);
        if ((0, helpers_1.isSet)(object.jailed))
          obj.jailed = Boolean(object.jailed);
        if ((0, helpers_1.isSet)(object.status))
          obj.status = bondStatusFromJSON2(object.status);
        if ((0, helpers_1.isSet)(object.tokens))
          obj.tokens = String(object.tokens);
        if ((0, helpers_1.isSet)(object.delegatorShares))
          obj.delegatorShares = String(object.delegatorShares);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = exports$1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.unbondingHeight))
          obj.unbondingHeight = BigInt(object.unbondingHeight.toString());
        if ((0, helpers_1.isSet)(object.unbondingTime))
          obj.unbondingTime = (0, helpers_1.fromJsonTimestamp)(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = exports$1.Commission.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        if (Array.isArray(object?.unbondingIds))
          obj.unbondingIds = object.unbondingIds.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== void 0 && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : void 0);
        message.jailed !== void 0 && (obj.jailed = message.jailed);
        message.status !== void 0 && (obj.status = bondStatusToJSON2(message.status));
        message.tokens !== void 0 && (obj.tokens = message.tokens);
        message.delegatorShares !== void 0 && (obj.delegatorShares = message.delegatorShares);
        message.description !== void 0 && (obj.description = message.description ? exports$1.Description.toJSON(message.description) : void 0);
        message.unbondingHeight !== void 0 && (obj.unbondingHeight = (message.unbondingHeight || BigInt(0)).toString());
        message.unbondingTime !== void 0 && (obj.unbondingTime = (0, helpers_1.fromTimestamp)(message.unbondingTime).toISOString());
        message.commission !== void 0 && (obj.commission = message.commission ? exports$1.Commission.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        if (message.unbondingIds) {
          obj.unbondingIds = message.unbondingIds.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.unbondingIds = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator5();
        message.operatorAddress = object.operatorAddress ?? "";
        if (object.consensusPubkey !== void 0 && object.consensusPubkey !== null) {
          message.consensusPubkey = any_1.Any.fromPartial(object.consensusPubkey);
        }
        message.jailed = object.jailed ?? false;
        message.status = object.status ?? 0;
        message.tokens = object.tokens ?? "";
        message.delegatorShares = object.delegatorShares ?? "";
        if (object.description !== void 0 && object.description !== null) {
          message.description = exports$1.Description.fromPartial(object.description);
        }
        if (object.unbondingHeight !== void 0 && object.unbondingHeight !== null) {
          message.unbondingHeight = BigInt(object.unbondingHeight.toString());
        }
        if (object.unbondingTime !== void 0 && object.unbondingTime !== null) {
          message.unbondingTime = timestamp_1.Timestamp.fromPartial(object.unbondingTime);
        }
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = exports$1.Commission.fromPartial(object.commission);
        }
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        message.unbondingIds = object.unbondingIds?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseValAddresses() {
      return {
        addresses: []
      };
    }
    exports$1.ValAddresses = {
      typeUrl: "/cosmos.staking.v1beta1.ValAddresses",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.addresses) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValAddresses();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValAddresses();
        if (Array.isArray(object?.addresses))
          obj.addresses = object.addresses.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValAddresses();
        message.addresses = object.addresses?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseDVPair() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports$1.DVPair = {
      typeUrl: "/cosmos.staking.v1beta1.DVPair",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPair();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVPair();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVPair();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseDVPairs() {
      return {
        pairs: []
      };
    }
    exports$1.DVPairs = {
      typeUrl: "/cosmos.staking.v1beta1.DVPairs",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pairs) {
          exports$1.DVPair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPairs();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pairs.push(exports$1.DVPair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVPairs();
        if (Array.isArray(object?.pairs))
          obj.pairs = object.pairs.map((e) => exports$1.DVPair.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pairs) {
          obj.pairs = message.pairs.map((e) => e ? exports$1.DVPair.toJSON(e) : void 0);
        } else {
          obj.pairs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVPairs();
        message.pairs = object.pairs?.map((e) => exports$1.DVPair.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDVVTriplet() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: ""
      };
    }
    exports$1.DVVTriplet = {
      typeUrl: "/cosmos.staking.v1beta1.DVVTriplet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVVTriplet();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVVTriplet();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        return message;
      }
    };
    function createBaseDVVTriplets() {
      return {
        triplets: []
      };
    }
    exports$1.DVVTriplets = {
      typeUrl: "/cosmos.staking.v1beta1.DVVTriplets",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.triplets) {
          exports$1.DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplets();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.triplets.push(exports$1.DVVTriplet.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVVTriplets();
        if (Array.isArray(object?.triplets))
          obj.triplets = object.triplets.map((e) => exports$1.DVVTriplet.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.triplets) {
          obj.triplets = message.triplets.map((e) => e ? exports$1.DVVTriplet.toJSON(e) : void 0);
        } else {
          obj.triplets = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVVTriplets();
        message.triplets = object.triplets?.map((e) => exports$1.DVVTriplet.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDelegation2() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        shares: ""
      };
    }
    exports$1.Delegation = {
      typeUrl: "/cosmos.staking.v1beta1.Delegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.shares !== "") {
          writer.uint32(26).string(message.shares);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegation2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.shares = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegation2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.shares))
          obj.shares = String(object.shares);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.shares !== void 0 && (obj.shares = message.shares);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegation2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.shares = object.shares ?? "";
        return message;
      }
    };
    function createBaseUnbondingDelegation2() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        entries: []
      };
    }
    exports$1.UnbondingDelegation = {
      typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v of message.entries) {
          exports$1.UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegation2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.entries.push(exports$1.UnbondingDelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUnbondingDelegation2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports$1.UnbondingDelegationEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports$1.UnbondingDelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUnbondingDelegation2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.entries = object.entries?.map((e) => exports$1.UnbondingDelegationEntry.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseUnbondingDelegationEntry2() {
      return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        balance: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
      };
    }
    exports$1.UnbondingDelegationEntry = {
      typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        if (message.unbondingId !== BigInt(0)) {
          writer.uint32(40).uint64(message.unbondingId);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegationEntry2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.balance = reader.string();
              break;
            case 5:
              message.unbondingId = reader.uint64();
              break;
            case 6:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUnbondingDelegationEntry2();
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance))
          obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = String(object.balance);
        if ((0, helpers_1.isSet)(object.unbondingId))
          obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.balance !== void 0 && (obj.balance = message.balance);
        message.unbondingId !== void 0 && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUnbondingDelegationEntry2();
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        message.initialBalance = object.initialBalance ?? "";
        message.balance = object.balance ?? "";
        if (object.unbondingId !== void 0 && object.unbondingId !== null) {
          message.unbondingId = BigInt(object.unbondingId.toString());
        }
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        return message;
      }
    };
    function createBaseRedelegationEntry2() {
      return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        sharesDst: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
      };
    }
    exports$1.RedelegationEntry = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.sharesDst !== "") {
          writer.uint32(34).string(message.sharesDst);
        }
        if (message.unbondingId !== BigInt(0)) {
          writer.uint32(40).uint64(message.unbondingId);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntry2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.sharesDst = reader.string();
              break;
            case 5:
              message.unbondingId = reader.uint64();
              break;
            case 6:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationEntry2();
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance))
          obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.sharesDst))
          obj.sharesDst = String(object.sharesDst);
        if ((0, helpers_1.isSet)(object.unbondingId))
          obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.sharesDst !== void 0 && (obj.sharesDst = message.sharesDst);
        message.unbondingId !== void 0 && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationEntry2();
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        message.initialBalance = object.initialBalance ?? "";
        message.sharesDst = object.sharesDst ?? "";
        if (object.unbondingId !== void 0 && object.unbondingId !== null) {
          message.unbondingId = BigInt(object.unbondingId.toString());
        }
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        return message;
      }
    };
    function createBaseRedelegation2() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        entries: []
      };
    }
    exports$1.Redelegation = {
      typeUrl: "/cosmos.staking.v1beta1.Redelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        for (const v of message.entries) {
          exports$1.RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegation2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.entries.push(exports$1.RedelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegation2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports$1.RedelegationEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports$1.RedelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegation2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        message.entries = object.entries?.map((e) => exports$1.RedelegationEntry.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseParams15() {
      return {
        unbondingTime: duration_1.Duration.fromPartial({}),
        maxValidators: 0,
        maxEntries: 0,
        historicalEntries: 0,
        bondDenom: "",
        minCommissionRate: ""
      };
    }
    exports$1.Params = {
      typeUrl: "/cosmos.staking.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbondingTime !== void 0) {
          duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxValidators !== 0) {
          writer.uint32(16).uint32(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
          writer.uint32(24).uint32(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
          writer.uint32(32).uint32(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
          writer.uint32(42).string(message.bondDenom);
        }
        if (message.minCommissionRate !== "") {
          writer.uint32(50).string(message.minCommissionRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams15();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.maxValidators = reader.uint32();
              break;
            case 3:
              message.maxEntries = reader.uint32();
              break;
            case 4:
              message.historicalEntries = reader.uint32();
              break;
            case 5:
              message.bondDenom = reader.string();
              break;
            case 6:
              message.minCommissionRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams15();
        if ((0, helpers_1.isSet)(object.unbondingTime))
          obj.unbondingTime = duration_1.Duration.fromJSON(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.maxValidators))
          obj.maxValidators = Number(object.maxValidators);
        if ((0, helpers_1.isSet)(object.maxEntries))
          obj.maxEntries = Number(object.maxEntries);
        if ((0, helpers_1.isSet)(object.historicalEntries))
          obj.historicalEntries = Number(object.historicalEntries);
        if ((0, helpers_1.isSet)(object.bondDenom))
          obj.bondDenom = String(object.bondDenom);
        if ((0, helpers_1.isSet)(object.minCommissionRate))
          obj.minCommissionRate = String(object.minCommissionRate);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : void 0);
        message.maxValidators !== void 0 && (obj.maxValidators = Math.round(message.maxValidators));
        message.maxEntries !== void 0 && (obj.maxEntries = Math.round(message.maxEntries));
        message.historicalEntries !== void 0 && (obj.historicalEntries = Math.round(message.historicalEntries));
        message.bondDenom !== void 0 && (obj.bondDenom = message.bondDenom);
        message.minCommissionRate !== void 0 && (obj.minCommissionRate = message.minCommissionRate);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams15();
        if (object.unbondingTime !== void 0 && object.unbondingTime !== null) {
          message.unbondingTime = duration_1.Duration.fromPartial(object.unbondingTime);
        }
        message.maxValidators = object.maxValidators ?? 0;
        message.maxEntries = object.maxEntries ?? 0;
        message.historicalEntries = object.historicalEntries ?? 0;
        message.bondDenom = object.bondDenom ?? "";
        message.minCommissionRate = object.minCommissionRate ?? "";
        return message;
      }
    };
    function createBaseDelegationResponse2() {
      return {
        delegation: exports$1.Delegation.fromPartial({}),
        balance: coin_1.Coin.fromPartial({})
      };
    }
    exports$1.DelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.DelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegation !== void 0) {
          exports$1.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegation = exports$1.Delegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegationResponse2();
        if ((0, helpers_1.isSet)(object.delegation))
          obj.delegation = exports$1.Delegation.fromJSON(object.delegation);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegation !== void 0 && (obj.delegation = message.delegation ? exports$1.Delegation.toJSON(message.delegation) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegationResponse2();
        if (object.delegation !== void 0 && object.delegation !== null) {
          message.delegation = exports$1.Delegation.fromPartial(object.delegation);
        }
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseRedelegationEntryResponse2() {
      return {
        redelegationEntry: exports$1.RedelegationEntry.fromPartial({}),
        balance: ""
      };
    }
    exports$1.RedelegationEntryResponse = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegationEntry !== void 0) {
          exports$1.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntryResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationEntry = exports$1.RedelegationEntry.decode(reader, reader.uint32());
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationEntryResponse2();
        if ((0, helpers_1.isSet)(object.redelegationEntry))
          obj.redelegationEntry = exports$1.RedelegationEntry.fromJSON(object.redelegationEntry);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = String(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.redelegationEntry !== void 0 && (obj.redelegationEntry = message.redelegationEntry ? exports$1.RedelegationEntry.toJSON(message.redelegationEntry) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationEntryResponse2();
        if (object.redelegationEntry !== void 0 && object.redelegationEntry !== null) {
          message.redelegationEntry = exports$1.RedelegationEntry.fromPartial(object.redelegationEntry);
        }
        message.balance = object.balance ?? "";
        return message;
      }
    };
    function createBaseRedelegationResponse2() {
      return {
        redelegation: exports$1.Redelegation.fromPartial({}),
        entries: []
      };
    }
    exports$1.RedelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegation !== void 0) {
          exports$1.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.entries) {
          exports$1.RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegation = exports$1.Redelegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.entries.push(exports$1.RedelegationEntryResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationResponse2();
        if ((0, helpers_1.isSet)(object.redelegation))
          obj.redelegation = exports$1.Redelegation.fromJSON(object.redelegation);
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports$1.RedelegationEntryResponse.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.redelegation !== void 0 && (obj.redelegation = message.redelegation ? exports$1.Redelegation.toJSON(message.redelegation) : void 0);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports$1.RedelegationEntryResponse.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationResponse2();
        if (object.redelegation !== void 0 && object.redelegation !== null) {
          message.redelegation = exports$1.Redelegation.fromPartial(object.redelegation);
        }
        message.entries = object.entries?.map((e) => exports$1.RedelegationEntryResponse.fromPartial(e)) || [];
        return message;
      }
    };
    function createBasePool2() {
      return {
        notBondedTokens: "",
        bondedTokens: ""
      };
    }
    exports$1.Pool = {
      typeUrl: "/cosmos.staking.v1beta1.Pool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.notBondedTokens !== "") {
          writer.uint32(10).string(message.notBondedTokens);
        }
        if (message.bondedTokens !== "") {
          writer.uint32(18).string(message.bondedTokens);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePool2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.notBondedTokens = reader.string();
              break;
            case 2:
              message.bondedTokens = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePool2();
        if ((0, helpers_1.isSet)(object.notBondedTokens))
          obj.notBondedTokens = String(object.notBondedTokens);
        if ((0, helpers_1.isSet)(object.bondedTokens))
          obj.bondedTokens = String(object.bondedTokens);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.notBondedTokens !== void 0 && (obj.notBondedTokens = message.notBondedTokens);
        message.bondedTokens !== void 0 && (obj.bondedTokens = message.bondedTokens);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePool2();
        message.notBondedTokens = object.notBondedTokens ?? "";
        message.bondedTokens = object.bondedTokens ?? "";
        return message;
      }
    };
    function createBaseValidatorUpdates() {
      return {
        updates: []
      };
    }
    exports$1.ValidatorUpdates = {
      typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.updates) {
          types_2.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.updates.push(types_2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorUpdates();
        if (Array.isArray(object?.updates))
          obj.updates = object.updates.map((e) => types_2.ValidatorUpdate.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.updates) {
          obj.updates = message.updates.map((e) => e ? types_2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.updates = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorUpdates();
        message.updates = object.updates?.map((e) => types_2.ValidatorUpdate.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js
var require_tx13 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgUpdateParamsResponse = exports$1.MsgUpdateParams = exports$1.MsgCancelUnbondingDelegationResponse = exports$1.MsgCancelUnbondingDelegation = exports$1.MsgUndelegateResponse = exports$1.MsgUndelegate = exports$1.MsgBeginRedelegateResponse = exports$1.MsgBeginRedelegate = exports$1.MsgDelegateResponse = exports$1.MsgDelegate = exports$1.MsgEditValidatorResponse = exports$1.MsgEditValidator = exports$1.MsgCreateValidatorResponse = exports$1.MsgCreateValidator = exports$1.protobufPackage = void 0;
    var staking_1 = require_staking();
    var any_1 = require_any();
    var coin_1 = require_coin();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseMsgCreateValidator2() {
      return {
        description: staking_1.Description.fromPartial({}),
        commission: staking_1.CommissionRates.fromPartial({}),
        minSelfDelegation: "",
        delegatorAddress: "",
        validatorAddress: "",
        pubkey: void 0,
        value: coin_1.Coin.fromPartial({})
      };
    }
    exports$1.MsgCreateValidator = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(26).string(message.minSelfDelegation);
        }
        if (message.delegatorAddress !== "") {
          writer.uint32(34).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(42).string(message.validatorAddress);
        }
        if (message.pubkey !== void 0) {
          any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        }
        if (message.value !== void 0) {
          coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidator2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());
              break;
            case 3:
              message.minSelfDelegation = reader.string();
              break;
            case 4:
              message.delegatorAddress = reader.string();
              break;
            case 5:
              message.validatorAddress = reader.string();
              break;
            case 6:
              message.pubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.value = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateValidator2();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = staking_1.CommissionRates.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.pubkey))
          obj.pubkey = any_1.Any.fromJSON(object.pubkey);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = coin_1.Coin.fromJSON(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.commission !== void 0 && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.pubkey !== void 0 && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : void 0);
        message.value !== void 0 && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateValidator2();
        if (object.description !== void 0 && object.description !== null) {
          message.description = staking_1.Description.fromPartial(object.description);
        }
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = staking_1.CommissionRates.fromPartial(object.commission);
        }
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.pubkey !== void 0 && object.pubkey !== null) {
          message.pubkey = any_1.Any.fromPartial(object.pubkey);
        }
        if (object.value !== void 0 && object.value !== null) {
          message.value = coin_1.Coin.fromPartial(object.value);
        }
        return message;
      }
    };
    function createBaseMsgCreateValidatorResponse2() {
      return {};
    }
    exports$1.MsgCreateValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidatorResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreateValidatorResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateValidatorResponse2();
        return message;
      }
    };
    function createBaseMsgEditValidator2() {
      return {
        description: staking_1.Description.fromPartial({}),
        validatorAddress: "",
        commissionRate: "",
        minSelfDelegation: ""
      };
    }
    exports$1.MsgEditValidator = {
      typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.commissionRate !== "") {
          writer.uint32(26).string(message.commissionRate);
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(34).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidator2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.commissionRate = reader.string();
              break;
            case 4:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgEditValidator2();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.commissionRate))
          obj.commissionRate = String(object.commissionRate);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.commissionRate !== void 0 && (obj.commissionRate = message.commissionRate);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgEditValidator2();
        if (object.description !== void 0 && object.description !== null) {
          message.description = staking_1.Description.fromPartial(object.description);
        }
        message.validatorAddress = object.validatorAddress ?? "";
        message.commissionRate = object.commissionRate ?? "";
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        return message;
      }
    };
    function createBaseMsgEditValidatorResponse2() {
      return {};
    }
    exports$1.MsgEditValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidatorResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgEditValidatorResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgEditValidatorResponse2();
        return message;
      }
    };
    function createBaseMsgDelegate2() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports$1.MsgDelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegate2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDelegate2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDelegate2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgDelegateResponse2() {
      return {};
    }
    exports$1.MsgDelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegateResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDelegateResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDelegateResponse2();
        return message;
      }
    };
    function createBaseMsgBeginRedelegate2() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports$1.MsgBeginRedelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegate2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgBeginRedelegate2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgBeginRedelegate2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgBeginRedelegateResponse2() {
      return {
        completionTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.MsgBeginRedelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegateResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgBeginRedelegateResponse2();
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgBeginRedelegateResponse2();
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        return message;
      }
    };
    function createBaseMsgUndelegate2() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports$1.MsgUndelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegate2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUndelegate2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUndelegate2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgUndelegateResponse2() {
      return {
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports$1.MsgUndelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUndelegateResponse2();
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUndelegateResponse2();
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegation2() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({}),
        creationHeight: BigInt(0)
      };
    }
    exports$1.MsgCancelUnbondingDelegation = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(32).int64(message.creationHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegation2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.creationHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelUnbondingDelegation2();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelUnbondingDelegation2();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegationResponse2() {
      return {};
    }
    exports$1.MsgCancelUnbondingDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegationResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCancelUnbondingDelegationResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCancelUnbondingDelegationResponse2();
        return message;
      }
    };
    function createBaseMsgUpdateParams17() {
      return {
        authority: "",
        params: staking_1.Params.fromPartial({})
      };
    }
    exports$1.MsgUpdateParams = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams17();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams17();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = staking_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse17() {
      return {};
    }
    exports$1.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse17();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse17();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse17();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateValidator = this.CreateValidator.bind(this);
        this.EditValidator = this.EditValidator.bind(this);
        this.Delegate = this.Delegate.bind(this);
        this.BeginRedelegate = this.BeginRedelegate.bind(this);
        this.Undelegate = this.Undelegate.bind(this);
        this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
      }
      CreateValidator(request) {
        const data2 = exports$1.MsgCreateValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", data2);
        return promise.then((data3) => exports$1.MsgCreateValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      EditValidator(request) {
        const data2 = exports$1.MsgEditValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", data2);
        return promise.then((data3) => exports$1.MsgEditValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Delegate(request) {
        const data2 = exports$1.MsgDelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", data2);
        return promise.then((data3) => exports$1.MsgDelegateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      BeginRedelegate(request) {
        const data2 = exports$1.MsgBeginRedelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", data2);
        return promise.then((data3) => exports$1.MsgBeginRedelegateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Undelegate(request) {
        const data2 = exports$1.MsgUndelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", data2);
        return promise.then((data3) => exports$1.MsgUndelegateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CancelUnbondingDelegation(request) {
        const data2 = exports$1.MsgCancelUnbondingDelegation.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", data2);
        return promise.then((data3) => exports$1.MsgCancelUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports$1.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports$1.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/staking/messages.js
var require_messages8 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/staking/messages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.stakingTypes = void 0;
    exports$1.isMsgBeginRedelegateEncodeObject = isMsgBeginRedelegateEncodeObject;
    exports$1.isMsgCreateValidatorEncodeObject = isMsgCreateValidatorEncodeObject;
    exports$1.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
    exports$1.isMsgEditValidatorEncodeObject = isMsgEditValidatorEncodeObject;
    exports$1.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
    exports$1.isMsgCancelUnbondingDelegationEncodeObject = isMsgCancelUnbondingDelegationEncodeObject;
    var tx_1 = require_tx13();
    exports$1.stakingTypes = [
      ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_1.MsgBeginRedelegate],
      ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_1.MsgCreateValidator],
      ["/cosmos.staking.v1beta1.MsgDelegate", tx_1.MsgDelegate],
      ["/cosmos.staking.v1beta1.MsgEditValidator", tx_1.MsgEditValidator],
      ["/cosmos.staking.v1beta1.MsgUndelegate", tx_1.MsgUndelegate],
      ["/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation", tx_1.MsgCancelUnbondingDelegation]
    ];
    function isMsgBeginRedelegateEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
    }
    function isMsgCreateValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
    }
    function isMsgDelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
    }
    function isMsgEditValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
    }
    function isMsgUndelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
    }
    function isMsgCancelUnbondingDelegationEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation";
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js
var require_query13 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueryClientImpl = exports$1.QueryParamsResponse = exports$1.QueryParamsRequest = exports$1.QueryPoolResponse = exports$1.QueryPoolRequest = exports$1.QueryHistoricalInfoResponse = exports$1.QueryHistoricalInfoRequest = exports$1.QueryDelegatorValidatorResponse = exports$1.QueryDelegatorValidatorRequest = exports$1.QueryDelegatorValidatorsResponse = exports$1.QueryDelegatorValidatorsRequest = exports$1.QueryRedelegationsResponse = exports$1.QueryRedelegationsRequest = exports$1.QueryDelegatorUnbondingDelegationsResponse = exports$1.QueryDelegatorUnbondingDelegationsRequest = exports$1.QueryDelegatorDelegationsResponse = exports$1.QueryDelegatorDelegationsRequest = exports$1.QueryUnbondingDelegationResponse = exports$1.QueryUnbondingDelegationRequest = exports$1.QueryDelegationResponse = exports$1.QueryDelegationRequest = exports$1.QueryValidatorUnbondingDelegationsResponse = exports$1.QueryValidatorUnbondingDelegationsRequest = exports$1.QueryValidatorDelegationsResponse = exports$1.QueryValidatorDelegationsRequest = exports$1.QueryValidatorResponse = exports$1.QueryValidatorRequest = exports$1.QueryValidatorsResponse = exports$1.QueryValidatorsRequest = exports$1.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var staking_1 = require_staking();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseQueryValidatorsRequest2() {
      return {
        status: "",
        pagination: void 0
      };
    }
    exports$1.QueryValidatorsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorsRequest2();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = String(object.status);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorsRequest2();
        message.status = object.status ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorsResponse2() {
      return {
        validators: [],
        pagination: void 0
      };
    }
    exports$1.QueryValidatorsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorsResponse2();
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorsResponse2();
        message.validators = object.validators?.map((e) => staking_1.Validator.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorRequest2() {
      return {
        validatorAddr: ""
      };
    }
    exports$1.QueryValidatorRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorRequest2();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorRequest2();
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorResponse2() {
      return {
        validator: staking_1.Validator.fromPartial({})
      };
    }
    exports$1.QueryValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorResponse2();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorResponse2();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = staking_1.Validator.fromPartial(object.validator);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsRequest2() {
      return {
        validatorAddr: "",
        pagination: void 0
      };
    }
    exports$1.QueryValidatorDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDelegationsRequest2();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDelegationsRequest2();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsResponse2() {
      return {
        delegationResponses: [],
        pagination: void 0
      };
    }
    exports$1.QueryValidatorDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDelegationsResponse2();
        if (Array.isArray(object?.delegationResponses))
          obj.delegationResponses = object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDelegationsResponse2();
        message.delegationResponses = object.delegationResponses?.map((e) => staking_1.DelegationResponse.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsRequest2() {
      return {
        validatorAddr: "",
        pagination: void 0
      };
    }
    exports$1.QueryValidatorUnbondingDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsRequest2();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorUnbondingDelegationsRequest2();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsResponse2() {
      return {
        unbondingResponses: [],
        pagination: void 0
      };
    }
    exports$1.QueryValidatorUnbondingDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsResponse2();
        if (Array.isArray(object?.unbondingResponses))
          obj.unbondingResponses = object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorUnbondingDelegationsResponse2();
        message.unbondingResponses = object.unbondingResponses?.map((e) => staking_1.UnbondingDelegation.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegationRequest2() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports$1.QueryDelegationRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegationRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRequest2();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRequest2();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationResponse2() {
      return {
        delegationResponse: void 0
      };
    }
    exports$1.QueryDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegationResponse !== void 0) {
          staking_1.DelegationResponse.encode(message.delegationResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponse = staking_1.DelegationResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationResponse2();
        if ((0, helpers_1.isSet)(object.delegationResponse))
          obj.delegationResponse = staking_1.DelegationResponse.fromJSON(object.delegationResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegationResponse !== void 0 && (obj.delegationResponse = message.delegationResponse ? staking_1.DelegationResponse.toJSON(message.delegationResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationResponse2();
        if (object.delegationResponse !== void 0 && object.delegationResponse !== null) {
          message.delegationResponse = staking_1.DelegationResponse.fromPartial(object.delegationResponse);
        }
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationRequest2() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports$1.QueryUnbondingDelegationRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnbondingDelegationRequest2();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationRequest2();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationResponse2() {
      return {
        unbond: staking_1.UnbondingDelegation.fromPartial({})
      };
    }
    exports$1.QueryUnbondingDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbond !== void 0) {
          staking_1.UnbondingDelegation.encode(message.unbond, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbond = staking_1.UnbondingDelegation.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnbondingDelegationResponse2();
        if ((0, helpers_1.isSet)(object.unbond))
          obj.unbond = staking_1.UnbondingDelegation.fromJSON(object.unbond);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.unbond !== void 0 && (obj.unbond = message.unbond ? staking_1.UnbondingDelegation.toJSON(message.unbond) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationResponse2();
        if (object.unbond !== void 0 && object.unbond !== null) {
          message.unbond = staking_1.UnbondingDelegation.fromPartial(object.unbond);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsRequest2() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports$1.QueryDelegatorDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorDelegationsRequest2();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorDelegationsRequest2();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsResponse2() {
      return {
        delegationResponses: [],
        pagination: void 0
      };
    }
    exports$1.QueryDelegatorDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorDelegationsResponse2();
        if (Array.isArray(object?.delegationResponses))
          obj.delegationResponses = object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorDelegationsResponse2();
        message.delegationResponses = object.delegationResponses?.map((e) => staking_1.DelegationResponse.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsRequest2() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports$1.QueryDelegatorUnbondingDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsRequest2();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest2();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsResponse2() {
      return {
        unbondingResponses: [],
        pagination: void 0
      };
    }
    exports$1.QueryDelegatorUnbondingDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsResponse2();
        if (Array.isArray(object?.unbondingResponses))
          obj.unbondingResponses = object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse2();
        message.unbondingResponses = object.unbondingResponses?.map((e) => staking_1.UnbondingDelegation.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryRedelegationsRequest2() {
      return {
        delegatorAddr: "",
        srcValidatorAddr: "",
        dstValidatorAddr: "",
        pagination: void 0
      };
    }
    exports$1.QueryRedelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.srcValidatorAddr !== "") {
          writer.uint32(18).string(message.srcValidatorAddr);
        }
        if (message.dstValidatorAddr !== "") {
          writer.uint32(26).string(message.dstValidatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.srcValidatorAddr = reader.string();
              break;
            case 3:
              message.dstValidatorAddr = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRedelegationsRequest2();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.srcValidatorAddr))
          obj.srcValidatorAddr = String(object.srcValidatorAddr);
        if ((0, helpers_1.isSet)(object.dstValidatorAddr))
          obj.dstValidatorAddr = String(object.dstValidatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.srcValidatorAddr !== void 0 && (obj.srcValidatorAddr = message.srcValidatorAddr);
        message.dstValidatorAddr !== void 0 && (obj.dstValidatorAddr = message.dstValidatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRedelegationsRequest2();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.srcValidatorAddr = object.srcValidatorAddr ?? "";
        message.dstValidatorAddr = object.dstValidatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryRedelegationsResponse2() {
      return {
        redelegationResponses: [],
        pagination: void 0
      };
    }
    exports$1.QueryRedelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.redelegationResponses) {
          staking_1.RedelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationResponses.push(staking_1.RedelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRedelegationsResponse2();
        if (Array.isArray(object?.redelegationResponses))
          obj.redelegationResponses = object.redelegationResponses.map((e) => staking_1.RedelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.redelegationResponses) {
          obj.redelegationResponses = message.redelegationResponses.map((e) => e ? staking_1.RedelegationResponse.toJSON(e) : void 0);
        } else {
          obj.redelegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRedelegationsResponse2();
        message.redelegationResponses = object.redelegationResponses?.map((e) => staking_1.RedelegationResponse.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest3() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports$1.QueryDelegatorValidatorsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsRequest3();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest3();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse3() {
      return {
        validators: [],
        pagination: void 0
      };
    }
    exports$1.QueryDelegatorValidatorsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsResponse3();
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsResponse3();
        message.validators = object.validators?.map((e) => staking_1.Validator.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorRequest2() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports$1.QueryDelegatorValidatorRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorRequest2();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorRequest2();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorResponse2() {
      return {
        validator: staking_1.Validator.fromPartial({})
      };
    }
    exports$1.QueryDelegatorValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorResponse2();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorResponse2();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = staking_1.Validator.fromPartial(object.validator);
        }
        return message;
      }
    };
    function createBaseQueryHistoricalInfoRequest2() {
      return {
        height: BigInt(0)
      };
    }
    exports$1.QueryHistoricalInfoRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryHistoricalInfoRequest2();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoRequest2();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        return message;
      }
    };
    function createBaseQueryHistoricalInfoResponse2() {
      return {
        hist: void 0
      };
    }
    exports$1.QueryHistoricalInfoResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hist !== void 0) {
          staking_1.HistoricalInfo.encode(message.hist, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hist = staking_1.HistoricalInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryHistoricalInfoResponse2();
        if ((0, helpers_1.isSet)(object.hist))
          obj.hist = staking_1.HistoricalInfo.fromJSON(object.hist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hist !== void 0 && (obj.hist = message.hist ? staking_1.HistoricalInfo.toJSON(message.hist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoResponse2();
        if (object.hist !== void 0 && object.hist !== null) {
          message.hist = staking_1.HistoricalInfo.fromPartial(object.hist);
        }
        return message;
      }
    };
    function createBaseQueryPoolRequest2() {
      return {};
    }
    exports$1.QueryPoolRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryPoolRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryPoolRequest2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryPoolRequest2();
        return message;
      }
    };
    function createBaseQueryPoolResponse2() {
      return {
        pool: staking_1.Pool.fromPartial({})
      };
    }
    exports$1.QueryPoolResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryPoolResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pool !== void 0) {
          staking_1.Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool = staking_1.Pool.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPoolResponse2();
        if ((0, helpers_1.isSet)(object.pool))
          obj.pool = staking_1.Pool.fromJSON(object.pool);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pool !== void 0 && (obj.pool = message.pool ? staking_1.Pool.toJSON(message.pool) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPoolResponse2();
        if (object.pool !== void 0 && object.pool !== null) {
          message.pool = staking_1.Pool.fromPartial(object.pool);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest18() {
      return {};
    }
    exports$1.QueryParamsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest18();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest18();
        return message;
      }
    };
    function createBaseQueryParamsResponse18() {
      return {
        params: staking_1.Params.fromPartial({})
      };
    }
    exports$1.QueryParamsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse18();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse18();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse18();
        if (object.params !== void 0 && object.params !== null) {
          message.params = staking_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Validators = this.Validators.bind(this);
        this.Validator = this.Validator.bind(this);
        this.ValidatorDelegations = this.ValidatorDelegations.bind(this);
        this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this);
        this.Delegation = this.Delegation.bind(this);
        this.UnbondingDelegation = this.UnbondingDelegation.bind(this);
        this.DelegatorDelegations = this.DelegatorDelegations.bind(this);
        this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this);
        this.Redelegations = this.Redelegations.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorValidator = this.DelegatorValidator.bind(this);
        this.HistoricalInfo = this.HistoricalInfo.bind(this);
        this.Pool = this.Pool.bind(this);
        this.Params = this.Params.bind(this);
      }
      Validators(request) {
        const data2 = exports$1.QueryValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", data2);
        return promise.then((data3) => exports$1.QueryValidatorsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Validator(request) {
        const data2 = exports$1.QueryValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", data2);
        return promise.then((data3) => exports$1.QueryValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorDelegations(request) {
        const data2 = exports$1.QueryValidatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", data2);
        return promise.then((data3) => exports$1.QueryValidatorDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorUnbondingDelegations(request) {
        const data2 = exports$1.QueryValidatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", data2);
        return promise.then((data3) => exports$1.QueryValidatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Delegation(request) {
        const data2 = exports$1.QueryDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", data2);
        return promise.then((data3) => exports$1.QueryDelegationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnbondingDelegation(request) {
        const data2 = exports$1.QueryUnbondingDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", data2);
        return promise.then((data3) => exports$1.QueryUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorDelegations(request) {
        const data2 = exports$1.QueryDelegatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", data2);
        return promise.then((data3) => exports$1.QueryDelegatorDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorUnbondingDelegations(request) {
        const data2 = exports$1.QueryDelegatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", data2);
        return promise.then((data3) => exports$1.QueryDelegatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Redelegations(request) {
        const data2 = exports$1.QueryRedelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", data2);
        return promise.then((data3) => exports$1.QueryRedelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorValidators(request) {
        const data2 = exports$1.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", data2);
        return promise.then((data3) => exports$1.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorValidator(request) {
        const data2 = exports$1.QueryDelegatorValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", data2);
        return promise.then((data3) => exports$1.QueryDelegatorValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      HistoricalInfo(request) {
        const data2 = exports$1.QueryHistoricalInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", data2);
        return promise.then((data3) => exports$1.QueryHistoricalInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Pool(request = {}) {
        const data2 = exports$1.QueryPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", data2);
        return promise.then((data3) => exports$1.QueryPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports$1.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports$1.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.QueryClientImpl = QueryClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/staking/queries.js
var require_queries10 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/staking/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupStakingExtension = setupStakingExtension;
    var query_1 = require_query13();
    var queryclient_1 = require_queryclient2();
    function setupStakingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        staking: {
          delegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.Delegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorUnbondingDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorUnbondingDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorValidator: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegatorValidator({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          historicalInfo: async (height) => {
            const response = await queryService.HistoricalInfo({
              height: BigInt(height)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          pool: async () => {
            const response = await queryService.Pool({});
            return response;
          },
          redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey) => {
            const response = await queryService.Redelegations({
              delegatorAddr: delegatorAddress,
              srcValidatorAddr: sourceValidatorAddress,
              dstValidatorAddr: destinationValidatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          unbondingDelegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.UnbondingDelegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          validator: async (validatorAddress) => {
            const response = await queryService.Validator({ validatorAddr: validatorAddress });
            return response;
          },
          validatorDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validators: async (status, paginationKey) => {
            const response = await queryService.Validators({
              status,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validatorUnbondingDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorUnbondingDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/evidence.js
var require_evidence = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/evidence.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.EvidenceList = exports$1.LightClientAttackEvidence = exports$1.DuplicateVoteEvidence = exports$1.Evidence = exports$1.protobufPackage = void 0;
    var types_1 = require_types3();
    var timestamp_1 = require_timestamp();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "tendermint.types";
    function createBaseEvidence2() {
      return {
        duplicateVoteEvidence: void 0,
        lightClientAttackEvidence: void 0
      };
    }
    exports$1.Evidence = {
      typeUrl: "/tendermint.types.Evidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.duplicateVoteEvidence !== void 0) {
          exports$1.DuplicateVoteEvidence.encode(message.duplicateVoteEvidence, writer.uint32(10).fork()).ldelim();
        }
        if (message.lightClientAttackEvidence !== void 0) {
          exports$1.LightClientAttackEvidence.encode(message.lightClientAttackEvidence, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidence2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.duplicateVoteEvidence = exports$1.DuplicateVoteEvidence.decode(reader, reader.uint32());
              break;
            case 2:
              message.lightClientAttackEvidence = exports$1.LightClientAttackEvidence.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidence2();
        if ((0, helpers_1.isSet)(object.duplicateVoteEvidence))
          obj.duplicateVoteEvidence = exports$1.DuplicateVoteEvidence.fromJSON(object.duplicateVoteEvidence);
        if ((0, helpers_1.isSet)(object.lightClientAttackEvidence))
          obj.lightClientAttackEvidence = exports$1.LightClientAttackEvidence.fromJSON(object.lightClientAttackEvidence);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.duplicateVoteEvidence !== void 0 && (obj.duplicateVoteEvidence = message.duplicateVoteEvidence ? exports$1.DuplicateVoteEvidence.toJSON(message.duplicateVoteEvidence) : void 0);
        message.lightClientAttackEvidence !== void 0 && (obj.lightClientAttackEvidence = message.lightClientAttackEvidence ? exports$1.LightClientAttackEvidence.toJSON(message.lightClientAttackEvidence) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidence2();
        if (object.duplicateVoteEvidence !== void 0 && object.duplicateVoteEvidence !== null) {
          message.duplicateVoteEvidence = exports$1.DuplicateVoteEvidence.fromPartial(object.duplicateVoteEvidence);
        }
        if (object.lightClientAttackEvidence !== void 0 && object.lightClientAttackEvidence !== null) {
          message.lightClientAttackEvidence = exports$1.LightClientAttackEvidence.fromPartial(object.lightClientAttackEvidence);
        }
        return message;
      }
    };
    function createBaseDuplicateVoteEvidence2() {
      return {
        voteA: void 0,
        voteB: void 0,
        totalVotingPower: BigInt(0),
        validatorPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.DuplicateVoteEvidence = {
      typeUrl: "/tendermint.types.DuplicateVoteEvidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteA !== void 0) {
          types_1.Vote.encode(message.voteA, writer.uint32(10).fork()).ldelim();
        }
        if (message.voteB !== void 0) {
          types_1.Vote.encode(message.voteB, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        if (message.validatorPower !== BigInt(0)) {
          writer.uint32(32).int64(message.validatorPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuplicateVoteEvidence2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteA = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 2:
              message.voteB = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            case 4:
              message.validatorPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDuplicateVoteEvidence2();
        if ((0, helpers_1.isSet)(object.voteA))
          obj.voteA = types_1.Vote.fromJSON(object.voteA);
        if ((0, helpers_1.isSet)(object.voteB))
          obj.voteB = types_1.Vote.fromJSON(object.voteB);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.validatorPower))
          obj.validatorPower = BigInt(object.validatorPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteA !== void 0 && (obj.voteA = message.voteA ? types_1.Vote.toJSON(message.voteA) : void 0);
        message.voteB !== void 0 && (obj.voteB = message.voteB ? types_1.Vote.toJSON(message.voteB) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.validatorPower !== void 0 && (obj.validatorPower = (message.validatorPower || BigInt(0)).toString());
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDuplicateVoteEvidence2();
        if (object.voteA !== void 0 && object.voteA !== null) {
          message.voteA = types_1.Vote.fromPartial(object.voteA);
        }
        if (object.voteB !== void 0 && object.voteB !== null) {
          message.voteB = types_1.Vote.fromPartial(object.voteB);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        if (object.validatorPower !== void 0 && object.validatorPower !== null) {
          message.validatorPower = BigInt(object.validatorPower.toString());
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        return message;
      }
    };
    function createBaseLightClientAttackEvidence2() {
      return {
        conflictingBlock: void 0,
        commonHeight: BigInt(0),
        byzantineValidators: [],
        totalVotingPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports$1.LightClientAttackEvidence = {
      typeUrl: "/tendermint.types.LightClientAttackEvidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.conflictingBlock !== void 0) {
          types_1.LightBlock.encode(message.conflictingBlock, writer.uint32(10).fork()).ldelim();
        }
        if (message.commonHeight !== BigInt(0)) {
          writer.uint32(16).int64(message.commonHeight);
        }
        for (const v of message.byzantineValidators) {
          validator_1.Validator.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(32).int64(message.totalVotingPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightClientAttackEvidence2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.conflictingBlock = types_1.LightBlock.decode(reader, reader.uint32());
              break;
            case 2:
              message.commonHeight = reader.int64();
              break;
            case 3:
              message.byzantineValidators.push(validator_1.Validator.decode(reader, reader.uint32()));
              break;
            case 4:
              message.totalVotingPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLightClientAttackEvidence2();
        if ((0, helpers_1.isSet)(object.conflictingBlock))
          obj.conflictingBlock = types_1.LightBlock.fromJSON(object.conflictingBlock);
        if ((0, helpers_1.isSet)(object.commonHeight))
          obj.commonHeight = BigInt(object.commonHeight.toString());
        if (Array.isArray(object?.byzantineValidators))
          obj.byzantineValidators = object.byzantineValidators.map((e) => validator_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.conflictingBlock !== void 0 && (obj.conflictingBlock = message.conflictingBlock ? types_1.LightBlock.toJSON(message.conflictingBlock) : void 0);
        message.commonHeight !== void 0 && (obj.commonHeight = (message.commonHeight || BigInt(0)).toString());
        if (message.byzantineValidators) {
          obj.byzantineValidators = message.byzantineValidators.map((e) => e ? validator_1.Validator.toJSON(e) : void 0);
        } else {
          obj.byzantineValidators = [];
        }
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLightClientAttackEvidence2();
        if (object.conflictingBlock !== void 0 && object.conflictingBlock !== null) {
          message.conflictingBlock = types_1.LightBlock.fromPartial(object.conflictingBlock);
        }
        if (object.commonHeight !== void 0 && object.commonHeight !== null) {
          message.commonHeight = BigInt(object.commonHeight.toString());
        }
        message.byzantineValidators = object.byzantineValidators?.map((e) => validator_1.Validator.fromPartial(e)) || [];
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        return message;
      }
    };
    function createBaseEvidenceList2() {
      return {
        evidence: []
      };
    }
    exports$1.EvidenceList = {
      typeUrl: "/tendermint.types.EvidenceList",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.evidence) {
          exports$1.Evidence.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceList2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.evidence.push(exports$1.Evidence.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidenceList2();
        if (Array.isArray(object?.evidence))
          obj.evidence = object.evidence.map((e) => exports$1.Evidence.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.evidence) {
          obj.evidence = message.evidence.map((e) => e ? exports$1.Evidence.toJSON(e) : void 0);
        } else {
          obj.evidence = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidenceList2();
        message.evidence = object.evidence?.map((e) => exports$1.Evidence.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/block.js
var require_block = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/block.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Block = exports$1.protobufPackage = void 0;
    var types_1 = require_types3();
    var evidence_1 = require_evidence();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "tendermint.types";
    function createBaseBlock3() {
      return {
        header: types_1.Header.fromPartial({}),
        data: types_1.Data.fromPartial({}),
        evidence: evidence_1.EvidenceList.fromPartial({}),
        lastCommit: void 0
      };
    }
    exports$1.Block = {
      typeUrl: "/tendermint.types.Block",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          types_1.Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          evidence_1.EvidenceList.encode(message.evidence, writer.uint32(26).fork()).ldelim();
        }
        if (message.lastCommit !== void 0) {
          types_1.Commit.encode(message.lastCommit, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlock3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = types_1.Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.evidence = evidence_1.EvidenceList.decode(reader, reader.uint32());
              break;
            case 4:
              message.lastCommit = types_1.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlock3();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = types_1.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = types_1.Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.evidence))
          obj.evidence = evidence_1.EvidenceList.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.lastCommit))
          obj.lastCommit = types_1.Commit.fromJSON(object.lastCommit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        message.data !== void 0 && (obj.data = message.data ? types_1.Data.toJSON(message.data) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toJSON(message.evidence) : void 0);
        message.lastCommit !== void 0 && (obj.lastCommit = message.lastCommit ? types_1.Commit.toJSON(message.lastCommit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlock3();
        if (object.header !== void 0 && object.header !== null) {
          message.header = types_1.Header.fromPartial(object.header);
        }
        if (object.data !== void 0 && object.data !== null) {
          message.data = types_1.Data.fromPartial(object.data);
        }
        if (object.evidence !== void 0 && object.evidence !== null) {
          message.evidence = evidence_1.EvidenceList.fromPartial(object.evidence);
        }
        if (object.lastCommit !== void 0 && object.lastCommit !== null) {
          message.lastCommit = types_1.Commit.fromPartial(object.lastCommit);
        }
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js
var require_abci = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SearchBlocksResult = exports$1.SearchTxsResult = exports$1.TxMsgData = exports$1.MsgData = exports$1.SimulationResponse = exports$1.Result = exports$1.GasInfo = exports$1.Attribute = exports$1.StringEvent = exports$1.ABCIMessageLog = exports$1.TxResponse = exports$1.protobufPackage = void 0;
    var any_1 = require_any();
    var types_1 = require_types4();
    var block_1 = require_block();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.base.abci.v1beta1";
    function createBaseTxResponse2() {
      return {
        height: BigInt(0),
        txhash: "",
        codespace: "",
        code: 0,
        data: "",
        rawLog: "",
        logs: [],
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        tx: void 0,
        timestamp: "",
        events: []
      };
    }
    exports$1.TxResponse = {
      typeUrl: "/cosmos.base.abci.v1beta1.TxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.txhash !== "") {
          writer.uint32(18).string(message.txhash);
        }
        if (message.codespace !== "") {
          writer.uint32(26).string(message.codespace);
        }
        if (message.code !== 0) {
          writer.uint32(32).uint32(message.code);
        }
        if (message.data !== "") {
          writer.uint32(42).string(message.data);
        }
        if (message.rawLog !== "") {
          writer.uint32(50).string(message.rawLog);
        }
        for (const v of message.logs) {
          exports$1.ABCIMessageLog.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.info !== "") {
          writer.uint32(66).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(72).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(80).int64(message.gasUsed);
        }
        if (message.tx !== void 0) {
          any_1.Any.encode(message.tx, writer.uint32(90).fork()).ldelim();
        }
        if (message.timestamp !== "") {
          writer.uint32(98).string(message.timestamp);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(106).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.txhash = reader.string();
              break;
            case 3:
              message.codespace = reader.string();
              break;
            case 4:
              message.code = reader.uint32();
              break;
            case 5:
              message.data = reader.string();
              break;
            case 6:
              message.rawLog = reader.string();
              break;
            case 7:
              message.logs.push(exports$1.ABCIMessageLog.decode(reader, reader.uint32()));
              break;
            case 8:
              message.info = reader.string();
              break;
            case 9:
              message.gasWanted = reader.int64();
              break;
            case 10:
              message.gasUsed = reader.int64();
              break;
            case 11:
              message.tx = any_1.Any.decode(reader, reader.uint32());
              break;
            case 12:
              message.timestamp = reader.string();
              break;
            case 13:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxResponse2();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.txhash))
          obj.txhash = String(object.txhash);
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.rawLog))
          obj.rawLog = String(object.rawLog);
        if (Array.isArray(object?.logs))
          obj.logs = object.logs.map((e) => exports$1.ABCIMessageLog.fromJSON(e));
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gasWanted))
          obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed))
          obj.gasUsed = BigInt(object.gasUsed.toString());
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = any_1.Any.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = String(object.timestamp);
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => types_1.Event.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.txhash !== void 0 && (obj.txhash = message.txhash);
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = message.data);
        message.rawLog !== void 0 && (obj.rawLog = message.rawLog);
        if (message.logs) {
          obj.logs = message.logs.map((e) => e ? exports$1.ABCIMessageLog.toJSON(e) : void 0);
        } else {
          obj.logs = [];
        }
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        message.tx !== void 0 && (obj.tx = message.tx ? any_1.Any.toJSON(message.tx) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxResponse2();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.txhash = object.txhash ?? "";
        message.codespace = object.codespace ?? "";
        message.code = object.code ?? 0;
        message.data = object.data ?? "";
        message.rawLog = object.rawLog ?? "";
        message.logs = object.logs?.map((e) => exports$1.ABCIMessageLog.fromPartial(e)) || [];
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = any_1.Any.fromPartial(object.tx);
        }
        message.timestamp = object.timestamp ?? "";
        message.events = object.events?.map((e) => types_1.Event.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseABCIMessageLog2() {
      return {
        msgIndex: 0,
        log: "",
        events: []
      };
    }
    exports$1.ABCIMessageLog = {
      typeUrl: "/cosmos.base.abci.v1beta1.ABCIMessageLog",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgIndex !== 0) {
          writer.uint32(8).uint32(message.msgIndex);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          exports$1.StringEvent.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseABCIMessageLog2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgIndex = reader.uint32();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(exports$1.StringEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseABCIMessageLog2();
        if ((0, helpers_1.isSet)(object.msgIndex))
          obj.msgIndex = Number(object.msgIndex);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => exports$1.StringEvent.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msgIndex !== void 0 && (obj.msgIndex = Math.round(message.msgIndex));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports$1.StringEvent.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseABCIMessageLog2();
        message.msgIndex = object.msgIndex ?? 0;
        message.log = object.log ?? "";
        message.events = object.events?.map((e) => exports$1.StringEvent.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseStringEvent2() {
      return {
        type: "",
        attributes: []
      };
    }
    exports$1.StringEvent = {
      typeUrl: "/cosmos.base.abci.v1beta1.StringEvent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports$1.Attribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStringEvent2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports$1.Attribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseStringEvent2();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if (Array.isArray(object?.attributes))
          obj.attributes = object.attributes.map((e) => exports$1.Attribute.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports$1.Attribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseStringEvent2();
        message.type = object.type ?? "";
        message.attributes = object.attributes?.map((e) => exports$1.Attribute.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseAttribute3() {
      return {
        key: "",
        value: ""
      };
    }
    exports$1.Attribute = {
      typeUrl: "/cosmos.base.abci.v1beta1.Attribute",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAttribute3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAttribute3();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = String(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAttribute3();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
      }
    };
    function createBaseGasInfo2() {
      return {
        gasWanted: BigInt(0),
        gasUsed: BigInt(0)
      };
    }
    exports$1.GasInfo = {
      typeUrl: "/cosmos.base.abci.v1beta1.GasInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(8).uint64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(16).uint64(message.gasUsed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGasInfo2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasWanted = reader.uint64();
              break;
            case 2:
              message.gasUsed = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGasInfo2();
        if ((0, helpers_1.isSet)(object.gasWanted))
          obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed))
          obj.gasUsed = BigInt(object.gasUsed.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGasInfo2();
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        return message;
      }
    };
    function createBaseResult2() {
      return {
        data: new Uint8Array(),
        log: "",
        events: [],
        msgResponses: []
      };
    }
    exports$1.Result = {
      typeUrl: "/cosmos.base.abci.v1beta1.Result",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.msgResponses) {
          any_1.Any.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResult2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            case 4:
              message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResult2();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => types_1.Event.fromJSON(e));
        if (Array.isArray(object?.msgResponses))
          obj.msgResponses = object.msgResponses.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        if (message.msgResponses) {
          obj.msgResponses = message.msgResponses.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgResponses = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResult2();
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.events = object.events?.map((e) => types_1.Event.fromPartial(e)) || [];
        message.msgResponses = object.msgResponses?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSimulationResponse() {
      return {
        gasInfo: exports$1.GasInfo.fromPartial({}),
        result: void 0
      };
    }
    exports$1.SimulationResponse = {
      typeUrl: "/cosmos.base.abci.v1beta1.SimulationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== void 0) {
          exports$1.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          exports$1.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = exports$1.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = exports$1.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulationResponse();
        if ((0, helpers_1.isSet)(object.gasInfo))
          obj.gasInfo = exports$1.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = exports$1.Result.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? exports$1.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? exports$1.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulationResponse();
        if (object.gasInfo !== void 0 && object.gasInfo !== null) {
          message.gasInfo = exports$1.GasInfo.fromPartial(object.gasInfo);
        }
        if (object.result !== void 0 && object.result !== null) {
          message.result = exports$1.Result.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseMsgData() {
      return {
        msgType: "",
        data: new Uint8Array()
      };
    }
    exports$1.MsgData = {
      typeUrl: "/cosmos.base.abci.v1beta1.MsgData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgType !== "") {
          writer.uint32(10).string(message.msgType);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgType = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgData();
        if ((0, helpers_1.isSet)(object.msgType))
          obj.msgType = String(object.msgType);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msgType !== void 0 && (obj.msgType = message.msgType);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgData();
        message.msgType = object.msgType ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxMsgData() {
      return {
        data: [],
        msgResponses: []
      };
    }
    exports$1.TxMsgData = {
      typeUrl: "/cosmos.base.abci.v1beta1.TxMsgData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.data) {
          exports$1.MsgData.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.msgResponses) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data.push(exports$1.MsgData.decode(reader, reader.uint32()));
              break;
            case 2:
              message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxMsgData();
        if (Array.isArray(object?.data))
          obj.data = object.data.map((e) => exports$1.MsgData.fromJSON(e));
        if (Array.isArray(object?.msgResponses))
          obj.msgResponses = object.msgResponses.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.data) {
          obj.data = message.data.map((e) => e ? exports$1.MsgData.toJSON(e) : void 0);
        } else {
          obj.data = [];
        }
        if (message.msgResponses) {
          obj.msgResponses = message.msgResponses.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgResponses = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxMsgData();
        message.data = object.data?.map((e) => exports$1.MsgData.fromPartial(e)) || [];
        message.msgResponses = object.msgResponses?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSearchTxsResult() {
      return {
        totalCount: BigInt(0),
        count: BigInt(0),
        pageNumber: BigInt(0),
        pageTotal: BigInt(0),
        limit: BigInt(0),
        txs: []
      };
    }
    exports$1.SearchTxsResult = {
      typeUrl: "/cosmos.base.abci.v1beta1.SearchTxsResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalCount !== BigInt(0)) {
          writer.uint32(8).uint64(message.totalCount);
        }
        if (message.count !== BigInt(0)) {
          writer.uint32(16).uint64(message.count);
        }
        if (message.pageNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.pageNumber);
        }
        if (message.pageTotal !== BigInt(0)) {
          writer.uint32(32).uint64(message.pageTotal);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).uint64(message.limit);
        }
        for (const v of message.txs) {
          exports$1.TxResponse.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchTxsResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalCount = reader.uint64();
              break;
            case 2:
              message.count = reader.uint64();
              break;
            case 3:
              message.pageNumber = reader.uint64();
              break;
            case 4:
              message.pageTotal = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            case 6:
              message.txs.push(exports$1.TxResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSearchTxsResult();
        if ((0, helpers_1.isSet)(object.totalCount))
          obj.totalCount = BigInt(object.totalCount.toString());
        if ((0, helpers_1.isSet)(object.count))
          obj.count = BigInt(object.count.toString());
        if ((0, helpers_1.isSet)(object.pageNumber))
          obj.pageNumber = BigInt(object.pageNumber.toString());
        if ((0, helpers_1.isSet)(object.pageTotal))
          obj.pageTotal = BigInt(object.pageTotal.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => exports$1.TxResponse.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalCount !== void 0 && (obj.totalCount = (message.totalCount || BigInt(0)).toString());
        message.count !== void 0 && (obj.count = (message.count || BigInt(0)).toString());
        message.pageNumber !== void 0 && (obj.pageNumber = (message.pageNumber || BigInt(0)).toString());
        message.pageTotal !== void 0 && (obj.pageTotal = (message.pageTotal || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? exports$1.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSearchTxsResult();
        if (object.totalCount !== void 0 && object.totalCount !== null) {
          message.totalCount = BigInt(object.totalCount.toString());
        }
        if (object.count !== void 0 && object.count !== null) {
          message.count = BigInt(object.count.toString());
        }
        if (object.pageNumber !== void 0 && object.pageNumber !== null) {
          message.pageNumber = BigInt(object.pageNumber.toString());
        }
        if (object.pageTotal !== void 0 && object.pageTotal !== null) {
          message.pageTotal = BigInt(object.pageTotal.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.txs = object.txs?.map((e) => exports$1.TxResponse.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSearchBlocksResult() {
      return {
        totalCount: BigInt(0),
        count: BigInt(0),
        pageNumber: BigInt(0),
        pageTotal: BigInt(0),
        limit: BigInt(0),
        blocks: []
      };
    }
    exports$1.SearchBlocksResult = {
      typeUrl: "/cosmos.base.abci.v1beta1.SearchBlocksResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalCount !== BigInt(0)) {
          writer.uint32(8).int64(message.totalCount);
        }
        if (message.count !== BigInt(0)) {
          writer.uint32(16).int64(message.count);
        }
        if (message.pageNumber !== BigInt(0)) {
          writer.uint32(24).int64(message.pageNumber);
        }
        if (message.pageTotal !== BigInt(0)) {
          writer.uint32(32).int64(message.pageTotal);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).int64(message.limit);
        }
        for (const v of message.blocks) {
          block_1.Block.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchBlocksResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalCount = reader.int64();
              break;
            case 2:
              message.count = reader.int64();
              break;
            case 3:
              message.pageNumber = reader.int64();
              break;
            case 4:
              message.pageTotal = reader.int64();
              break;
            case 5:
              message.limit = reader.int64();
              break;
            case 6:
              message.blocks.push(block_1.Block.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSearchBlocksResult();
        if ((0, helpers_1.isSet)(object.totalCount))
          obj.totalCount = BigInt(object.totalCount.toString());
        if ((0, helpers_1.isSet)(object.count))
          obj.count = BigInt(object.count.toString());
        if ((0, helpers_1.isSet)(object.pageNumber))
          obj.pageNumber = BigInt(object.pageNumber.toString());
        if ((0, helpers_1.isSet)(object.pageTotal))
          obj.pageTotal = BigInt(object.pageTotal.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if (Array.isArray(object?.blocks))
          obj.blocks = object.blocks.map((e) => block_1.Block.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalCount !== void 0 && (obj.totalCount = (message.totalCount || BigInt(0)).toString());
        message.count !== void 0 && (obj.count = (message.count || BigInt(0)).toString());
        message.pageNumber !== void 0 && (obj.pageNumber = (message.pageNumber || BigInt(0)).toString());
        message.pageTotal !== void 0 && (obj.pageTotal = (message.pageTotal || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        if (message.blocks) {
          obj.blocks = message.blocks.map((e) => e ? block_1.Block.toJSON(e) : void 0);
        } else {
          obj.blocks = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSearchBlocksResult();
        if (object.totalCount !== void 0 && object.totalCount !== null) {
          message.totalCount = BigInt(object.totalCount.toString());
        }
        if (object.count !== void 0 && object.count !== null) {
          message.count = BigInt(object.count.toString());
        }
        if (object.pageNumber !== void 0 && object.pageNumber !== null) {
          message.pageNumber = BigInt(object.pageNumber.toString());
        }
        if (object.pageTotal !== void 0 && object.pageTotal !== null) {
          message.pageTotal = BigInt(object.pageTotal.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.blocks = object.blocks?.map((e) => block_1.Block.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// ../../node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js
var require_service = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ServiceClientImpl = exports$1.TxDecodeAminoResponse = exports$1.TxDecodeAminoRequest = exports$1.TxEncodeAminoResponse = exports$1.TxEncodeAminoRequest = exports$1.TxEncodeResponse = exports$1.TxEncodeRequest = exports$1.TxDecodeResponse = exports$1.TxDecodeRequest = exports$1.GetBlockWithTxsResponse = exports$1.GetBlockWithTxsRequest = exports$1.GetTxResponse = exports$1.GetTxRequest = exports$1.SimulateResponse = exports$1.SimulateRequest = exports$1.BroadcastTxResponse = exports$1.BroadcastTxRequest = exports$1.GetTxsEventResponse = exports$1.GetTxsEventRequest = exports$1.broadcastModeToJSON = exports$1.broadcastModeFromJSON = exports$1.BroadcastMode = exports$1.orderByToJSON = exports$1.orderByFromJSON = exports$1.OrderBy = exports$1.protobufPackage = void 0;
    var tx_1 = require_tx();
    var pagination_1 = require_pagination();
    var abci_1 = require_abci();
    var types_1 = require_types3();
    var block_1 = require_block();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.tx.v1beta1";
    var OrderBy;
    (function(OrderBy2) {
      OrderBy2[OrderBy2["ORDER_BY_UNSPECIFIED"] = 0] = "ORDER_BY_UNSPECIFIED";
      OrderBy2[OrderBy2["ORDER_BY_ASC"] = 1] = "ORDER_BY_ASC";
      OrderBy2[OrderBy2["ORDER_BY_DESC"] = 2] = "ORDER_BY_DESC";
      OrderBy2[OrderBy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OrderBy || (exports$1.OrderBy = OrderBy = {}));
    function orderByFromJSON2(object) {
      switch (object) {
        case 0:
        case "ORDER_BY_UNSPECIFIED":
          return OrderBy.ORDER_BY_UNSPECIFIED;
        case 1:
        case "ORDER_BY_ASC":
          return OrderBy.ORDER_BY_ASC;
        case 2:
        case "ORDER_BY_DESC":
          return OrderBy.ORDER_BY_DESC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return OrderBy.UNRECOGNIZED;
      }
    }
    exports$1.orderByFromJSON = orderByFromJSON2;
    function orderByToJSON2(object) {
      switch (object) {
        case OrderBy.ORDER_BY_UNSPECIFIED:
          return "ORDER_BY_UNSPECIFIED";
        case OrderBy.ORDER_BY_ASC:
          return "ORDER_BY_ASC";
        case OrderBy.ORDER_BY_DESC:
          return "ORDER_BY_DESC";
        case OrderBy.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.orderByToJSON = orderByToJSON2;
    var BroadcastMode;
    (function(BroadcastMode2) {
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_UNSPECIFIED"] = 0] = "BROADCAST_MODE_UNSPECIFIED";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_BLOCK"] = 1] = "BROADCAST_MODE_BLOCK";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_SYNC"] = 2] = "BROADCAST_MODE_SYNC";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_ASYNC"] = 3] = "BROADCAST_MODE_ASYNC";
      BroadcastMode2[BroadcastMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BroadcastMode || (exports$1.BroadcastMode = BroadcastMode = {}));
    function broadcastModeFromJSON2(object) {
      switch (object) {
        case 0:
        case "BROADCAST_MODE_UNSPECIFIED":
          return BroadcastMode.BROADCAST_MODE_UNSPECIFIED;
        case 1:
        case "BROADCAST_MODE_BLOCK":
          return BroadcastMode.BROADCAST_MODE_BLOCK;
        case 2:
        case "BROADCAST_MODE_SYNC":
          return BroadcastMode.BROADCAST_MODE_SYNC;
        case 3:
        case "BROADCAST_MODE_ASYNC":
          return BroadcastMode.BROADCAST_MODE_ASYNC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BroadcastMode.UNRECOGNIZED;
      }
    }
    exports$1.broadcastModeFromJSON = broadcastModeFromJSON2;
    function broadcastModeToJSON2(object) {
      switch (object) {
        case BroadcastMode.BROADCAST_MODE_UNSPECIFIED:
          return "BROADCAST_MODE_UNSPECIFIED";
        case BroadcastMode.BROADCAST_MODE_BLOCK:
          return "BROADCAST_MODE_BLOCK";
        case BroadcastMode.BROADCAST_MODE_SYNC:
          return "BROADCAST_MODE_SYNC";
        case BroadcastMode.BROADCAST_MODE_ASYNC:
          return "BROADCAST_MODE_ASYNC";
        case BroadcastMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports$1.broadcastModeToJSON = broadcastModeToJSON2;
    function createBaseGetTxsEventRequest2() {
      return {
        events: [],
        pagination: void 0,
        orderBy: 0,
        page: BigInt(0),
        limit: BigInt(0),
        query: ""
      };
    }
    exports$1.GetTxsEventRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxsEventRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.events) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.orderBy !== 0) {
          writer.uint32(24).int32(message.orderBy);
        }
        if (message.page !== BigInt(0)) {
          writer.uint32(32).uint64(message.page);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).uint64(message.limit);
        }
        if (message.query !== "") {
          writer.uint32(50).string(message.query);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 3:
              message.orderBy = reader.int32();
              break;
            case 4:
              message.page = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            case 6:
              message.query = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxsEventRequest2();
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.orderBy))
          obj.orderBy = orderByFromJSON2(object.orderBy);
        if ((0, helpers_1.isSet)(object.page))
          obj.page = BigInt(object.page.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.query))
          obj.query = String(object.query);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e);
        } else {
          obj.events = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        message.orderBy !== void 0 && (obj.orderBy = orderByToJSON2(message.orderBy));
        message.page !== void 0 && (obj.page = (message.page || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        message.query !== void 0 && (obj.query = message.query);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxsEventRequest2();
        message.events = object.events?.map((e) => e) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.orderBy = object.orderBy ?? 0;
        if (object.page !== void 0 && object.page !== null) {
          message.page = BigInt(object.page.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.query = object.query ?? "";
        return message;
      }
    };
    function createBaseGetTxsEventResponse2() {
      return {
        txs: [],
        txResponses: [],
        pagination: void 0,
        total: BigInt(0)
      };
    }
    exports$1.GetTxsEventResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxsEventResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.txResponses) {
          abci_1.TxResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        if (message.total !== BigInt(0)) {
          writer.uint32(32).uint64(message.total);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.txResponses.push(abci_1.TxResponse.decode(reader, reader.uint32()));
              break;
            case 3:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 4:
              message.total = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxsEventResponse2();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => tx_1.Tx.fromJSON(e));
        if (Array.isArray(object?.txResponses))
          obj.txResponses = object.txResponses.map((e) => abci_1.TxResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        if (message.txResponses) {
          obj.txResponses = message.txResponses.map((e) => e ? abci_1.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxsEventResponse2();
        message.txs = object.txs?.map((e) => tx_1.Tx.fromPartial(e)) || [];
        message.txResponses = object.txResponses?.map((e) => abci_1.TxResponse.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        return message;
      }
    };
    function createBaseBroadcastTxRequest2() {
      return {
        txBytes: new Uint8Array(),
        mode: 0
      };
    }
    exports$1.BroadcastTxRequest = {
      typeUrl: "/cosmos.tx.v1beta1.BroadcastTxRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        if (message.mode !== 0) {
          writer.uint32(16).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            case 2:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBroadcastTxRequest2();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = broadcastModeFromJSON2(object.mode);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        message.mode !== void 0 && (obj.mode = broadcastModeToJSON2(message.mode));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBroadcastTxRequest2();
        message.txBytes = object.txBytes ?? new Uint8Array();
        message.mode = object.mode ?? 0;
        return message;
      }
    };
    function createBaseBroadcastTxResponse2() {
      return {
        txResponse: void 0
      };
    }
    exports$1.BroadcastTxResponse = {
      typeUrl: "/cosmos.tx.v1beta1.BroadcastTxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBroadcastTxResponse2();
        if ((0, helpers_1.isSet)(object.txResponse))
          obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBroadcastTxResponse2();
        if (object.txResponse !== void 0 && object.txResponse !== null) {
          message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        }
        return message;
      }
    };
    function createBaseSimulateRequest2() {
      return {
        tx: void 0,
        txBytes: new Uint8Array()
      };
    }
    exports$1.SimulateRequest = {
      typeUrl: "/cosmos.tx.v1beta1.SimulateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txBytes.length !== 0) {
          writer.uint32(18).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulateRequest2();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulateRequest2();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSimulateResponse2() {
      return {
        gasInfo: void 0,
        result: void 0
      };
    }
    exports$1.SimulateResponse = {
      typeUrl: "/cosmos.tx.v1beta1.SimulateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== void 0) {
          abci_1.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          abci_1.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = abci_1.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = abci_1.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulateResponse2();
        if ((0, helpers_1.isSet)(object.gasInfo))
          obj.gasInfo = abci_1.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = abci_1.Result.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? abci_1.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? abci_1.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulateResponse2();
        if (object.gasInfo !== void 0 && object.gasInfo !== null) {
          message.gasInfo = abci_1.GasInfo.fromPartial(object.gasInfo);
        }
        if (object.result !== void 0 && object.result !== null) {
          message.result = abci_1.Result.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseGetTxRequest2() {
      return {
        hash: ""
      };
    }
    exports$1.GetTxRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxRequest2();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxRequest2();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseGetTxResponse2() {
      return {
        tx: void 0,
        txResponse: void 0
      };
    }
    exports$1.GetTxResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxResponse2();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txResponse))
          obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxResponse2();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        if (object.txResponse !== void 0 && object.txResponse !== null) {
          message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        }
        return message;
      }
    };
    function createBaseGetBlockWithTxsRequest2() {
      return {
        height: BigInt(0),
        pagination: void 0
      };
    }
    exports$1.GetBlockWithTxsRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetBlockWithTxsRequest2();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetBlockWithTxsRequest2();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseGetBlockWithTxsResponse2() {
      return {
        txs: [],
        blockId: void 0,
        block: void 0,
        pagination: void 0
      };
    }
    exports$1.GetBlockWithTxsResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockId !== void 0) {
          types_1.BlockID.encode(message.blockId, writer.uint32(18).fork()).ldelim();
        }
        if (message.block !== void 0) {
          block_1.Block.encode(message.block, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.blockId = types_1.BlockID.decode(reader, reader.uint32());
              break;
            case 3:
              message.block = block_1.Block.decode(reader, reader.uint32());
              break;
            case 4:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetBlockWithTxsResponse2();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => tx_1.Tx.fromJSON(e));
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = types_1.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.block))
          obj.block = block_1.Block.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        message.blockId !== void 0 && (obj.blockId = message.blockId ? types_1.BlockID.toJSON(message.blockId) : void 0);
        message.block !== void 0 && (obj.block = message.block ? block_1.Block.toJSON(message.block) : void 0);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetBlockWithTxsResponse2();
        message.txs = object.txs?.map((e) => tx_1.Tx.fromPartial(e)) || [];
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = types_1.BlockID.fromPartial(object.blockId);
        }
        if (object.block !== void 0 && object.block !== null) {
          message.block = block_1.Block.fromPartial(object.block);
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseTxDecodeRequest2() {
      return {
        txBytes: new Uint8Array()
      };
    }
    exports$1.TxDecodeRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeRequest2();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeRequest2();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeResponse2() {
      return {
        tx: void 0
      };
    }
    exports$1.TxDecodeResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeResponse2();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeResponse2();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        return message;
      }
    };
    function createBaseTxEncodeRequest2() {
      return {
        tx: void 0
      };
    }
    exports$1.TxEncodeRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeRequest2();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeRequest2();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        return message;
      }
    };
    function createBaseTxEncodeResponse2() {
      return {
        txBytes: new Uint8Array()
      };
    }
    exports$1.TxEncodeResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeResponse2();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeResponse2();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxEncodeAminoRequest2() {
      return {
        aminoJson: ""
      };
    }
    exports$1.TxEncodeAminoRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") {
          writer.uint32(10).string(message.aminoJson);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoJson = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeAminoRequest2();
        if ((0, helpers_1.isSet)(object.aminoJson))
          obj.aminoJson = String(object.aminoJson);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoJson !== void 0 && (obj.aminoJson = message.aminoJson);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeAminoRequest2();
        message.aminoJson = object.aminoJson ?? "";
        return message;
      }
    };
    function createBaseTxEncodeAminoResponse2() {
      return {
        aminoBinary: new Uint8Array()
      };
    }
    exports$1.TxEncodeAminoResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) {
          writer.uint32(10).bytes(message.aminoBinary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoBinary = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeAminoResponse2();
        if ((0, helpers_1.isSet)(object.aminoBinary))
          obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoBinary !== void 0 && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== void 0 ? message.aminoBinary : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeAminoResponse2();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeAminoRequest2() {
      return {
        aminoBinary: new Uint8Array()
      };
    }
    exports$1.TxDecodeAminoRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) {
          writer.uint32(10).bytes(message.aminoBinary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoBinary = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeAminoRequest2();
        if ((0, helpers_1.isSet)(object.aminoBinary))
          obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoBinary !== void 0 && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== void 0 ? message.aminoBinary : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeAminoRequest2();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeAminoResponse2() {
      return {
        aminoJson: ""
      };
    }
    exports$1.TxDecodeAminoResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") {
          writer.uint32(10).string(message.aminoJson);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoJson = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeAminoResponse2();
        if ((0, helpers_1.isSet)(object.aminoJson))
          obj.aminoJson = String(object.aminoJson);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoJson !== void 0 && (obj.aminoJson = message.aminoJson);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeAminoResponse2();
        message.aminoJson = object.aminoJson ?? "";
        return message;
      }
    };
    var ServiceClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Simulate = this.Simulate.bind(this);
        this.GetTx = this.GetTx.bind(this);
        this.BroadcastTx = this.BroadcastTx.bind(this);
        this.GetTxsEvent = this.GetTxsEvent.bind(this);
        this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this);
        this.TxDecode = this.TxDecode.bind(this);
        this.TxEncode = this.TxEncode.bind(this);
        this.TxEncodeAmino = this.TxEncodeAmino.bind(this);
        this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
      }
      Simulate(request) {
        const data2 = exports$1.SimulateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", data2);
        return promise.then((data3) => exports$1.SimulateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GetTx(request) {
        const data2 = exports$1.GetTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", data2);
        return promise.then((data3) => exports$1.GetTxResponse.decode(new binary_1.BinaryReader(data3)));
      }
      BroadcastTx(request) {
        const data2 = exports$1.BroadcastTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", data2);
        return promise.then((data3) => exports$1.BroadcastTxResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GetTxsEvent(request) {
        const data2 = exports$1.GetTxsEventRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", data2);
        return promise.then((data3) => exports$1.GetTxsEventResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GetBlockWithTxs(request) {
        const data2 = exports$1.GetBlockWithTxsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", data2);
        return promise.then((data3) => exports$1.GetBlockWithTxsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxDecode(request) {
        const data2 = exports$1.TxDecodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", data2);
        return promise.then((data3) => exports$1.TxDecodeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxEncode(request) {
        const data2 = exports$1.TxEncodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", data2);
        return promise.then((data3) => exports$1.TxEncodeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxEncodeAmino(request) {
        const data2 = exports$1.TxEncodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", data2);
        return promise.then((data3) => exports$1.TxEncodeAminoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxDecodeAmino(request) {
        const data2 = exports$1.TxDecodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", data2);
        return promise.then((data3) => exports$1.TxDecodeAminoResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.ServiceClientImpl = ServiceClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/tx/queries.js
var require_queries11 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/tx/queries.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.setupTxExtension = setupTxExtension;
    var proto_signing_1 = require_build6();
    var signing_1 = require_signing();
    var service_1 = require_service();
    var tx_1 = require_tx();
    var queryclient_1 = require_queryclient2();
    function setupTxExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new service_1.ServiceClientImpl(rpc);
      return {
        tx: {
          getTx: async (txId) => {
            const request = {
              hash: txId
            };
            const response = await queryService.GetTx(request);
            return response;
          },
          simulate: async (messages, memo, signer, sequence) => {
            const tx = tx_1.Tx.fromPartial({
              authInfo: tx_1.AuthInfo.fromPartial({
                fee: tx_1.Fee.fromPartial({}),
                signerInfos: [
                  {
                    publicKey: (0, proto_signing_1.encodePubkey)(signer),
                    sequence: BigInt(sequence),
                    modeInfo: { single: { mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED } }
                  }
                ]
              }),
              body: tx_1.TxBody.fromPartial({
                messages: Array.from(messages),
                memo
              }),
              signatures: [new Uint8Array()]
            });
            const request = service_1.SimulateRequest.fromPartial({
              txBytes: tx_1.Tx.encode(tx).finish()
            });
            const response = await queryService.Simulate(request);
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js
var require_aminomessages12 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isAminoMsgCreateVestingAccount = isAminoMsgCreateVestingAccount;
    exports$1.createVestingAminoConverters = createVestingAminoConverters;
    function isAminoMsgCreateVestingAccount(msg) {
      return msg.type === "cosmos-sdk/MsgCreateVestingAccount";
    }
    function createVestingAminoConverters() {
      return {
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
          aminoType: "cosmos-sdk/MsgCreateVestingAccount",
          toAmino: ({ fromAddress, toAddress, amount, endTime, delayed }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount],
            end_time: endTime.toString(),
            delayed
          }),
          fromAmino: ({ from_address, to_address, amount, end_time, delayed }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount],
            endTime: BigInt(end_time),
            delayed
          })
        }
      };
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js
var require_tx14 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MsgClientImpl = exports$1.MsgCreatePeriodicVestingAccountResponse = exports$1.MsgCreatePeriodicVestingAccount = exports$1.MsgCreatePermanentLockedAccountResponse = exports$1.MsgCreatePermanentLockedAccount = exports$1.MsgCreateVestingAccountResponse = exports$1.MsgCreateVestingAccount = exports$1.protobufPackage = void 0;
    var coin_1 = require_coin();
    var vesting_1 = require_vesting();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports$1.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseMsgCreateVestingAccount2() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: [],
        endTime: BigInt(0),
        delayed: false
      };
    }
    exports$1.MsgCreateVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.endTime !== BigInt(0)) {
          writer.uint32(32).int64(message.endTime);
        }
        if (message.delayed === true) {
          writer.uint32(40).bool(message.delayed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccount2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.endTime = reader.int64();
              break;
            case 5:
              message.delayed = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateVestingAccount2();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime))
          obj.endTime = BigInt(object.endTime.toString());
        if ((0, helpers_1.isSet)(object.delayed))
          obj.delayed = Boolean(object.delayed);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || BigInt(0)).toString());
        message.delayed !== void 0 && (obj.delayed = message.delayed);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateVestingAccount2();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.endTime !== void 0 && object.endTime !== null) {
          message.endTime = BigInt(object.endTime.toString());
        }
        message.delayed = object.delayed ?? false;
        return message;
      }
    };
    function createBaseMsgCreateVestingAccountResponse2() {
      return {};
    }
    exports$1.MsgCreateVestingAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccountResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreateVestingAccountResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateVestingAccountResponse2();
        return message;
      }
    };
    function createBaseMsgCreatePermanentLockedAccount2() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: []
      };
    }
    exports$1.MsgCreatePermanentLockedAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccount2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreatePermanentLockedAccount2();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreatePermanentLockedAccount2();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgCreatePermanentLockedAccountResponse2() {
      return {};
    }
    exports$1.MsgCreatePermanentLockedAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccountResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreatePermanentLockedAccountResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreatePermanentLockedAccountResponse2();
        return message;
      }
    };
    function createBaseMsgCreatePeriodicVestingAccount2() {
      return {
        fromAddress: "",
        toAddress: "",
        startTime: BigInt(0),
        vestingPeriods: []
      };
    }
    exports$1.MsgCreatePeriodicVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(24).int64(message.startTime);
        }
        for (const v of message.vestingPeriods) {
          vesting_1.Period.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccount2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.startTime = reader.int64();
              break;
            case 4:
              message.vestingPeriods.push(vesting_1.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreatePeriodicVestingAccount2();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object?.vestingPeriods))
          obj.vestingPeriods = object.vestingPeriods.map((e) => vesting_1.Period.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? vesting_1.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreatePeriodicVestingAccount2();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        message.vestingPeriods = object.vestingPeriods?.map((e) => vesting_1.Period.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgCreatePeriodicVestingAccountResponse2() {
      return {};
    }
    exports$1.MsgCreatePeriodicVestingAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccountResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreatePeriodicVestingAccountResponse2();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreatePeriodicVestingAccountResponse2();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateVestingAccount = this.CreateVestingAccount.bind(this);
        this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this);
        this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this);
      }
      CreateVestingAccount(request) {
        const data2 = exports$1.MsgCreateVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", data2);
        return promise.then((data3) => exports$1.MsgCreateVestingAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreatePermanentLockedAccount(request) {
        const data2 = exports$1.MsgCreatePermanentLockedAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", data2);
        return promise.then((data3) => exports$1.MsgCreatePermanentLockedAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreatePeriodicVestingAccount(request) {
        const data2 = exports$1.MsgCreatePeriodicVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", data2);
        return promise.then((data3) => exports$1.MsgCreatePeriodicVestingAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports$1.MsgClientImpl = MsgClientImpl;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/vesting/messages.js
var require_messages9 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/vesting/messages.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.vestingTypes = void 0;
    var tx_1 = require_tx14();
    exports$1.vestingTypes = [
      ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", tx_1.MsgCreateVestingAccount]
    ];
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/index.js
var require_modules = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isAminoMsgCreateValidator = exports$1.isAminoMsgBeginRedelegate = exports$1.createStakingAminoConverters = exports$1.setupSlashingExtension = exports$1.isAminoMsgUnjail = exports$1.createSlashingAminoConverters = exports$1.setupMintExtension = exports$1.setupIbcExtension = exports$1.isMsgTransferEncodeObject = exports$1.ibcTypes = exports$1.isAminoMsgTransfer = exports$1.createIbcAminoConverters = exports$1.groupTypes = exports$1.createGroupAminoConverters = exports$1.setupGovExtension = exports$1.isMsgVoteWeightedEncodeObject = exports$1.isMsgVoteEncodeObject = exports$1.isMsgSubmitProposalEncodeObject = exports$1.isMsgDepositEncodeObject = exports$1.govTypes = exports$1.isAminoMsgVoteWeighted = exports$1.isAminoMsgVote = exports$1.isAminoMsgSubmitProposal = exports$1.isAminoMsgDeposit = exports$1.createGovAminoConverters = exports$1.setupFeegrantExtension = exports$1.feegrantTypes = exports$1.createFeegrantAminoConverters = exports$1.isAminoMsgSubmitEvidence = exports$1.createEvidenceAminoConverters = exports$1.setupDistributionExtension = exports$1.isMsgWithdrawDelegatorRewardEncodeObject = exports$1.distributionTypes = exports$1.isAminoMsgWithdrawValidatorCommission = exports$1.isAminoMsgWithdrawDelegatorReward = exports$1.isAminoMsgSetWithdrawAddress = exports$1.isAminoMsgFundCommunityPool = exports$1.createDistributionAminoConverters = exports$1.isAminoMsgVerifyInvariant = exports$1.createCrysisAminoConverters = exports$1.setupBankExtension = exports$1.isMsgSendEncodeObject = exports$1.bankTypes = exports$1.isAminoMsgSend = exports$1.isAminoMsgMultiSend = exports$1.createBankAminoConverters = exports$1.setupAuthzExtension = exports$1.authzTypes = exports$1.createAuthzAminoConverters = exports$1.setupAuthExtension = void 0;
    exports$1.vestingTypes = exports$1.isAminoMsgCreateVestingAccount = exports$1.createVestingAminoConverters = exports$1.setupTxExtension = exports$1.setupStakingExtension = exports$1.stakingTypes = exports$1.isMsgUndelegateEncodeObject = exports$1.isMsgEditValidatorEncodeObject = exports$1.isMsgDelegateEncodeObject = exports$1.isMsgCreateValidatorEncodeObject = exports$1.isMsgCancelUnbondingDelegationEncodeObject = exports$1.isMsgBeginRedelegateEncodeObject = exports$1.isAminoMsgUndelegate = exports$1.isAminoMsgEditValidator = exports$1.isAminoMsgDelegate = void 0;
    var queries_1 = require_queries();
    Object.defineProperty(exports$1, "setupAuthExtension", { enumerable: true, get: function() {
      return queries_1.setupAuthExtension;
    } });
    var aminomessages_1 = require_aminomessages();
    Object.defineProperty(exports$1, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createAuthzAminoConverters;
    } });
    var messages_1 = require_messages();
    Object.defineProperty(exports$1, "authzTypes", { enumerable: true, get: function() {
      return messages_1.authzTypes;
    } });
    var queries_2 = require_queries2();
    Object.defineProperty(exports$1, "setupAuthzExtension", { enumerable: true, get: function() {
      return queries_2.setupAuthzExtension;
    } });
    var aminomessages_2 = require_aminomessages2();
    Object.defineProperty(exports$1, "createBankAminoConverters", { enumerable: true, get: function() {
      return aminomessages_2.createBankAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports$1, "isAminoMsgSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgSend;
    } });
    var messages_2 = require_messages2();
    Object.defineProperty(exports$1, "bankTypes", { enumerable: true, get: function() {
      return messages_2.bankTypes;
    } });
    Object.defineProperty(exports$1, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return messages_2.isMsgSendEncodeObject;
    } });
    var queries_3 = require_queries3();
    Object.defineProperty(exports$1, "setupBankExtension", { enumerable: true, get: function() {
      return queries_3.setupBankExtension;
    } });
    var aminomessages_3 = require_aminomessages3();
    Object.defineProperty(exports$1, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return aminomessages_3.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return aminomessages_3.isAminoMsgVerifyInvariant;
    } });
    var aminomessages_4 = require_aminomessages4();
    Object.defineProperty(exports$1, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return aminomessages_4.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports$1, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports$1, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports$1, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawValidatorCommission;
    } });
    var messages_3 = require_messages3();
    Object.defineProperty(exports$1, "distributionTypes", { enumerable: true, get: function() {
      return messages_3.distributionTypes;
    } });
    Object.defineProperty(exports$1, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return messages_3.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    var queries_4 = require_queries4();
    Object.defineProperty(exports$1, "setupDistributionExtension", { enumerable: true, get: function() {
      return queries_4.setupDistributionExtension;
    } });
    var aminomessages_5 = require_aminomessages5();
    Object.defineProperty(exports$1, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return aminomessages_5.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return aminomessages_5.isAminoMsgSubmitEvidence;
    } });
    var aminomessages_6 = require_aminomessages6();
    Object.defineProperty(exports$1, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return aminomessages_6.createFeegrantAminoConverters;
    } });
    var messages_4 = require_messages4();
    Object.defineProperty(exports$1, "feegrantTypes", { enumerable: true, get: function() {
      return messages_4.feegrantTypes;
    } });
    var queries_5 = require_queries5();
    Object.defineProperty(exports$1, "setupFeegrantExtension", { enumerable: true, get: function() {
      return queries_5.setupFeegrantExtension;
    } });
    var aminomessages_7 = require_aminomessages7();
    Object.defineProperty(exports$1, "createGovAminoConverters", { enumerable: true, get: function() {
      return aminomessages_7.createGovAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports$1, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports$1, "isAminoMsgVote", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVote;
    } });
    Object.defineProperty(exports$1, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVoteWeighted;
    } });
    var messages_5 = require_messages5();
    Object.defineProperty(exports$1, "govTypes", { enumerable: true, get: function() {
      return messages_5.govTypes;
    } });
    Object.defineProperty(exports$1, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteWeightedEncodeObject;
    } });
    var queries_6 = require_queries6();
    Object.defineProperty(exports$1, "setupGovExtension", { enumerable: true, get: function() {
      return queries_6.setupGovExtension;
    } });
    var aminomessages_8 = require_aminomessages8();
    Object.defineProperty(exports$1, "createGroupAminoConverters", { enumerable: true, get: function() {
      return aminomessages_8.createGroupAminoConverters;
    } });
    var messages_6 = require_messages6();
    Object.defineProperty(exports$1, "groupTypes", { enumerable: true, get: function() {
      return messages_6.groupTypes;
    } });
    var aminomessages_9 = require_aminomessages9();
    Object.defineProperty(exports$1, "createIbcAminoConverters", { enumerable: true, get: function() {
      return aminomessages_9.createIbcAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return aminomessages_9.isAminoMsgTransfer;
    } });
    var messages_7 = require_messages7();
    Object.defineProperty(exports$1, "ibcTypes", { enumerable: true, get: function() {
      return messages_7.ibcTypes;
    } });
    Object.defineProperty(exports$1, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgTransferEncodeObject;
    } });
    var queries_7 = require_queries7();
    Object.defineProperty(exports$1, "setupIbcExtension", { enumerable: true, get: function() {
      return queries_7.setupIbcExtension;
    } });
    var queries_8 = require_queries8();
    Object.defineProperty(exports$1, "setupMintExtension", { enumerable: true, get: function() {
      return queries_8.setupMintExtension;
    } });
    var aminomessages_10 = require_aminomessages10();
    Object.defineProperty(exports$1, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_10.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgUnjail;
    } });
    var queries_9 = require_queries9();
    Object.defineProperty(exports$1, "setupSlashingExtension", { enumerable: true, get: function() {
      return queries_9.setupSlashingExtension;
    } });
    var aminomessages_11 = require_aminomessages11();
    Object.defineProperty(exports$1, "createStakingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_11.createStakingAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports$1, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports$1, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports$1, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports$1, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgUndelegate;
    } });
    var messages_8 = require_messages8();
    Object.defineProperty(exports$1, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports$1, "stakingTypes", { enumerable: true, get: function() {
      return messages_8.stakingTypes;
    } });
    var queries_10 = require_queries10();
    Object.defineProperty(exports$1, "setupStakingExtension", { enumerable: true, get: function() {
      return queries_10.setupStakingExtension;
    } });
    var queries_11 = require_queries11();
    Object.defineProperty(exports$1, "setupTxExtension", { enumerable: true, get: function() {
      return queries_11.setupTxExtension;
    } });
    var aminomessages_12 = require_aminomessages12();
    Object.defineProperty(exports$1, "createVestingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_12.createVestingAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return aminomessages_12.isAminoMsgCreateVestingAccount;
    } });
    var messages_9 = require_messages9();
    Object.defineProperty(exports$1, "vestingTypes", { enumerable: true, get: function() {
      return messages_9.vestingTypes;
    } });
  }
});

// ../../node_modules/@cosmjs/stargate/build/multisignature.js
var require_multisignature = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/multisignature.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.makeCompactBitArray = makeCompactBitArray;
    exports$1.makeMultisignedTx = makeMultisignedTx;
    exports$1.makeMultisignedTxBytes = makeMultisignedTxBytes;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var proto_signing_1 = require_build6();
    var multisig_1 = require_multisig();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    function makeCompactBitArray(bits) {
      const byteCount = Math.ceil(bits.length / 8);
      const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
      const bytes = new Uint8Array(byteCount);
      bits.forEach((value, index) => {
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        if (value)
          bytes[bytePos] |= 1 << 8 - 1 - bitPos;
      });
      return multisig_1.CompactBitArray.fromPartial({ elems: bytes, extraBitsStored: extraBits });
    }
    function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const addresses = Array.from(signatures.keys());
      const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;
      const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
      const signaturesList = new Array();
      for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
          signers[i] = true;
          signaturesList.push(signature);
        }
      }
      const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
          multi: {
            bitarray: makeCompactBitArray(signers),
            modeInfos: signaturesList.map((_) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
          }
        },
        sequence: BigInt(sequence)
      };
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [signerInfo],
        fee: {
          amount: [...fee.amount],
          gasLimit: BigInt(fee.gas)
        }
      });
      const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
      const signedTx = tx_1.TxRaw.fromPartial({
        bodyBytes,
        authInfoBytes,
        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()]
      });
      return signedTx;
    }
    function makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);
      return Uint8Array.from(tx_1.TxRaw.encode(signedTx).finish());
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/search.js
var require_search = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/search.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isSearchTxQueryArray = isSearchTxQueryArray;
    function isSearchTxQueryArray(query) {
      return Array.isArray(query);
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/addresses.js
var require_addresses2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/addresses.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    exports$1.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    exports$1.pubkeyToRawAddress = pubkeyToRawAddress;
    exports$1.pubkeyToAddress = pubkeyToAddress;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    function pubkeyToRawAddress(type2, data2) {
      switch (type2) {
        case "ed25519":
          return rawEd25519PubkeyToRawAddress(data2);
        case "secp256k1":
          return rawSecp256k1PubkeyToRawAddress(data2);
        default:
          throw new Error(`Pubkey type ${type2} not supported`);
      }
    }
    function pubkeyToAddress(type2, data2) {
      return (0, encoding_1.toHex)(pubkeyToRawAddress(type2, data2)).toUpperCase();
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/dates.js
var require_dates = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/dates.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DateTime = void 0;
    exports$1.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
    exports$1.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
    exports$1.fromSeconds = fromSeconds;
    exports$1.toSeconds = toSeconds;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    function fromRfc3339WithNanoseconds(dateTimeString) {
      const out = (0, encoding_1.fromRfc3339)(dateTimeString);
      const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
      const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
      out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
      return out;
    }
    function toRfc3339WithNanoseconds(dateTime) {
      const millisecondIso = dateTime.toISOString();
      const nanoseconds = dateTime.nanoseconds?.toString() ?? "";
      return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
    }
    function fromSeconds(seconds, nanos = 0) {
      const checkedNanos = new math_1.Uint32(nanos).toNumber();
      if (checkedNanos > 999999999) {
        throw new Error("Nano seconds must not exceed 999999999");
      }
      const out = new Date(seconds * 1e3 + Math.floor(checkedNanos / 1e6));
      out.nanoseconds = checkedNanos % 1e6;
      return out;
    }
    function toSeconds(date) {
      return {
        seconds: Math.floor(date.getTime() / 1e3),
        nanos: date.getTime() % 1e3 * 1e6 + (date.nanoseconds ?? 0)
      };
    }
    var DateTime = class {
      /** @deprecated Use fromRfc3339WithNanoseconds instead */
      static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
      }
      /** @deprecated Use toRfc3339WithNanoseconds instead */
      static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
      }
    };
    exports$1.DateTime = DateTime;
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/id.js
var require_id = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/id.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.makeJsonRpcId = makeJsonRpcId;
    var counter = 1e4;
    function makeJsonRpcId() {
      return counter += 1;
    }
  }
});

// ../../node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS({
  "../../node_modules/symbol-observable/lib/ponyfill.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    exports$1["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result2;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result2 = _Symbol.observable;
        } else {
          result2 = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
          try {
            _Symbol.observable = result2;
          } catch (err) {
          }
        }
      } else {
        result2 = "@@observable";
      }
      return result2;
    }
  }
});

// ../../node_modules/symbol-observable/ponyfill.js
var require_ponyfill2 = __commonJS({
  "../../node_modules/symbol-observable/ponyfill.js"(exports$1, module) {
    module.exports = require_ponyfill();
  }
});

// ../../node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "../../node_modules/define-properties/index.js"(exports$1, module) {
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof /* @__PURE__ */ Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name2, value, predicate) {
      if (name2 in object) {
        if (predicate === true) {
          if (object[name2] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name2, value, true);
      } else {
        defineDataProperty(object, name2, value);
      }
    };
    var defineProperties = function(object, map2) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map2);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map2));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map2[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// ../../node_modules/globalthis/implementation.js
var require_implementation3 = __commonJS({
  "../../node_modules/globalthis/implementation.js"(exports$1, module) {
    module.exports = global;
  }
});

// ../../node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS({
  "../../node_modules/globalthis/polyfill.js"(exports$1, module) {
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// ../../node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "../../node_modules/globalthis/shim.js"(exports$1, module) {
    var define = require_define_properties();
    var gOPD = require_gopd();
    var getPolyfill = require_polyfill();
    module.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define.supportsDescriptors) {
        var descriptor = gOPD(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// ../../node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "../../node_modules/globalthis/index.js"(exports$1, module) {
    var defineProperties = require_define_properties();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal2 = function() {
      return polyfill;
    };
    defineProperties(getGlobal2, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = getGlobal2;
  }
});

// ../../node_modules/xstream/index.js
var require_xstream = __commonJS({
  "../../node_modules/xstream/index.js"(exports$1) {
    var __extends = exports$1 && exports$1.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p3 in b2) if (b2.hasOwnProperty(p3)) d2[p3] = b2[p3];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.NO_IL = exports$1.NO = exports$1.MemoryStream = exports$1.Stream = void 0;
    var ponyfill_1 = require_ponyfill2();
    var globalthis_1 = require_globalthis();
    var $$observable = ponyfill_1.default(globalthis_1.getPolyfill());
    var NO = {};
    exports$1.NO = NO;
    function noop2() {
    }
    function cp(a) {
      var l = a.length;
      var b = Array(l);
      for (var i = 0; i < l; ++i)
        b[i] = a[i];
      return b;
    }
    function and2(f1, f2) {
      return function andFn(t) {
        return f1(t) && f2(t);
      };
    }
    function _try(c, t, u) {
      try {
        return c.f(t);
      } catch (e) {
        u._e(e);
        return NO;
      }
    }
    var NO_IL = {
      _n: noop2,
      _e: noop2,
      _c: noop2
    };
    exports$1.NO_IL = NO_IL;
    function internalizeProducer(producer) {
      producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
      };
      producer._stop = producer.stop;
    }
    var StreamSub = (
      /** @class */
      (function() {
        function StreamSub2(_stream, _listener) {
          this._stream = _stream;
          this._listener = _listener;
        }
        StreamSub2.prototype.unsubscribe = function() {
          this._stream._remove(this._listener);
        };
        return StreamSub2;
      })()
    );
    var Observer = (
      /** @class */
      (function() {
        function Observer2(_listener) {
          this._listener = _listener;
        }
        Observer2.prototype.next = function(value) {
          this._listener._n(value);
        };
        Observer2.prototype.error = function(err) {
          this._listener._e(err);
        };
        Observer2.prototype.complete = function() {
          this._listener._c();
        };
        return Observer2;
      })()
    );
    var FromObservable = (
      /** @class */
      (function() {
        function FromObservable2(observable) {
          this.type = "fromObservable";
          this.ins = observable;
          this.active = false;
        }
        FromObservable2.prototype._start = function(out) {
          this.out = out;
          this.active = true;
          this._sub = this.ins.subscribe(new Observer(out));
          if (!this.active)
            this._sub.unsubscribe();
        };
        FromObservable2.prototype._stop = function() {
          if (this._sub)
            this._sub.unsubscribe();
          this.active = false;
        };
        return FromObservable2;
      })()
    );
    var Merge = (
      /** @class */
      (function() {
        function Merge2(insArr) {
          this.type = "merge";
          this.insArr = insArr;
          this.out = NO;
          this.ac = 0;
        }
        Merge2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var L = s.length;
          this.ac = L;
          for (var i = 0; i < L; i++)
            s[i]._add(this);
        };
        Merge2.prototype._stop = function() {
          var s = this.insArr;
          var L = s.length;
          for (var i = 0; i < L; i++)
            s[i]._remove(this);
          this.out = NO;
        };
        Merge2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        Merge2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Merge2.prototype._c = function() {
          if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO)
              return;
            u._c();
          }
        };
        return Merge2;
      })()
    );
    var CombineListener = (
      /** @class */
      (function() {
        function CombineListener2(i, out, p3) {
          this.i = i;
          this.out = out;
          this.p = p3;
          p3.ils.push(this);
        }
        CombineListener2.prototype._n = function(t) {
          var p3 = this.p, out = this.out;
          if (out === NO)
            return;
          if (p3.up(t, this.i)) {
            var b = cp(p3.vals);
            out._n(b);
          }
        };
        CombineListener2.prototype._e = function(err) {
          var out = this.out;
          if (out === NO)
            return;
          out._e(err);
        };
        CombineListener2.prototype._c = function() {
          var p3 = this.p;
          if (p3.out === NO)
            return;
          if (--p3.Nc === 0)
            p3.out._c();
        };
        return CombineListener2;
      })()
    );
    var Combine = (
      /** @class */
      (function() {
        function Combine2(insArr) {
          this.type = "combine";
          this.insArr = insArr;
          this.out = NO;
          this.ils = [];
          this.Nc = this.Nn = 0;
          this.vals = [];
        }
        Combine2.prototype.up = function(t, i) {
          var v = this.vals[i];
          var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
          this.vals[i] = t;
          return Nn === 0;
        };
        Combine2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var n = this.Nc = this.Nn = s.length;
          var vals = this.vals = new Array(n);
          if (n === 0) {
            out._n([]);
            out._c();
          } else {
            for (var i = 0; i < n; i++) {
              vals[i] = NO;
              s[i]._add(new CombineListener(i, out, this));
            }
          }
        };
        Combine2.prototype._stop = function() {
          var s = this.insArr;
          var n = s.length;
          var ils = this.ils;
          for (var i = 0; i < n; i++)
            s[i]._remove(ils[i]);
          this.out = NO;
          this.ils = [];
          this.vals = [];
        };
        return Combine2;
      })()
    );
    var FromArray = (
      /** @class */
      (function() {
        function FromArray2(a) {
          this.type = "fromArray";
          this.a = a;
        }
        FromArray2.prototype._start = function(out) {
          var a = this.a;
          for (var i = 0, n = a.length; i < n; i++)
            out._n(a[i]);
          out._c();
        };
        FromArray2.prototype._stop = function() {
        };
        return FromArray2;
      })()
    );
    var FromPromise = (
      /** @class */
      (function() {
        function FromPromise2(p3) {
          this.type = "fromPromise";
          this.on = false;
          this.p = p3;
        }
        FromPromise2.prototype._start = function(out) {
          var prod = this;
          this.on = true;
          this.p.then(function(v) {
            if (prod.on) {
              out._n(v);
              out._c();
            }
          }, function(e) {
            out._e(e);
          }).then(noop2, function(err) {
            setTimeout(function() {
              throw err;
            });
          });
        };
        FromPromise2.prototype._stop = function() {
          this.on = false;
        };
        return FromPromise2;
      })()
    );
    var Periodic = (
      /** @class */
      (function() {
        function Periodic2(period) {
          this.type = "periodic";
          this.period = period;
          this.intervalID = -1;
          this.i = 0;
        }
        Periodic2.prototype._start = function(out) {
          var self2 = this;
          function intervalHandler() {
            out._n(self2.i++);
          }
          this.intervalID = setInterval(intervalHandler, this.period);
        };
        Periodic2.prototype._stop = function() {
          if (this.intervalID !== -1)
            clearInterval(this.intervalID);
          this.intervalID = -1;
          this.i = 0;
        };
        return Periodic2;
      })()
    );
    var Debug = (
      /** @class */
      (function() {
        function Debug2(ins, arg) {
          this.type = "debug";
          this.ins = ins;
          this.out = NO;
          this.s = noop2;
          this.l = "";
          if (typeof arg === "string")
            this.l = arg;
          else if (typeof arg === "function")
            this.s = arg;
        }
        Debug2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Debug2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Debug2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var s = this.s, l = this.l;
          if (s !== noop2) {
            try {
              s(t);
            } catch (e) {
              u._e(e);
            }
          } else if (l)
            console.log(l + ":", t);
          else
            console.log(t);
          u._n(t);
        };
        Debug2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Debug2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Debug2;
      })()
    );
    var Drop = (
      /** @class */
      (function() {
        function Drop2(max, ins) {
          this.type = "drop";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.dropped = 0;
        }
        Drop2.prototype._start = function(out) {
          this.out = out;
          this.dropped = 0;
          this.ins._add(this);
        };
        Drop2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Drop2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          if (this.dropped++ >= this.max)
            u._n(t);
        };
        Drop2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Drop2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Drop2;
      })()
    );
    var EndWhenListener = (
      /** @class */
      (function() {
        function EndWhenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        EndWhenListener2.prototype._n = function() {
          this.op.end();
        };
        EndWhenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        EndWhenListener2.prototype._c = function() {
          this.op.end();
        };
        return EndWhenListener2;
      })()
    );
    var EndWhen = (
      /** @class */
      (function() {
        function EndWhen2(o, ins) {
          this.type = "endWhen";
          this.ins = ins;
          this.out = NO;
          this.o = o;
          this.oil = NO_IL;
        }
        EndWhen2.prototype._start = function(out) {
          this.out = out;
          this.o._add(this.oil = new EndWhenListener(out, this));
          this.ins._add(this);
        };
        EndWhen2.prototype._stop = function() {
          this.ins._remove(this);
          this.o._remove(this.oil);
          this.out = NO;
          this.oil = NO_IL;
        };
        EndWhen2.prototype.end = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        EndWhen2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        EndWhen2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        EndWhen2.prototype._c = function() {
          this.end();
        };
        return EndWhen2;
      })()
    );
    var Filter = (
      /** @class */
      (function() {
        function Filter2(passes, ins) {
          this.type = "filter";
          this.ins = ins;
          this.out = NO;
          this.f = passes;
        }
        Filter2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Filter2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Filter2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO || !r)
            return;
          u._n(t);
        };
        Filter2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Filter2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Filter2;
      })()
    );
    var FlattenListener = (
      /** @class */
      (function() {
        function FlattenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        FlattenListener2.prototype._n = function(t) {
          this.out._n(t);
        };
        FlattenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        FlattenListener2.prototype._c = function() {
          this.op.inner = NO;
          this.op.less();
        };
        return FlattenListener2;
      })()
    );
    var Flatten = (
      /** @class */
      (function() {
        function Flatten2(ins) {
          this.type = "flatten";
          this.ins = ins;
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        }
        Flatten2.prototype._start = function(out) {
          this.out = out;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
          this.ins._add(this);
        };
        Flatten2.prototype._stop = function() {
          this.ins._remove(this);
          if (this.inner !== NO)
            this.inner._remove(this.il);
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        };
        Flatten2.prototype.less = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (!this.open && this.inner === NO)
            u._c();
        };
        Flatten2.prototype._n = function(s) {
          var u = this.out;
          if (u === NO)
            return;
          var _a2 = this, inner = _a2.inner, il = _a2.il;
          if (inner !== NO && il !== NO_IL)
            inner._remove(il);
          (this.inner = s)._add(this.il = new FlattenListener(u, this));
        };
        Flatten2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Flatten2.prototype._c = function() {
          this.open = false;
          this.less();
        };
        return Flatten2;
      })()
    );
    var Fold = (
      /** @class */
      (function() {
        function Fold2(f, seed, ins) {
          var _this = this;
          this.type = "fold";
          this.ins = ins;
          this.out = NO;
          this.f = function(t) {
            return f(_this.acc, t);
          };
          this.acc = this.seed = seed;
        }
        Fold2.prototype._start = function(out) {
          this.out = out;
          this.acc = this.seed;
          out._n(this.acc);
          this.ins._add(this);
        };
        Fold2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.acc = this.seed;
        };
        Fold2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(this.acc = r);
        };
        Fold2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Fold2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Fold2;
      })()
    );
    var Last = (
      /** @class */
      (function() {
        function Last2(ins) {
          this.type = "last";
          this.ins = ins;
          this.out = NO;
          this.has = false;
          this.val = NO;
        }
        Last2.prototype._start = function(out) {
          this.out = out;
          this.has = false;
          this.ins._add(this);
        };
        Last2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.val = NO;
        };
        Last2.prototype._n = function(t) {
          this.has = true;
          this.val = t;
        };
        Last2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Last2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (this.has) {
            u._n(this.val);
            u._c();
          } else
            u._e(new Error("last() failed because input stream completed"));
        };
        return Last2;
      })()
    );
    var MapOp = (
      /** @class */
      (function() {
        function MapOp2(project, ins) {
          this.type = "map";
          this.ins = ins;
          this.out = NO;
          this.f = project;
        }
        MapOp2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        MapOp2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        MapOp2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(r);
        };
        MapOp2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        MapOp2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return MapOp2;
      })()
    );
    var Remember = (
      /** @class */
      (function() {
        function Remember2(ins) {
          this.type = "remember";
          this.ins = ins;
          this.out = NO;
        }
        Remember2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(out);
        };
        Remember2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return Remember2;
      })()
    );
    var ReplaceError = (
      /** @class */
      (function() {
        function ReplaceError2(replacer, ins) {
          this.type = "replaceError";
          this.ins = ins;
          this.out = NO;
          this.f = replacer;
        }
        ReplaceError2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        ReplaceError2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        ReplaceError2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        ReplaceError2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
          } catch (e) {
            u._e(e);
          }
        };
        ReplaceError2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return ReplaceError2;
      })()
    );
    var StartWith = (
      /** @class */
      (function() {
        function StartWith2(ins, val) {
          this.type = "startWith";
          this.ins = ins;
          this.out = NO;
          this.val = val;
        }
        StartWith2.prototype._start = function(out) {
          this.out = out;
          this.out._n(this.val);
          this.ins._add(out);
        };
        StartWith2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return StartWith2;
      })()
    );
    var Take = (
      /** @class */
      (function() {
        function Take2(max, ins) {
          this.type = "take";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.taken = 0;
        }
        Take2.prototype._start = function(out) {
          this.out = out;
          this.taken = 0;
          if (this.max <= 0)
            out._c();
          else
            this.ins._add(this);
        };
        Take2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Take2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var m = ++this.taken;
          if (m < this.max)
            u._n(t);
          else if (m === this.max) {
            u._n(t);
            u._c();
          }
        };
        Take2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Take2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Take2;
      })()
    );
    var Stream = (
      /** @class */
      (function() {
        function Stream2(producer) {
          this._prod = producer || NO;
          this._ils = [];
          this._stopID = NO;
          this._dl = NO;
          this._d = false;
          this._target = null;
          this._err = NO;
        }
        Stream2.prototype._n = function(t) {
          var a = this._ils;
          var L = a.length;
          if (this._d)
            this._dl._n(t);
          if (L == 1)
            a[0]._n(t);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._n(t);
          }
        };
        Stream2.prototype._e = function(err) {
          if (this._err !== NO)
            return;
          this._err = err;
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._e(err);
          if (L == 1)
            a[0]._e(err);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._e(err);
          }
          if (!this._d && L == 0)
            throw this._err;
        };
        Stream2.prototype._c = function() {
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._c();
          if (L == 1)
            a[0]._c();
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._c();
          }
        };
        Stream2.prototype._x = function() {
          if (this._ils.length === 0)
            return;
          if (this._prod !== NO)
            this._prod._stop();
          this._err = NO;
          this._ils = [];
        };
        Stream2.prototype._stopNow = function() {
          this._prod._stop();
          this._err = NO;
          this._stopID = NO;
        };
        Stream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1)
            return;
          if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else {
            var p3 = this._prod;
            if (p3 !== NO)
              p3._start(this);
          }
        };
        Stream2.prototype._remove = function(il) {
          var _this = this;
          var ta = this._target;
          if (ta)
            return ta._remove(il);
          var a = this._ils;
          var i = a.indexOf(il);
          if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
              this._err = NO;
              this._stopID = setTimeout(function() {
                return _this._stopNow();
              });
            } else if (a.length === 1) {
              this._pruneCycles();
            }
          }
        };
        Stream2.prototype._pruneCycles = function() {
          if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
        };
        Stream2.prototype._hasNoSinks = function(x, trace) {
          if (trace.indexOf(x) !== -1)
            return true;
          else if (x.out === this)
            return true;
          else if (x.out && x.out !== NO)
            return this._hasNoSinks(x.out, trace.concat(x));
          else if (x._ils) {
            for (var i = 0, N = x._ils.length; i < N; i++)
              if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
                return false;
            return true;
          } else
            return false;
        };
        Stream2.prototype.ctor = function() {
          return this instanceof MemoryStream ? MemoryStream : Stream2;
        };
        Stream2.prototype.addListener = function(listener) {
          listener._n = listener.next || noop2;
          listener._e = listener.error || noop2;
          listener._c = listener.complete || noop2;
          this._add(listener);
        };
        Stream2.prototype.removeListener = function(listener) {
          this._remove(listener);
        };
        Stream2.prototype.subscribe = function(listener) {
          this.addListener(listener);
          return new StreamSub(this, listener);
        };
        Stream2.prototype[$$observable] = function() {
          return this;
        };
        Stream2.create = function(producer) {
          if (producer) {
            if (typeof producer.start !== "function" || typeof producer.stop !== "function")
              throw new Error("producer requires both start and stop functions");
            internalizeProducer(producer);
          }
          return new Stream2(producer);
        };
        Stream2.createWithMemory = function(producer) {
          if (producer)
            internalizeProducer(producer);
          return new MemoryStream(producer);
        };
        Stream2.never = function() {
          return new Stream2({ _start: noop2, _stop: noop2 });
        };
        Stream2.empty = function() {
          return new Stream2({
            _start: function(il) {
              il._c();
            },
            _stop: noop2
          });
        };
        Stream2.throw = function(error) {
          return new Stream2({
            _start: function(il) {
              il._e(error);
            },
            _stop: noop2
          });
        };
        Stream2.from = function(input) {
          if (typeof input[$$observable] === "function")
            return Stream2.fromObservable(input);
          else if (typeof input.then === "function")
            return Stream2.fromPromise(input);
          else if (Array.isArray(input))
            return Stream2.fromArray(input);
          throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
        };
        Stream2.of = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          return Stream2.fromArray(items);
        };
        Stream2.fromArray = function(array) {
          return new Stream2(new FromArray(array));
        };
        Stream2.fromPromise = function(promise) {
          return new Stream2(new FromPromise(promise));
        };
        Stream2.fromObservable = function(obs) {
          if (obs.endWhen !== void 0)
            return obs;
          var o = typeof obs[$$observable] === "function" ? obs[$$observable]() : obs;
          return new Stream2(new FromObservable(o));
        };
        Stream2.periodic = function(period) {
          return new Stream2(new Periodic(period));
        };
        Stream2.prototype._map = function(project) {
          return new (this.ctor())(new MapOp(project, this));
        };
        Stream2.prototype.map = function(project) {
          return this._map(project);
        };
        Stream2.prototype.mapTo = function(projectedValue) {
          var s = this.map(function() {
            return projectedValue;
          });
          var op = s._prod;
          op.type = "mapTo";
          return s;
        };
        Stream2.prototype.filter = function(passes) {
          var p3 = this._prod;
          if (p3 instanceof Filter)
            return new Stream2(new Filter(and2(p3.f, passes), p3.ins));
          return new Stream2(new Filter(passes, this));
        };
        Stream2.prototype.take = function(amount) {
          return new (this.ctor())(new Take(amount, this));
        };
        Stream2.prototype.drop = function(amount) {
          return new Stream2(new Drop(amount, this));
        };
        Stream2.prototype.last = function() {
          return new Stream2(new Last(this));
        };
        Stream2.prototype.startWith = function(initial) {
          return new MemoryStream(new StartWith(this, initial));
        };
        Stream2.prototype.endWhen = function(other) {
          return new (this.ctor())(new EndWhen(other, this));
        };
        Stream2.prototype.fold = function(accumulate, seed) {
          return new MemoryStream(new Fold(accumulate, seed, this));
        };
        Stream2.prototype.replaceError = function(replace) {
          return new (this.ctor())(new ReplaceError(replace, this));
        };
        Stream2.prototype.flatten = function() {
          return new Stream2(new Flatten(this));
        };
        Stream2.prototype.compose = function(operator) {
          return operator(this);
        };
        Stream2.prototype.remember = function() {
          return new MemoryStream(new Remember(this));
        };
        Stream2.prototype.debug = function(labelOrSpy) {
          return new (this.ctor())(new Debug(this, labelOrSpy));
        };
        Stream2.prototype.imitate = function(target) {
          if (target instanceof MemoryStream)
            throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
          this._target = target;
          for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
            target._add(ils[i]);
          this._ils = [];
        };
        Stream2.prototype.shamefullySendNext = function(value) {
          this._n(value);
        };
        Stream2.prototype.shamefullySendError = function(error) {
          this._e(error);
        };
        Stream2.prototype.shamefullySendComplete = function() {
          this._c();
        };
        Stream2.prototype.setDebugListener = function(listener) {
          if (!listener) {
            this._d = false;
            this._dl = NO;
          } else {
            this._d = true;
            listener._n = listener.next || noop2;
            listener._e = listener.error || noop2;
            listener._c = listener.complete || noop2;
            this._dl = listener;
          }
        };
        Stream2.merge = function merge2() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Merge(streams));
        };
        Stream2.combine = function combine() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Combine(streams));
        };
        return Stream2;
      })()
    );
    exports$1.Stream = Stream;
    var MemoryStream = (
      /** @class */
      (function(_super) {
        __extends(MemoryStream2, _super);
        function MemoryStream2(producer) {
          var _this = _super.call(this, producer) || this;
          _this._has = false;
          return _this;
        }
        MemoryStream2.prototype._n = function(x) {
          this._v = x;
          this._has = true;
          _super.prototype._n.call(this, x);
        };
        MemoryStream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1) {
            if (this._has)
              il._n(this._v);
            return;
          }
          if (this._stopID !== NO) {
            if (this._has)
              il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else if (this._has)
            il._n(this._v);
          else {
            var p3 = this._prod;
            if (p3 !== NO)
              p3._start(this);
          }
        };
        MemoryStream2.prototype._stopNow = function() {
          this._has = false;
          _super.prototype._stopNow.call(this);
        };
        MemoryStream2.prototype._x = function() {
          this._has = false;
          _super.prototype._x.call(this);
        };
        MemoryStream2.prototype.map = function(project) {
          return this._map(project);
        };
        MemoryStream2.prototype.mapTo = function(projectedValue) {
          return _super.prototype.mapTo.call(this, projectedValue);
        };
        MemoryStream2.prototype.take = function(amount) {
          return _super.prototype.take.call(this, amount);
        };
        MemoryStream2.prototype.endWhen = function(other) {
          return _super.prototype.endWhen.call(this, other);
        };
        MemoryStream2.prototype.replaceError = function(replace) {
          return _super.prototype.replaceError.call(this, replace);
        };
        MemoryStream2.prototype.remember = function() {
          return this;
        };
        MemoryStream2.prototype.debug = function(labelOrSpy) {
          return _super.prototype.debug.call(this, labelOrSpy);
        };
        return MemoryStream2;
      })(Stream)
    );
    exports$1.MemoryStream = MemoryStream;
    var xs = Stream;
    exports$1.default = xs;
  }
});

// ../../node_modules/@cosmjs/stream/build/concat.js
var require_concat = __commonJS({
  "../../node_modules/@cosmjs/stream/build/concat.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.concat = concat;
    var xstream_1 = require_xstream();
    function concat(...streams) {
      const subscriptions = new Array();
      const queues = new Array();
      const completedStreams = /* @__PURE__ */ new Set();
      let activeStreamIndex = 0;
      function reset() {
        while (subscriptions.length > 0) {
          const subscription = subscriptions.shift();
          subscription.unsubscribe();
        }
        queues.length = 0;
        completedStreams.clear();
        activeStreamIndex = 0;
      }
      const producer = {
        start: (listener) => {
          streams.forEach((_) => queues.push([]));
          function emitAllQueuesEvents(streamIndex) {
            while (true) {
              const element = queues[streamIndex].shift();
              if (element === void 0) {
                return;
              }
              listener.next(element);
            }
          }
          function isDone() {
            return activeStreamIndex >= streams.length;
          }
          if (isDone()) {
            listener.complete();
            return;
          }
          streams.forEach((stream, index) => {
            subscriptions.push(stream.subscribe({
              next: (value) => {
                if (index === activeStreamIndex) {
                  listener.next(value);
                } else {
                  queues[index].push(value);
                }
              },
              complete: () => {
                completedStreams.add(index);
                while (completedStreams.has(activeStreamIndex)) {
                  emitAllQueuesEvents(activeStreamIndex);
                  activeStreamIndex++;
                }
                if (isDone()) {
                  listener.complete();
                } else {
                  emitAllQueuesEvents(activeStreamIndex);
                }
              },
              error: (error) => {
                listener.error(error);
                reset();
              }
            }));
          });
        },
        stop: () => {
          reset();
        }
      };
      return xstream_1.Stream.create(producer);
    }
  }
});

// ../../node_modules/@cosmjs/stream/build/defaultvalueproducer.js
var require_defaultvalueproducer = __commonJS({
  "../../node_modules/@cosmjs/stream/build/defaultvalueproducer.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DefaultValueProducer = void 0;
    var DefaultValueProducer = class {
      get value() {
        return this.internalValue;
      }
      callbacks;
      internalValue;
      listener;
      constructor(value, callbacks) {
        this.callbacks = callbacks;
        this.internalValue = value;
      }
      /**
       * Update the current value.
       *
       * If producer is active (i.e. someone is listening), this emits an event.
       * If not, just the current value is updated.
       */
      update(value) {
        this.internalValue = value;
        if (this.listener) {
          this.listener.next(value);
        }
      }
      /**
       * Produce an error
       */
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      error(error) {
        if (this.listener) {
          this.listener.error(error);
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      start(listener) {
        this.listener = listener;
        listener.next(this.internalValue);
        if (this.callbacks) {
          this.callbacks.onStarted();
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      stop() {
        if (this.callbacks) {
          this.callbacks.onStop();
        }
        this.listener = void 0;
      }
    };
    exports$1.DefaultValueProducer = DefaultValueProducer;
  }
});

// ../../node_modules/@cosmjs/stream/build/dropduplicates.js
var require_dropduplicates = __commonJS({
  "../../node_modules/@cosmjs/stream/build/dropduplicates.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.dropDuplicates = dropDuplicates;
    function dropDuplicates(valueToKey) {
      const operand = (instream) => {
        const emittedKeys = /* @__PURE__ */ new Set();
        const deduplicatedStream = instream.filter((value) => !emittedKeys.has(valueToKey(value))).debug((value) => emittedKeys.add(valueToKey(value)));
        return deduplicatedStream;
      };
      return operand;
    }
  }
});

// ../../node_modules/@cosmjs/stream/build/promise.js
var require_promise = __commonJS({
  "../../node_modules/@cosmjs/stream/build/promise.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.fromListPromise = fromListPromise;
    exports$1.toListPromise = toListPromise;
    exports$1.firstEvent = firstEvent;
    var xstream_1 = require_xstream();
    function fromListPromise(promise) {
      const producer = {
        start: (listener) => {
          promise.then((iterable) => {
            for (const element of iterable) {
              listener.next(element);
            }
            listener.complete();
          }).catch((error) => {
            listener.error(error);
          });
        },
        stop: () => {
        }
      };
      return xstream_1.Stream.create(producer);
    }
    async function toListPromise(stream, count) {
      return new Promise((resolve, reject) => {
        if (count === 0) {
          resolve([]);
          return;
        }
        const events = new Array();
        stream.take(count).subscribe({
          next: (event) => {
            events.push(event);
            if (events.length === count) {
              resolve(events);
            }
          },
          complete: () => {
            reject(`Stream completed before all events could be collected. Collected ${events.length}, expected ${count}`);
          },
          error: (error) => {
            reject(error);
          }
        });
      });
    }
    async function firstEvent(stream) {
      return (await toListPromise(stream, 1))[0];
    }
  }
});

// ../../node_modules/@cosmjs/stream/build/reducer.js
var require_reducer = __commonJS({
  "../../node_modules/@cosmjs/stream/build/reducer.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Reducer = void 0;
    exports$1.countStream = countStream;
    exports$1.asArray = asArray;
    exports$1.lastValue = lastValue;
    var Reducer = class {
      stream;
      reducer;
      state;
      // completed maintains state of stream, resolves/rejects
      // on complete or error
      completed;
      constructor(stream, reducer, initState) {
        this.stream = stream;
        this.reducer = reducer;
        this.state = initState;
        this.completed = new Promise((resolve, reject) => {
          const subscription = this.stream.subscribe({
            next: (evt) => {
              this.state = this.reducer(this.state, evt);
            },
            complete: () => {
              resolve();
              subscription.unsubscribe();
            },
            error: (err) => {
              reject(err);
              subscription.unsubscribe();
            }
          });
        });
      }
      // value returns current materialized state
      value() {
        return this.state;
      }
      // finished resolves on completed stream, rejects on stream error
      async finished() {
        return this.completed;
      }
    };
    exports$1.Reducer = Reducer;
    function increment(sum, _) {
      return sum + 1;
    }
    function countStream(stream) {
      return new Reducer(stream, increment, 0);
    }
    function append(list, evt) {
      return [...list, evt];
    }
    function asArray(stream) {
      return new Reducer(stream, append, []);
    }
    function last(_, event) {
      return event;
    }
    function lastValue(stream) {
      return new Reducer(stream, last, void 0);
    }
  }
});

// ../../node_modules/@cosmjs/stream/build/valueandupdates.js
var require_valueandupdates = __commonJS({
  "../../node_modules/@cosmjs/stream/build/valueandupdates.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ValueAndUpdates = void 0;
    var xstream_1 = require_xstream();
    var ValueAndUpdates = class {
      updates;
      get value() {
        return this.producer.value;
      }
      producer;
      constructor(producer) {
        this.producer = producer;
        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);
      }
      /**
       * Resolves as soon as search value is found.
       *
       * @param search either a value or a function that must return true when found
       * @returns the value of the update that caused the search match
       */
      async waitFor(search) {
        const searchImplementation = typeof search === "function" ? search : (value) => value === search;
        return new Promise((resolve, reject) => {
          const subscription = this.updates.subscribe({
            next: (newValue) => {
              if (searchImplementation(newValue)) {
                resolve(newValue);
                setTimeout(() => {
                  subscription.unsubscribe();
                }, 0);
              }
            },
            complete: () => {
              subscription.unsubscribe();
              reject("Update stream completed without expected value");
            },
            error: (error) => {
              reject(error);
            }
          });
        });
      }
    };
    exports$1.ValueAndUpdates = ValueAndUpdates;
  }
});

// ../../node_modules/@cosmjs/stream/build/index.js
var require_build7 = __commonJS({
  "../../node_modules/@cosmjs/stream/build/index.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports$1 && exports$1.__exportStar || function(m, exports2) {
      for (var p3 in m) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m, p3);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ValueAndUpdates = exports$1.toListPromise = exports$1.fromListPromise = exports$1.firstEvent = exports$1.dropDuplicates = exports$1.DefaultValueProducer = exports$1.concat = void 0;
    var concat_1 = require_concat();
    Object.defineProperty(exports$1, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var defaultvalueproducer_1 = require_defaultvalueproducer();
    Object.defineProperty(exports$1, "DefaultValueProducer", { enumerable: true, get: function() {
      return defaultvalueproducer_1.DefaultValueProducer;
    } });
    var dropduplicates_1 = require_dropduplicates();
    Object.defineProperty(exports$1, "dropDuplicates", { enumerable: true, get: function() {
      return dropduplicates_1.dropDuplicates;
    } });
    var promise_1 = require_promise();
    Object.defineProperty(exports$1, "firstEvent", { enumerable: true, get: function() {
      return promise_1.firstEvent;
    } });
    Object.defineProperty(exports$1, "fromListPromise", { enumerable: true, get: function() {
      return promise_1.fromListPromise;
    } });
    Object.defineProperty(exports$1, "toListPromise", { enumerable: true, get: function() {
      return promise_1.toListPromise;
    } });
    __exportStar(require_reducer(), exports$1);
    var valueandupdates_1 = require_valueandupdates();
    Object.defineProperty(exports$1, "ValueAndUpdates", { enumerable: true, get: function() {
      return valueandupdates_1.ValueAndUpdates;
    } });
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/types.js
var require_types5 = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/types.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.jsonRpcCode = void 0;
    exports$1.isJsonRpcErrorResponse = isJsonRpcErrorResponse;
    exports$1.isJsonRpcSuccessResponse = isJsonRpcSuccessResponse;
    function isJsonRpcErrorResponse(response) {
      return typeof response.error === "object";
    }
    function isJsonRpcSuccessResponse(response) {
      return !isJsonRpcErrorResponse(response);
    }
    exports$1.jsonRpcCode = {
      parseError: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internalError: -32603,
      // server error (Reserved for implementation-defined server-errors.):
      // -32000 to -32099
      serverError: {
        default: -32e3
      }
    };
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js
var require_jsonrpcclient = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.JsonRpcClient = void 0;
    var stream_1 = require_build7();
    var types_1 = require_types5();
    var JsonRpcClient = class {
      connection;
      constructor(connection) {
        this.connection = connection;
      }
      async run(request) {
        const filteredStream = this.connection.responseStream.filter((r) => r.id === request.id);
        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);
        this.connection.sendRequest(request);
        const response = await pendingResponses;
        if ((0, types_1.isJsonRpcErrorResponse)(response)) {
          const error = response.error;
          throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);
        }
        return response;
      }
    };
    exports$1.JsonRpcClient = JsonRpcClient;
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/compatibility.js
var require_compatibility = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/compatibility.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isJsonCompatibleValue = isJsonCompatibleValue;
    exports$1.isJsonCompatibleArray = isJsonCompatibleArray;
    exports$1.isJsonCompatibleDictionary = isJsonCompatibleDictionary;
    function isJsonCompatibleValue(value) {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleArray(value) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleDictionary(value)) {
        return true;
      } else {
        return false;
      }
    }
    function isJsonCompatibleArray(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (const item of value) {
        if (!isJsonCompatibleValue(item)) {
          return false;
        }
      }
      return true;
    }
    function isJsonCompatibleDictionary(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      return Object.values(value).every(isJsonCompatibleValue);
    }
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/parse.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.parseJsonRpcId = parseJsonRpcId;
    exports$1.parseJsonRpcRequest = parseJsonRpcRequest;
    exports$1.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;
    exports$1.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;
    exports$1.parseJsonRpcResponse = parseJsonRpcResponse;
    var compatibility_1 = require_compatibility();
    function parseJsonRpcId(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      const id = data2.id;
      if (typeof id !== "number" && typeof id !== "string") {
        return null;
      }
      return id;
    }
    function parseJsonRpcRequest(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (typeof data2.jsonrpc !== "string") {
        throw new Error(`Invalid "jsonrpc" field. Must be a string.`);
      }
      if (data2.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${data2.jsonrpc}`);
      }
      const id = parseJsonRpcId(data2);
      if (id === null) {
        throw new Error("Invalid id field");
      }
      const method = data2.method;
      if (typeof method !== "string") {
        throw new Error(`Invalid "method" field. Must be a string.`);
      }
      if (!(0, compatibility_1.isJsonCompatibleArray)(data2.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data2.params)) {
        throw new Error("Invalid params field");
      }
      return {
        jsonrpc: "2.0",
        id,
        method,
        params: data2.params
      };
    }
    function parseError(error) {
      if (typeof error.code !== "number") {
        throw new Error("Error property 'code' is not a number");
      }
      if (typeof error.message !== "string") {
        throw new Error("Error property 'message' is not a string");
      }
      let maybeUndefinedData;
      if (error.data === void 0) {
        maybeUndefinedData = void 0;
      } else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {
        maybeUndefinedData = error.data;
      } else {
        throw new Error("Error property 'data' is defined but not a JSON compatible value.");
      }
      return {
        code: error.code,
        message: error.message,
        ...maybeUndefinedData !== void 0 ? { data: maybeUndefinedData } : {}
      };
    }
    function parseJsonRpcErrorResponse(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data2.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data2)}`);
      }
      const id = data2.id;
      if (typeof id !== "number" && typeof id !== "string" && id !== null) {
        throw new Error("Invalid id field");
      }
      if (typeof data2.error === "undefined" || !(0, compatibility_1.isJsonCompatibleDictionary)(data2.error)) {
        throw new Error("Invalid error field");
      }
      return {
        jsonrpc: "2.0",
        id,
        error: parseError(data2.error)
      };
    }
    function parseJsonRpcSuccessResponse(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data2.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data2)}`);
      }
      const id = data2.id;
      if (typeof id !== "number" && typeof id !== "string") {
        throw new Error("Invalid id field");
      }
      if (typeof data2.result === "undefined") {
        throw new Error("Invalid result field");
      }
      const result2 = data2.result;
      return {
        jsonrpc: "2.0",
        id,
        result: result2
      };
    }
    function parseJsonRpcResponse(data2) {
      let response;
      try {
        response = parseJsonRpcErrorResponse(data2);
      } catch (_) {
        response = parseJsonRpcSuccessResponse(data2);
      }
      return response;
    }
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/index.js
var require_build8 = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.jsonRpcCode = exports$1.isJsonRpcSuccessResponse = exports$1.isJsonRpcErrorResponse = exports$1.parseJsonRpcSuccessResponse = exports$1.parseJsonRpcResponse = exports$1.parseJsonRpcRequest = exports$1.parseJsonRpcId = exports$1.parseJsonRpcErrorResponse = exports$1.JsonRpcClient = exports$1.makeJsonRpcId = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports$1, "makeJsonRpcId", { enumerable: true, get: function() {
      return id_1.makeJsonRpcId;
    } });
    var jsonrpcclient_1 = require_jsonrpcclient();
    Object.defineProperty(exports$1, "JsonRpcClient", { enumerable: true, get: function() {
      return jsonrpcclient_1.JsonRpcClient;
    } });
    var parse_1 = require_parse2();
    Object.defineProperty(exports$1, "parseJsonRpcErrorResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports$1, "parseJsonRpcId", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcId;
    } });
    Object.defineProperty(exports$1, "parseJsonRpcRequest", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcRequest;
    } });
    Object.defineProperty(exports$1, "parseJsonRpcResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcResponse;
    } });
    Object.defineProperty(exports$1, "parseJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcSuccessResponse;
    } });
    var types_1 = require_types5();
    Object.defineProperty(exports$1, "isJsonRpcErrorResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports$1, "isJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcSuccessResponse;
    } });
    Object.defineProperty(exports$1, "jsonRpcCode", { enumerable: true, get: function() {
      return types_1.jsonRpcCode;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js
var require_http = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.http = http;
    function filterBadStatus(res) {
      if (res.status >= 400) {
        throw new Error(`Bad status on response: ${res.status}`);
      }
      return res;
    }
    async function http(method, url, headers, request, timeout) {
      const settings = {
        method,
        body: request ? JSON.stringify(request) : void 0,
        headers: {
          "Content-Type": "application/json",
          ...headers
        },
        signal: timeout ? AbortSignal.timeout(timeout) : void 0
      };
      return fetch(url, settings).then(filterBadStatus).then((res) => res.json());
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js
var require_rpcclient = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
    exports$1.hasProtocol = hasProtocol;
    function instanceOfRpcStreamingClient(client) {
      return typeof client.listen === "function";
    }
    function hasProtocol(url) {
      return url.search("://") !== -1;
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js
var require_httpbatchclient = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.HttpBatchClient = void 0;
    var json_rpc_1 = require_build8();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var defaultHttpBatchClientOptions = {
      dispatchInterval: 20,
      batchSizeLimit: 20
    };
    var HttpBatchClient = class {
      url;
      headers;
      options;
      timer;
      queue = [];
      constructor(endpoint, options = {}) {
        this.options = {
          batchSizeLimit: options.batchSizeLimit ?? defaultHttpBatchClientOptions.batchSizeLimit,
          dispatchInterval: options.dispatchInterval ?? defaultHttpBatchClientOptions.dispatchInterval,
          httpTimeout: options.httpTimeout
        };
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timer = setInterval(() => {
          this.tick();
        }, options.dispatchInterval);
        this.validate();
      }
      disconnect() {
        if (this.timer)
          clearInterval(this.timer);
        this.timer = void 0;
      }
      async execute(request) {
        return new Promise((resolve, reject) => {
          this.queue.push({ request, resolve, reject });
          if (this.queue.length >= this.options.batchSizeLimit) {
            this.tick();
          }
        });
      }
      validate() {
        if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) {
          throw new Error("batchSizeLimit must be a safe integer >= 1");
        }
      }
      /**
       * This is called in an interval where promise rejections cannot be handled.
       * So this is not async and HTTP errors need to be handled by the queued promises.
       */
      tick() {
        const batch = this.queue.splice(0, this.options.batchSizeLimit);
        if (!batch.length)
          return;
        const requests = batch.map((s) => s.request);
        const requestIds = requests.map((request) => request.id);
        (0, http_1.http)("POST", this.url, this.headers, requests, this.options.httpTimeout).then((raw) => {
          const arr = Array.isArray(raw) ? raw : [raw];
          arr.forEach((el) => {
            const req = batch.find((s) => s.request.id === el.id);
            if (!req)
              return;
            const { reject, resolve } = req;
            const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              reject(new Error(JSON.stringify(response.error)));
            } else {
              resolve(response);
            }
          });
        }, (error) => {
          for (const requestId of requestIds) {
            const req = batch.find((s) => s.request.id === requestId);
            if (!req)
              return;
            req.reject(error);
          }
        });
      }
    };
    exports$1.HttpBatchClient = HttpBatchClient;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js
var require_httpclient = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.HttpClient = void 0;
    var json_rpc_1 = require_build8();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var HttpClient = class {
      url;
      headers;
      timeout;
      constructor(endpoint, timeout) {
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timeout = timeout;
      }
      disconnect() {
      }
      async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await (0, http_1.http)("POST", this.url, this.headers, request, this.timeout));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
    };
    exports$1.HttpClient = HttpClient;
  }
});

// ../../node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/ws/lib/constants.js"(exports$1, module) {
    module.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: /* @__PURE__ */ Symbol("status-code"),
      kWebSocket: /* @__PURE__ */ Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../../node_modules/ws/lib/buffer-util.js"(exports$1, module) {
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data2) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data2)) return data2;
      let buf;
      if (data2 instanceof ArrayBuffer) {
        buf = Buffer.from(data2);
      } else if (ArrayBuffer.isView(data2)) {
        buf = Buffer.from(data2.buffer, data2.byteOffset, data2.byteLength);
      } else {
        buf = Buffer.from(data2);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = __require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// ../../node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../../node_modules/ws/lib/limiter.js"(exports$1, module) {
    var kDone = /* @__PURE__ */ Symbol("kDone");
    var kRun = /* @__PURE__ */ Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module.exports = Limiter;
  }
});

// ../../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../node_modules/ws/lib/permessage-deflate.js"(exports$1, module) {
    var zlib = __require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = /* @__PURE__ */ Symbol("permessage-deflate");
    var kTotalLength = /* @__PURE__ */ Symbol("total-length");
    var kCallback = /* @__PURE__ */ Symbol("callback");
    var kBuffers = /* @__PURE__ */ Symbol("buffers");
    var kError = /* @__PURE__ */ Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data2, fin, (err, result2) => {
            done();
            callback(err, result2);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data2, fin, (err, result2) => {
            done();
            callback(err, result2);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data2, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data2);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data3 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data3);
        });
      }
      /**
       * Compress data.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data2, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data2);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data3 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) data3 = data3.slice(0, data3.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data3);
        });
      }
    };
    module.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../../node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../../node_modules/ws/lib/validation.js"(exports$1, module) {
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = __require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// ../../node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/ws/lib/receiver.js"(exports$1, module) {
    var { Writable } = __require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {String} [binaryType=nodebuffer] The type for binary data
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Boolean} [isServer=false] Specifies whether to operate in client or
       *     server mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data2 = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data2 = this.consume(this._payloadLength);
          if (this._masked) unmask(data2, this._mask);
        }
        if (this._opcode > 7) return this.controlMessage(data2);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data2, cb);
          return;
        }
        if (data2.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data2);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data2, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data2, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er) return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data2;
            if (this._binaryType === "nodebuffer") {
              data2 = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data2 = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data2 = fragments;
            }
            this.emit("message", data2);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data2) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data2.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data2.length === 1) {
            return error(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code = data2.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = data2.slice(2);
            if (!isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data2);
        } else {
          this.emit("pong", data2);
        }
        this._state = GET_INFO;
      }
    };
    module.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// ../../node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../../node_modules/ws/lib/sender.js"(exports$1, module) {
    __require("net");
    __require("tls");
    var { randomFillSync } = __require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       */
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {Buffer} data The data to frame
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {Buffer[]} The framed data as a list of `Buffer` instances
       * @public
       */
      static frame(data2, options) {
        const merge2 = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data2.length;
        if (data2.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data2.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge2 ? data2.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data2.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data2.length, 6);
        }
        if (!options.mask) return [target, data2];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge2) {
          applyMask(data2, mask, target, offset, data2.length);
          return [target];
        }
        applyMask(data2, mask, data2, 0, data2.length);
        return [target, data2];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {String} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data2, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data2 === void 0 || data2 === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data2);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data2, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      /**
       * Frames and sends a close message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @private
       */
      doClose(data2, mask2, cb) {
        this.sendFrame(
          _Sender.frame(data2, {
            fin: true,
            rsv1: false,
            opcode: 8,
            mask: mask2,
            readOnly: false
          }),
          cb
        );
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data2, mask2, cb) {
        const buf = toBuffer(data2);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a ping message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPing(data2, mask2, readOnly, cb) {
        this.sendFrame(
          _Sender.frame(data2, {
            fin: true,
            rsv1: false,
            opcode: 9,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data2, mask2, cb) {
        const buf = toBuffer(data2);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a pong message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPong(data2, mask2, readOnly, cb) {
        this.sendFrame(
          _Sender.frame(data2, {
            fin: true,
            rsv1: false,
            opcode: 10,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data2, options, cb) {
        const buf = toBuffer(data2);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(buf, {
              fin: options.fin,
              rsv1: false,
              opcode,
              mask: options.mask,
              readOnly: toBuffer.readOnly
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a data message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data2, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data2, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data2.length;
        this._deflating = true;
        perMessageDeflate.compress(data2, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function") cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function") callback(err);
            }
            return;
          }
          this._bufferedBytes -= data2.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module.exports = Sender;
  }
});

// ../../node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../../node_modules/ws/lib/event-target.js"(exports$1, module) {
    var Event3 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @param {Object} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(type2, target) {
        this.target = target;
        this.type = type2;
      }
    };
    var MessageEvent = class extends Event3 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(data2, target) {
        super("message", target);
        this.data = data2;
      }
    };
    var CloseEvent = class extends Event3 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {Number} code The status code explaining why the connection is being
       *     closed
       * @param {String} reason A human-readable string explaining why the
       *     connection is closing
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event3 {
      /**
       * Create a new `OpenEvent`.
       *
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event3 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {Object} error The error that generated this event
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {Function} listener The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type2, listener, options) {
        if (typeof listener !== "function") return;
        function onMessage(data2) {
          listener.call(this, new MessageEvent(data2, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options && options.once ? "once" : "on";
        if (type2 === "message") {
          onMessage._listener = listener;
          this[method](type2, onMessage);
        } else if (type2 === "close") {
          onClose._listener = listener;
          this[method](type2, onClose);
        } else if (type2 === "error") {
          onError._listener = listener;
          this[method](type2, onError);
        } else if (type2 === "open") {
          onOpen._listener = listener;
          this[method](type2, onOpen);
        } else {
          this[method](type2, listener);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {Function} listener The listener to remove
       * @public
       */
      removeEventListener(type2, listener) {
        const listeners = this.listeners(type2);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type2, listeners[i]);
          }
        }
      }
    };
    module.exports = EventTarget;
  }
});

// ../../node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../../node_modules/ws/lib/extension.js"(exports$1, module) {
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function push(dest, name2, elem) {
      if (dest[name2] === void 0) dest[name2] = [elem];
      else dest[name2].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      if (header === void 0 || header === "") return offers;
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name2 = header.slice(start, end);
            if (code === 44) {
              push(offers, name2, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name2;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module.exports = { format, parse };
  }
});

// ../../node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/ws/lib/websocket.js"(exports$1, module) {
    var EventEmitter2 = __require("events");
    var https = __require("https");
    var http = __require("http");
    var net = __require("net");
    var tls = __require("tls");
    var { randomBytes, createHash } = __require("crypto");
    var { Readable } = __require("stream");
    var { URL } = __require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var { addEventListener, removeEventListener } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class _WebSocket extends EventEmitter2 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type2) {
        if (!BINARY_TYPES.includes(type2)) return;
        this._binaryType = type2;
        if (this._receiver) this._receiver._binaryType = type2;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return void 0;
      }
      /* istanbul ignore next */
      set onclose(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return void 0;
      }
      /* istanbul ignore next */
      set onerror(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return void 0;
      }
      /* istanbul ignore next */
      set onopen(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return void 0;
      }
      /* istanbul ignore next */
      set onmessage(listener) {
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Number} [maxPayload=0] The maximum allowed message size
       * @private
       */
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(
          this.binaryType,
          this._extensions,
          this._isServer,
          maxPayload
        );
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {String} [data] A string explaining why the connection is closing
       * @public
       */
      close(code, data2) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data2, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data2, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data2 === "number") data2 = data2.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data2 || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data2, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data2 === "number") data2 = data2.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data2 || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data2, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data2 === "number") data2 = data2.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        const opts = {
          binary: typeof data2 !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data2 || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener) return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener) this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        const err = new Error(`Invalid URL: ${websocket.url}`);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalUnixSocket = isUnixSocket;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else {
          const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL(location, address);
          } catch (err) {
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data2, cb) {
      if (data2) {
        const length = toBuffer(data2).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data2) {
      this[kWebSocket].emit("message", data2);
    }
    function receiverOnPing(data2) {
      const websocket = this[kWebSocket];
      websocket.pong(data2, !websocket._isServer, NOOP);
      websocket.emit("ping", data2);
    }
    function receiverOnPong(data2) {
      this[kWebSocket].emit("pong", data2);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../../node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/ws/lib/stream.js"(exports$1, module) {
    var { Duplex } = __require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain) ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain) ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module.exports = createWebSocketStream;
  }
});

// ../../node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../../node_modules/ws/lib/websocket-server.js"(exports$1, module) {
    var EventEmitter2 = __require("events");
    var http = __require("http");
    __require("https");
    __require("net");
    __require("tls");
    var { createHash } = __require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket = require_websocket();
    var { format, parse } = require_extension();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter2 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) this.clients = /* @__PURE__ */ new Set();
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Close the server.
       *
       * @param {Function} [cb] Callback
       * @public
       */
      close(cb) {
        if (cb) this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client of this.clients) client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || upgrade === void 0 || upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Object} extensions The accepted extensions
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module.exports = WebSocketServer;
    function addListeners(server, map2) {
      for (const event of Object.keys(map2)) server.on(event, map2[event]);
      return function removeListeners() {
        for (const event of Object.keys(map2)) {
          server.removeListener(event, map2[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(
          `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str2) {
      return str2.trim();
    }
  }
});

// ../../node_modules/ws/index.js
var require_ws = __commonJS({
  "../../node_modules/ws/index.js"(exports$1, module) {
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module.exports = WebSocket;
  }
});

// ../../node_modules/isomorphic-ws/node.js
var require_node = __commonJS({
  "../../node_modules/isomorphic-ws/node.js"(exports$1, module) {
    module.exports = require_ws();
  }
});

// ../../node_modules/@cosmjs/socket/build/socketwrapper.js
var require_socketwrapper = __commonJS({
  "../../node_modules/@cosmjs/socket/build/socketwrapper.js"(exports$1) {
    var __importDefault = exports$1 && exports$1.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SocketWrapper = void 0;
    var isomorphic_ws_1 = __importDefault(require_node());
    function environmentIsNodeJs() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    var SocketWrapper = class {
      connected;
      connectedResolver;
      connectedRejecter;
      socket;
      timeoutId;
      closed = false;
      url;
      messageHandler;
      errorHandler;
      openHandler;
      closeHandler;
      timeout;
      constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 1e4) {
        this.connected = new Promise((resolve, reject) => {
          this.connectedResolver = resolve;
          this.connectedRejecter = reject;
        });
        this.url = url;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.openHandler = openHandler;
        this.closeHandler = closeHandler;
        this.timeout = timeout;
      }
      /**
       * returns a promise that resolves when connection is open
       */
      connect() {
        const socket = new isomorphic_ws_1.default(this.url);
        socket.onerror = (error) => {
          this.clearTimeout();
          if (this.errorHandler) {
            this.errorHandler(error);
          }
        };
        socket.onmessage = (messageEvent) => {
          this.messageHandler({
            type: messageEvent.type,
            data: messageEvent.data
          });
        };
        socket.onopen = (_) => {
          this.clearTimeout();
          this.connectedResolver();
          if (this.openHandler) {
            this.openHandler();
          }
        };
        socket.onclose = (closeEvent) => {
          this.closed = true;
          if (this.closeHandler) {
            this.closeHandler(closeEvent);
          }
        };
        const started = Date.now();
        this.timeoutId = setTimeout(() => {
          socket.onmessage = () => 0;
          socket.onerror = () => 0;
          socket.onopen = () => 0;
          socket.onclose = () => 0;
          socket.close();
          this.socket = void 0;
          const elapsed = Math.floor(Date.now() - started);
          this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);
        }, this.timeout);
        this.socket = socket;
      }
      /**
       * Closes an established connection and aborts other connection states
       */
      disconnect() {
        if (!this.socket) {
          throw new Error("Socket undefined. This must be called after connecting.");
        }
        this.clearTimeout();
        switch (this.socket.readyState) {
          case isomorphic_ws_1.default.OPEN:
            this.socket.close(
              1e3
              /* Normal Closure */
            );
            break;
          case isomorphic_ws_1.default.CLOSED:
            break;
          case isomorphic_ws_1.default.CONNECTING:
            this.socket.onopen = () => 0;
            this.socket.onclose = () => 0;
            this.socket.onerror = () => 0;
            this.socket.onmessage = () => 0;
            this.socket = void 0;
            if (this.closeHandler) {
              this.closeHandler({ wasClean: false, code: 4001 });
            }
            break;
          case isomorphic_ws_1.default.CLOSING:
            break;
          default:
            throw new Error(`Unknown readyState: ${this.socket.readyState}`);
        }
      }
      async send(data2) {
        return new Promise((resolve, reject) => {
          if (!this.socket) {
            throw new Error("Socket undefined. This must be called after connecting.");
          }
          if (this.closed) {
            throw new Error("Socket was closed, so no data can be sent anymore.");
          }
          if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error("Websocket is not open");
          }
          if (environmentIsNodeJs()) {
            this.socket.send(data2, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
          } else {
            this.socket.send(data2);
            resolve();
          }
        });
      }
      /**
       * Clears the timeout function, such that no timeout error will be raised anymore. This should be
       * called when the connection is established, a connection error occurred or the socket is disconnected.
       *
       * This method must not be called before `connect()`.
       * This method is idempotent.
       */
      clearTimeout() {
        if (!this.timeoutId) {
          throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
        }
        clearTimeout(this.timeoutId);
      }
    };
    exports$1.SocketWrapper = SocketWrapper;
  }
});

// ../../node_modules/@cosmjs/socket/build/streamingsocket.js
var require_streamingsocket = __commonJS({
  "../../node_modules/@cosmjs/socket/build/streamingsocket.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.StreamingSocket = void 0;
    var xstream_1 = require_xstream();
    var socketwrapper_1 = require_socketwrapper();
    var StreamingSocket = class {
      connected;
      events;
      eventProducerListener;
      socket;
      constructor(url, timeout = 1e4) {
        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.next(event);
          }
        }, (errorEvent) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.error(errorEvent);
          }
        }, () => {
        }, (closeEvent) => {
          if (this.eventProducerListener) {
            if (closeEvent.wasClean) {
              this.eventProducerListener.complete();
            } else {
              this.eventProducerListener.error("Socket was closed unclean");
            }
          }
        }, timeout);
        this.connected = this.socket.connected;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
      }
      connect() {
        this.socket.connect();
      }
      disconnect() {
        this.socket.disconnect();
      }
      async send(data2) {
        return this.socket.send(data2);
      }
    };
    exports$1.StreamingSocket = StreamingSocket;
  }
});

// ../../node_modules/@cosmjs/socket/build/queueingstreamingsocket.js
var require_queueingstreamingsocket = __commonJS({
  "../../node_modules/@cosmjs/socket/build/queueingstreamingsocket.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.QueueingStreamingSocket = exports$1.ConnectionStatus = void 0;
    var stream_1 = require_build7();
    var xstream_1 = require_xstream();
    var streamingsocket_1 = require_streamingsocket();
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2[ConnectionStatus2["Unconnected"] = 0] = "Unconnected";
      ConnectionStatus2[ConnectionStatus2["Connecting"] = 1] = "Connecting";
      ConnectionStatus2[ConnectionStatus2["Connected"] = 2] = "Connected";
      ConnectionStatus2[ConnectionStatus2["Disconnected"] = 3] = "Disconnected";
    })(ConnectionStatus || (exports$1.ConnectionStatus = ConnectionStatus = {}));
    var QueueingStreamingSocket = class {
      connectionStatus;
      events;
      url;
      timeout;
      queue = [];
      socket;
      isProcessingQueue = false;
      eventProducerListener;
      connectionStatusProducer;
      reconnectedHandler;
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.url = url;
        this.timeout = timeout;
        this.reconnectedHandler = reconnectedHandler;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);
        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => {
            this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
          }
        });
      }
      connect() {
        this.connectionStatusProducer.update(ConnectionStatus.Connecting);
        this.socket.connected.then(async () => {
          this.connectionStatusProducer.update(ConnectionStatus.Connected);
          return this.processQueue();
        }, () => {
          this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        });
        this.socket.connect();
      }
      disconnect() {
        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        this.socket.disconnect();
      }
      reconnect() {
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => {
            this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
          }
        });
        this.socket.connected.then(() => {
          if (this.reconnectedHandler) {
            this.reconnectedHandler();
          }
        });
        this.connect();
      }
      getQueueLength() {
        return this.queue.length;
      }
      queueRequest(request) {
        this.queue.push(request);
        this.processQueue();
      }
      async processQueue() {
        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {
          return;
        }
        this.isProcessingQueue = true;
        let request;
        while (request = this.queue.shift()) {
          try {
            await this.socket.send(request);
            this.isProcessingQueue = false;
          } catch (_error) {
            this.queue.unshift(request);
            this.isProcessingQueue = false;
            return;
          }
        }
      }
    };
    exports$1.QueueingStreamingSocket = QueueingStreamingSocket;
  }
});

// ../../node_modules/@cosmjs/socket/build/reconnectingsocket.js
var require_reconnectingsocket = __commonJS({
  "../../node_modules/@cosmjs/socket/build/reconnectingsocket.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ReconnectingSocket = void 0;
    var xstream_1 = require_xstream();
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    var ReconnectingSocket = class _ReconnectingSocket {
      /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
      static calculateTimeout(index) {
        return Math.min(2 ** index * 100, 5e3);
      }
      connectionStatus;
      events;
      socket;
      eventProducerListener;
      unconnected = true;
      disconnected = false;
      timeoutIndex = 0;
      reconnectTimeout = null;
      constructor(url, timeout = 1e4, reconnectedHandler) {
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);
        this.socket.events.subscribe({
          next: (event) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.next(event);
            }
          },
          error: (error) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.error(error);
            }
          }
        });
        this.connectionStatus = this.socket.connectionStatus;
        this.connectionStatus.updates.subscribe({
          next: (status) => {
            if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {
              this.timeoutIndex = 0;
            }
            if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {
              if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
              }
              this.reconnectTimeout = setTimeout(() => {
                this.socket.reconnect();
              }, _ReconnectingSocket.calculateTimeout(this.timeoutIndex++));
            }
          }
        });
      }
      connect() {
        if (!this.unconnected) {
          throw new Error("Cannot connect: socket has already connected");
        }
        this.socket.connect();
        this.unconnected = false;
      }
      disconnect() {
        if (this.unconnected) {
          throw new Error("Cannot disconnect: socket has not yet connected");
        }
        this.socket.disconnect();
        if (this.eventProducerListener) {
          this.eventProducerListener.complete();
        }
        this.disconnected = true;
      }
      queueRequest(request) {
        if (this.disconnected) {
          throw new Error("Cannot queue request: socket has disconnected");
        }
        this.socket.queueRequest(request);
      }
    };
    exports$1.ReconnectingSocket = ReconnectingSocket;
  }
});

// ../../node_modules/@cosmjs/socket/build/index.js
var require_build9 = __commonJS({
  "../../node_modules/@cosmjs/socket/build/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.StreamingSocket = exports$1.SocketWrapper = exports$1.ReconnectingSocket = exports$1.QueueingStreamingSocket = exports$1.ConnectionStatus = void 0;
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    Object.defineProperty(exports$1, "ConnectionStatus", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.ConnectionStatus;
    } });
    Object.defineProperty(exports$1, "QueueingStreamingSocket", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.QueueingStreamingSocket;
    } });
    var reconnectingsocket_1 = require_reconnectingsocket();
    Object.defineProperty(exports$1, "ReconnectingSocket", { enumerable: true, get: function() {
      return reconnectingsocket_1.ReconnectingSocket;
    } });
    var socketwrapper_1 = require_socketwrapper();
    Object.defineProperty(exports$1, "SocketWrapper", { enumerable: true, get: function() {
      return socketwrapper_1.SocketWrapper;
    } });
    var streamingsocket_1 = require_streamingsocket();
    Object.defineProperty(exports$1, "StreamingSocket", { enumerable: true, get: function() {
      return streamingsocket_1.StreamingSocket;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js
var require_websocketclient = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.WebsocketClient = void 0;
    var json_rpc_1 = require_build8();
    var socket_1 = require_build9();
    var stream_1 = require_build7();
    var xstream_1 = require_xstream();
    var rpcclient_1 = require_rpcclient();
    function defaultErrorHandler(error) {
      throw error;
    }
    function toJsonRpcResponse(message) {
      if (message.type !== "message") {
        throw new Error(`Unexpected message type on websocket: ${message.type}`);
      }
      const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
      return jsonRpcEvent;
    }
    var RpcEventProducer = class {
      request;
      socket;
      running = false;
      subscriptions = [];
      constructor(request, socket) {
        this.request = request;
        this.socket = socket;
      }
      /**
       * Implementation of Producer.start
       */
      start(listener) {
        if (this.running) {
          throw Error("Already started. Please stop first before restarting.");
        }
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
      }
      /**
       * Implementation of Producer.stop
       *
       * Called by the stream when the stream's last listener stopped listening
       * or when the producer completed.
       */
      stop() {
        this.running = false;
        const endRequest = { ...this.request, method: "unsubscribe" };
        try {
          this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
          if (error instanceof Error && error.message.match(/socket has disconnected/i)) ; else {
            throw error;
          }
        }
      }
      connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        const idSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            }
            idSubscription.unsubscribe();
          }
        });
        const idEventSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            } else {
              listener.next(response.result);
            }
          }
        });
        const nonResponseSubscription = responseStream.subscribe({
          error: (error) => {
            this.closeSubscriptions();
            listener.error(error);
          },
          complete: () => {
            this.closeSubscriptions();
            listener.complete();
          }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
      }
      closeSubscriptions() {
        for (const subscription of this.subscriptions) {
          subscription.unsubscribe();
        }
        this.subscriptions = [];
      }
    };
    var WebsocketClient = class {
      url;
      socket;
      /** Same events as in socket.events but in the format we need */
      jsonRpcResponseStream;
      // Lazily create streams and use the same stream when listening to the same query twice.
      //
      // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this
      // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!
      subscriptionStreams = /* @__PURE__ */ new Map();
      constructor(baseUrl, onError = defaultErrorHandler) {
        if (!(0, rpcclient_1.hasProtocol)(baseUrl)) {
          throw new Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
        }
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        this.url = baseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
          error: (error) => {
            onError(error);
            errorSubscription.unsubscribe();
          }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
      }
      async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
      listen(request) {
        if (request.method !== "subscribe") {
          throw new Error(`Request method must be "subscribe" to start event listening`);
        }
        const query = request.params.query;
        if (typeof query !== "string") {
          throw new Error("request.params.query must be a string");
        }
        if (!this.subscriptionStreams.has(query)) {
          const producer = new RpcEventProducer(request, this.socket);
          const stream = xstream_1.Stream.create(producer);
          this.subscriptionStreams.set(query, stream);
        }
        return this.subscriptionStreams.get(query).filter((response) => response.query !== void 0);
      }
      /**
       * Resolves as soon as websocket is connected. execute() queues requests automatically,
       * so this should be required for testing purposes only.
       */
      async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
      }
      disconnect() {
        this.socket.disconnect();
      }
      async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === id));
      }
    };
    exports$1.WebsocketClient = WebsocketClient;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js
var require_rpcclients = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.WebsocketClient = exports$1.instanceOfRpcStreamingClient = exports$1.HttpClient = exports$1.HttpBatchClient = void 0;
    var httpbatchclient_1 = require_httpbatchclient();
    Object.defineProperty(exports$1, "HttpBatchClient", { enumerable: true, get: function() {
      return httpbatchclient_1.HttpBatchClient;
    } });
    var httpclient_1 = require_httpclient();
    Object.defineProperty(exports$1, "HttpClient", { enumerable: true, get: function() {
      return httpclient_1.HttpClient;
    } });
    var rpcclient_1 = require_rpcclient();
    Object.defineProperty(exports$1, "instanceOfRpcStreamingClient", { enumerable: true, get: function() {
      return rpcclient_1.instanceOfRpcStreamingClient;
    } });
    var websocketclient_1 = require_websocketclient();
    Object.defineProperty(exports$1, "WebsocketClient", { enumerable: true, get: function() {
      return websocketclient_1.WebsocketClient;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js
var require_encodings = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.assertSet = assertSet;
    exports$1.assertBoolean = assertBoolean;
    exports$1.assertString = assertString;
    exports$1.assertNumber = assertNumber;
    exports$1.assertArray = assertArray;
    exports$1.assertObject = assertObject;
    exports$1.assertNotEmpty = assertNotEmpty;
    exports$1.may = may;
    exports$1.dictionaryToStringMap = dictionaryToStringMap;
    exports$1.encodeString = encodeString;
    exports$1.encodeUvarint = encodeUvarint;
    exports$1.encodeTime = encodeTime;
    exports$1.encodeBytes = encodeBytes;
    exports$1.encodeVersion = encodeVersion;
    exports$1.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be an array");
      }
      return value;
    }
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js
var require_inthelpers = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.apiToSmallInt = apiToSmallInt;
    exports$1.apiToBigInt = apiToBigInt;
    exports$1.smallIntToApi = smallIntToApi;
    var math_1 = require_build();
    var encodings_1 = require_encodings();
    function apiToSmallInt(input) {
      const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
      return asInt.toNumber();
    }
    function apiToBigInt(input) {
      (0, encodings_1.assertString)(input);
      if (!input.match(/^-?[0-9]+$/)) {
        throw new Error("Invalid string format");
      }
      return BigInt(input);
    }
    function smallIntToApi(num) {
      return new math_1.Int53(num).toString();
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js
var require_jsonrpc = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.createJsonRpcRequest = createJsonRpcRequest;
    var numbersWithoutZero = "123456789";
    function randomNumericChar() {
      return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
    }
    function randomId() {
      return parseInt(Array.from({ length: 12 }).map(() => randomNumericChar()).join(""), 10);
    }
    function createJsonRpcRequest(method, params) {
      const paramsCopy = params ? { ...params } : {};
      return {
        jsonrpc: "2.0",
        id: randomId(),
        method,
        params: paramsCopy
      };
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js
var require_encodings2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.assertSet = assertSet;
    exports$1.assertBoolean = assertBoolean;
    exports$1.assertString = assertString;
    exports$1.assertNumber = assertNumber;
    exports$1.assertArray = assertArray;
    exports$1.assertObject = assertObject;
    exports$1.assertNotEmpty = assertNotEmpty;
    exports$1.may = may;
    exports$1.dictionaryToStringMap = dictionaryToStringMap;
    exports$1.encodeString = encodeString;
    exports$1.encodeUvarint = encodeUvarint;
    exports$1.encodeTime = encodeTime;
    exports$1.encodeBytes = encodeBytes;
    exports$1.encodeVersion = encodeVersion;
    exports$1.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be an array");
      }
      return value;
    }
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js
var require_requests = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SubscriptionEventType = exports$1.Method = void 0;
    exports$1.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports$1.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports$1.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js
var require_requests2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings2();
    var requests = __importStar(require_requests());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params15 = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports$1.Params = Params15;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/types.js
var require_types6 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/types.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.BlockIdFlag = void 0;
    var BlockIdFlag;
    (function(BlockIdFlag2) {
      BlockIdFlag2[BlockIdFlag2["Unknown"] = 0] = "Unknown";
      BlockIdFlag2[BlockIdFlag2["Absent"] = 1] = "Absent";
      BlockIdFlag2[BlockIdFlag2["Commit"] = 2] = "Commit";
      BlockIdFlag2[BlockIdFlag2["Nil"] = 3] = "Nil";
      BlockIdFlag2[BlockIdFlag2["Unrecognized"] = -1] = "Unrecognized";
    })(BlockIdFlag || (exports$1.BlockIdFlag = BlockIdFlag = {}));
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.hashTx = hashTx;
    exports$1.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings2();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js
var require_responses = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Responses = void 0;
    exports$1.decodeEvent = decodeEvent;
    exports$1.decodeValidatorUpdate = decodeValidatorUpdate;
    exports$1.decodeCommit = decodeCommit;
    exports$1.decodeValidatorGenesis = decodeValidatorGenesis;
    exports$1.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types6();
    var encodings_1 = require_encodings2();
    var hasher_1 = require_hasher();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, encodings_1.assertString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, encodings_1.assertString)(data2.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, encodings_1.assertObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, encodings_1.assertObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        finalizeBlockEvents: decodeEvents(data2.finalize_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      const txResult = data2.tx_result ? decodeTxData(data2.tx_result) : void 0;
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data2.check_tx)),
        deliverTx: txResult,
        txResult
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: data2.signatures ? (0, encodings_1.assertArray)(data2.signatures).map(decodeCommitSignature) : []
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.power))
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data2.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data2.network),
        version: (0, encodings_1.assertString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, encodings_1.assertString)(data2.channels),
        // can be empty
        moniker: (0, encodings_1.assertNotEmpty)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        txs: (0, encodings_1.assertArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_height)),
        validators: (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total))
      };
    }
    function decodeBlock(data2) {
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, encodings_1.assertArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data2.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        blocks: (0, encodings_1.assertArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports$1.Responses = Responses;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js
var require_adaptor = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Responses = exports$1.Params = void 0;
    var requests_1 = require_requests2();
    Object.defineProperty(exports$1, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses();
    Object.defineProperty(exports$1, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js
var require_comet38client = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Comet38Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor();
    var requests = __importStar(require_requests());
    var Comet38Client = class _Comet38Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Comet38Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Comet38Client(rpcClient);
      }
      client;
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result2 = await this.client.execute(req);
        return decode(result2);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports$1.Comet38Client = Comet38Client;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js
var require_responses2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.VoteType = void 0;
    exports$1.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports$1.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports$1.VoteType = VoteType = {}));
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js
var require_comet38 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.VoteType = exports$1.broadcastTxSyncSuccess = exports$1.broadcastTxCommitSuccess = exports$1.SubscriptionEventType = exports$1.Method = exports$1.Comet38Client = void 0;
    var comet38client_1 = require_comet38client();
    Object.defineProperty(exports$1, "Comet38Client", { enumerable: true, get: function() {
      return comet38client_1.Comet38Client;
    } });
    var requests_1 = require_requests();
    Object.defineProperty(exports$1, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports$1, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses2();
    Object.defineProperty(exports$1, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports$1, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports$1, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js
var require_requests3 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SubscriptionEventType = exports$1.Method = void 0;
    exports$1.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports$1.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports$1.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js
var require_responses3 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.VoteType = void 0;
    exports$1.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports$1.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports$1.VoteType = VoteType = {}));
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js
var require_requests4 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings();
    var requests = __importStar(require_requests3());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params15 = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports$1.Params = Params15;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js
var require_hasher2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.hashTx = hashTx;
    exports$1.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js
var require_responses4 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Responses = void 0;
    exports$1.decodeEvent = decodeEvent;
    exports$1.decodeValidatorUpdate = decodeValidatorUpdate;
    exports$1.decodeValidatorGenesis = decodeValidatorGenesis;
    exports$1.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types6();
    var encodings_1 = require_encodings();
    var hasher_1 = require_hasher2();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, encodings_1.assertString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, encodings_1.assertString)(data2.info ?? "")
      };
    }
    function decodeAttribute(attribute) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(attribute.value ?? ""))
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, encodings_1.assertObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, encodings_1.assertObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        beginBlockEvents: decodeEvents(data2.begin_block_events || []),
        endBlockEvents: decodeEvents(data2.end_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data2.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data2.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: (0, encodings_1.assertArray)(data2.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.power))
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data2.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data2.network),
        version: (0, encodings_1.assertString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, encodings_1.assertNotEmpty)(data2.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        txs: (0, encodings_1.assertArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_height)),
        validators: (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total))
      };
    }
    function decodeBlock(data2) {
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, encodings_1.assertArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data2.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        blocks: (0, encodings_1.assertArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports$1.Responses = Responses;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js
var require_adaptor2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Responses = exports$1.Params = void 0;
    var requests_1 = require_requests4();
    Object.defineProperty(exports$1, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses4();
    Object.defineProperty(exports$1, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js
var require_tendermint34client = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Tendermint34Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor2();
    var requests = __importStar(require_requests3());
    var Tendermint34Client = class _Tendermint34Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Tendermint34Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Tendermint34Client(rpcClient);
      }
      client;
      /**
       * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result2 = await this.client.execute(req);
        return decode(result2);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports$1.Tendermint34Client = Tendermint34Client;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js
var require_tendermint34 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Tendermint34Client = exports$1.VoteType = exports$1.broadcastTxSyncSuccess = exports$1.broadcastTxCommitSuccess = exports$1.SubscriptionEventType = exports$1.Method = void 0;
    var requests_1 = require_requests3();
    Object.defineProperty(exports$1, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports$1, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses3();
    Object.defineProperty(exports$1, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports$1, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports$1, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint34client_1 = require_tendermint34client();
    Object.defineProperty(exports$1, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34client_1.Tendermint34Client;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js
var require_requests5 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SubscriptionEventType = exports$1.Method = void 0;
    exports$1.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports$1.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports$1.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js
var require_responses5 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.VoteType = void 0;
    exports$1.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports$1.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports$1.VoteType = VoteType = {}));
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js
var require_encodings3 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.assertSet = assertSet;
    exports$1.assertBoolean = assertBoolean;
    exports$1.assertString = assertString;
    exports$1.assertNumber = assertNumber;
    exports$1.assertArray = assertArray;
    exports$1.assertObject = assertObject;
    exports$1.assertNotEmpty = assertNotEmpty;
    exports$1.may = may;
    exports$1.dictionaryToStringMap = dictionaryToStringMap;
    exports$1.encodeString = encodeString;
    exports$1.encodeUvarint = encodeUvarint;
    exports$1.encodeTime = encodeTime;
    exports$1.encodeBytes = encodeBytes;
    exports$1.encodeVersion = encodeVersion;
    exports$1.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be an array");
      }
      return value;
    }
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js
var require_requests6 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings3();
    var requests = __importStar(require_requests5());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params15 = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports$1.Params = Params15;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js
var require_hasher3 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.hashTx = hashTx;
    exports$1.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings3();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js
var require_responses6 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Responses = void 0;
    exports$1.decodeEvent = decodeEvent;
    exports$1.decodeValidatorUpdate = decodeValidatorUpdate;
    exports$1.decodeValidatorGenesis = decodeValidatorGenesis;
    exports$1.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types6();
    var encodings_1 = require_encodings3();
    var hasher_1 = require_hasher3();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, encodings_1.assertString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, encodings_1.assertString)(data2.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, encodings_1.assertObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, encodings_1.assertObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        beginBlockEvents: decodeEvents(data2.begin_block_events || []),
        endBlockEvents: decodeEvents(data2.end_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data2.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data2.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: (0, encodings_1.assertArray)(data2.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.power))
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data2.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data2.network),
        version: (0, encodings_1.assertString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, encodings_1.assertString)(data2.channels),
        // can be empty
        moniker: (0, encodings_1.assertNotEmpty)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        txs: (0, encodings_1.assertArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.block_height)),
        validators: (0, encodings_1.assertArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total))
      };
    }
    function decodeBlock(data2) {
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, encodings_1.assertArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data2.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_count)),
        blocks: (0, encodings_1.assertArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports$1.Responses = Responses;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js
var require_adaptor3 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Responses = exports$1.Params = void 0;
    var requests_1 = require_requests6();
    Object.defineProperty(exports$1, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses6();
    Object.defineProperty(exports$1, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js
var require_tendermint37client = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Tendermint37Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor3();
    var requests = __importStar(require_requests5());
    var Tendermint37Client = class _Tendermint37Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Tendermint37Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Tendermint37Client(rpcClient);
      }
      client;
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result2 = await this.client.execute(req);
        return decode(result2);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports$1.Tendermint37Client = Tendermint37Client;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js
var require_tendermint37 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Tendermint37Client = exports$1.VoteType = exports$1.broadcastTxSyncSuccess = exports$1.broadcastTxCommitSuccess = exports$1.SubscriptionEventType = exports$1.Method = void 0;
    var requests_1 = require_requests5();
    Object.defineProperty(exports$1, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports$1, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses5();
    Object.defineProperty(exports$1, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports$1, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports$1, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint37client_1 = require_tendermint37client();
    Object.defineProperty(exports$1, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37client_1.Tendermint37Client;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js
var require_tendermintclient = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isTendermint34Client = isTendermint34Client;
    exports$1.isTendermint37Client = isTendermint37Client;
    exports$1.isComet38Client = isComet38Client;
    exports$1.connectComet = connectComet;
    var comet38_1 = require_comet38();
    var tendermint34_1 = require_tendermint34();
    var tendermint37_1 = require_tendermint37();
    function isTendermint34Client(client) {
      return client instanceof tendermint34_1.Tendermint34Client;
    }
    function isTendermint37Client(client) {
      return client instanceof tendermint37_1.Tendermint37Client;
    }
    function isComet38Client(client) {
      return client instanceof comet38_1.Comet38Client;
    }
    async function connectComet(endpoint) {
      let out;
      const tm37Client = await tendermint37_1.Tendermint37Client.connect(endpoint);
      const version = (await tm37Client.status()).nodeInfo.version;
      if (version.startsWith("0.37.")) {
        out = tm37Client;
      } else if (version.startsWith("0.38.") || version.startsWith("1.0.")) {
        tm37Client.disconnect();
        out = await comet38_1.Comet38Client.connect(endpoint);
      } else {
        tm37Client.disconnect();
        out = await tendermint34_1.Tendermint34Client.connect(endpoint);
      }
      return out;
    }
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/index.js
var require_build10 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/index.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.BlockIdFlag = exports$1.isTendermint37Client = exports$1.isTendermint34Client = exports$1.isComet38Client = exports$1.connectComet = exports$1.Tendermint37Client = exports$1.tendermint37 = exports$1.Tendermint34Client = exports$1.tendermint34 = exports$1.VoteType = exports$1.SubscriptionEventType = exports$1.Method = exports$1.broadcastTxSyncSuccess = exports$1.broadcastTxCommitSuccess = exports$1.WebsocketClient = exports$1.HttpClient = exports$1.HttpBatchClient = exports$1.Comet38Client = exports$1.comet38 = exports$1.toSeconds = exports$1.toRfc3339WithNanoseconds = exports$1.fromSeconds = exports$1.fromRfc3339WithNanoseconds = exports$1.DateTime = exports$1.rawSecp256k1PubkeyToRawAddress = exports$1.rawEd25519PubkeyToRawAddress = exports$1.pubkeyToRawAddress = exports$1.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses2();
    Object.defineProperty(exports$1, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports$1, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports$1, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports$1, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var dates_1 = require_dates();
    Object.defineProperty(exports$1, "DateTime", { enumerable: true, get: function() {
      return dates_1.DateTime;
    } });
    Object.defineProperty(exports$1, "fromRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.fromRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports$1, "fromSeconds", { enumerable: true, get: function() {
      return dates_1.fromSeconds;
    } });
    Object.defineProperty(exports$1, "toRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.toRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports$1, "toSeconds", { enumerable: true, get: function() {
      return dates_1.toSeconds;
    } });
    exports$1.comet38 = __importStar(require_comet38());
    var comet38_1 = require_comet38();
    Object.defineProperty(exports$1, "Comet38Client", { enumerable: true, get: function() {
      return comet38_1.Comet38Client;
    } });
    var rpcclients_1 = require_rpcclients();
    Object.defineProperty(exports$1, "HttpBatchClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpBatchClient;
    } });
    Object.defineProperty(exports$1, "HttpClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpClient;
    } });
    Object.defineProperty(exports$1, "WebsocketClient", { enumerable: true, get: function() {
      return rpcclients_1.WebsocketClient;
    } });
    var tendermint34_1 = require_tendermint34();
    Object.defineProperty(exports$1, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports$1, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports$1, "Method", { enumerable: true, get: function() {
      return tendermint34_1.Method;
    } });
    Object.defineProperty(exports$1, "SubscriptionEventType", { enumerable: true, get: function() {
      return tendermint34_1.SubscriptionEventType;
    } });
    Object.defineProperty(exports$1, "VoteType", { enumerable: true, get: function() {
      return tendermint34_1.VoteType;
    } });
    exports$1.tendermint34 = __importStar(require_tendermint34());
    var tendermint34_2 = require_tendermint34();
    Object.defineProperty(exports$1, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34_2.Tendermint34Client;
    } });
    exports$1.tendermint37 = __importStar(require_tendermint37());
    var tendermint37_1 = require_tendermint37();
    Object.defineProperty(exports$1, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37_1.Tendermint37Client;
    } });
    var tendermintclient_1 = require_tendermintclient();
    Object.defineProperty(exports$1, "connectComet", { enumerable: true, get: function() {
      return tendermintclient_1.connectComet;
    } });
    Object.defineProperty(exports$1, "isComet38Client", { enumerable: true, get: function() {
      return tendermintclient_1.isComet38Client;
    } });
    Object.defineProperty(exports$1, "isTendermint34Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint34Client;
    } });
    Object.defineProperty(exports$1, "isTendermint37Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint37Client;
    } });
    var types_1 = require_types6();
    Object.defineProperty(exports$1, "BlockIdFlag", { enumerable: true, get: function() {
      return types_1.BlockIdFlag;
    } });
  }
});

// ../../node_modules/@cosmjs/stargate/build/stargateclient.js
var require_stargateclient = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/stargateclient.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.StargateClient = exports$1.BroadcastTxError = exports$1.TimeoutError = void 0;
    exports$1.isDeliverTxFailure = isDeliverTxFailure;
    exports$1.isDeliverTxSuccess = isDeliverTxSuccess;
    exports$1.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
    exports$1.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build3();
    var abci_1 = require_abci();
    var accounts_1 = require_accounts();
    var events_1 = require_events();
    var modules_1 = require_modules();
    var queryclient_1 = require_queryclient2();
    var search_1 = require_search();
    var TimeoutError = class extends Error {
      txId;
      constructor(message, txId) {
        super(message);
        this.txId = txId;
      }
    };
    exports$1.TimeoutError = TimeoutError;
    function isDeliverTxFailure(result2) {
      return !!result2.code;
    }
    function isDeliverTxSuccess(result2) {
      return !isDeliverTxFailure(result2);
    }
    function assertIsDeliverTxSuccess(result2) {
      if (isDeliverTxFailure(result2)) {
        throw new Error(`Error when broadcasting tx ${result2.transactionHash} at height ${result2.height}. Code: ${result2.code}; Raw log: ${result2.rawLog}`);
      }
    }
    function assertIsDeliverTxFailure(result2) {
      if (isDeliverTxSuccess(result2)) {
        throw new Error(`Transaction ${result2.transactionHash} did not fail at height ${result2.height}. Code: ${result2.code}; Raw log: ${result2.rawLog}`);
      }
    }
    var BroadcastTxError = class extends Error {
      code;
      codespace;
      log;
      constructor(code, codespace, log) {
        super(`Broadcasting transaction failed with code ${code} (codespace: ${codespace}). Log: ${log}`);
        this.code = code;
        this.codespace = codespace;
        this.log = log;
      }
    };
    exports$1.BroadcastTxError = BroadcastTxError;
    var StargateClient = class _StargateClient {
      cometClient;
      queryClient;
      chainId;
      accountParser;
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `create`.
       */
      static async connect(endpoint, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _StargateClient.create(cometClient, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static create(cometClient, options = {}) {
        return new _StargateClient(cometClient, options);
      }
      constructor(cometClient, options) {
        if (cometClient) {
          this.cometClient = cometClient;
          this.queryClient = queryclient_1.QueryClient.withExtensions(cometClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);
        }
        const { accountParser = accounts_1.accountFromAny } = options;
        this.accountParser = accountParser;
      }
      getCometClient() {
        return this.cometClient;
      }
      forceGetCometClient() {
        if (!this.cometClient) {
          throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        }
        return this.cometClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetCometClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? this.accountParser(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      /**
       * Queries all balances for all denoms that belong to this address.
       *
       * Uses the grpc queries (which iterates over the store internally), and we cannot get
       * proofs from such a method.
       */
      async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
      }
      async getBalanceStaked(address) {
        const allDelegations = [];
        let startAtKey = void 0;
        do {
          const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);
          const loadedDelegations = delegationResponses || [];
          allDelegations.push(...loadedDelegations);
          startAtKey = pagination?.nextKey;
        } while (startAtKey !== void 0 && startAtKey.length !== 0);
        const sumValues = allDelegations.reduce((previousValue, currentValue) => {
          (0, utils_1.assert)(currentValue.balance);
          return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;
        }, null);
        return sumValues;
      }
      async getDelegation(delegatorAddress, validatorAddress) {
        let delegatedAmount;
        try {
          delegatedAmount = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse?.balance;
        } catch (e) {
          if (e.toString().includes("key not found")) ; else {
            throw e;
          }
        }
        return delegatedAmount || null;
      }
      async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
      }
      async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") {
          rawQuery = query;
        } else if ((0, search_1.isSearchTxQueryArray)(query)) {
          rawQuery = query.map((t) => {
            if (typeof t.value === "string")
              return `${t.key}='${t.value}'`;
            else
              return `${t.key}=${t.value}`;
          }).join(" AND ");
        } else {
          throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        }
        return this.txsQuery(rawQuery);
      }
      disconnect() {
        if (this.cometClient)
          this.cometClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result2 = await this.getTx(txId);
          return result2 ? {
            code: result2.code,
            height: result2.height,
            txIndex: result2.txIndex,
            events: result2.events,
            rawLog: result2.rawLog,
            transactionHash: txId,
            msgResponses: result2.msgResponses,
            gasUsed: result2.gasUsed,
            gasWanted: result2.gasWanted
          } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * Broadcasts a signed transaction to the network without monitoring it.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
       * usually needs to check if the transaction was included in a block and was successful.
       *
       * @returns Returns the hash of the transaction
       */
      async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
      }
      async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
          return {
            height: tx.height,
            txIndex: tx.index,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(events_1.fromTendermintEvent),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            msgResponses: txMsgData.msgResponses,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports$1.StargateClient = StargateClient;
  }
});

// ../../node_modules/@cosmjs/stargate/build/signingstargateclient.js
var require_signingstargateclient = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/signingstargateclient.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SigningStargateClient = exports$1.defaultRegistryTypes = void 0;
    exports$1.createDefaultAminoConverters = createDefaultAminoConverters;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build3();
    var coin_1 = require_coin();
    var tx_1 = require_tx4();
    var tx_2 = require_tx13();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx9();
    var aminotypes_1 = require_aminotypes();
    var fee_1 = require_fee();
    var modules_1 = require_modules();
    var stargateclient_1 = require_stargateclient();
    exports$1.defaultRegistryTypes = [
      ["/cosmos.base.v1beta1.Coin", coin_1.Coin],
      ...modules_1.authzTypes,
      ...modules_1.bankTypes,
      ...modules_1.distributionTypes,
      ...modules_1.feegrantTypes,
      ...modules_1.govTypes,
      ...modules_1.groupTypes,
      ...modules_1.stakingTypes,
      ...modules_1.ibcTypes,
      ...modules_1.vestingTypes
    ];
    function createDefaultAminoConverters() {
      return {
        ...(0, modules_1.createAuthzAminoConverters)(),
        ...(0, modules_1.createBankAminoConverters)(),
        ...(0, modules_1.createDistributionAminoConverters)(),
        ...(0, modules_1.createGovAminoConverters)(),
        ...(0, modules_1.createStakingAminoConverters)(),
        ...(0, modules_1.createIbcAminoConverters)(),
        ...(0, modules_1.createFeegrantAminoConverters)(),
        ...(0, modules_1.createVestingAminoConverters)()
      };
    }
    var SigningStargateClient2 = class _SigningStargateClient extends stargateclient_1.StargateClient {
      registry;
      broadcastTimeoutMs;
      broadcastPollIntervalMs;
      signer;
      aminoTypes;
      gasPrice;
      // Starting with Cosmos SDK 0.47, we see many cases in which 1.3 is not enough anymore
      // E.g. https://github.com/cosmos/cosmos-sdk/issues/16020
      defaultGasMultiplier = 1.4;
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `createWithSigner`.
       */
      static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _SigningStargateClient.createWithSigner(cometClient, signer, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static createWithSigner(cometClient, signer, options = {}) {
        return new _SigningStargateClient(cometClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new _SigningStargateClient(void 0, signer, options);
      }
      constructor(cometClient, signer, options) {
        super(cometClient, options);
        const { registry = new proto_signing_1.Registry(exports$1.defaultRegistryTypes), aminoTypes = new aminotypes_1.AminoTypes(createDefaultAminoConverters()) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({
            delegatorAddress,
            validatorAddress
          })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
      }
      /**
       * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
       * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
       * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
       * @see https://github.com/cosmos/cosmjs/issues/1493
       */
      async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1e9) : void 0;
        const transferMsg = {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: tx_4.MsgTransfer.fromPartial({
            sourcePort,
            sourceChannel,
            sender: senderAddress,
            receiver: recipientAddress,
            token: transferAmount,
            timeoutHeight,
            timeoutTimestamp: timeoutTimestampNanoseconds
          })
        };
        return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
      }
      async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      /**
       * This method is useful if you want to send a transaction in broadcast,
       * without waiting for it to be placed inside a block, because for example
       * I would like to receive the hash to later track the transaction with another tool.
       * @returns Returns the hash of the transaction
       */
      async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
      }
      /**
       * Gets account number and sequence from the API, creates a sign doc,
       * creates a single signature and assembles the signed transaction.
       *
       * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
       *
       * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
       * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
       * (See the SigningStargateClient.offline constructor).
       */
      async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
          memo: signed.memo,
          timeoutHeight
        };
        const signedTxBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo,
            timeoutHeight
          }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports$1.SigningStargateClient = SigningStargateClient2;
  }
});

// ../../node_modules/@cosmjs/stargate/build/index.js
var require_build11 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/index.js"(exports$1) {
    var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports$1 && exports$1.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
        }
        __setModuleDefault(result2, mod);
        return result2;
      };
    })();
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.isMsgVoteWeightedEncodeObject = exports$1.isMsgVoteEncodeObject = exports$1.isMsgUndelegateEncodeObject = exports$1.isMsgTransferEncodeObject = exports$1.isMsgSubmitProposalEncodeObject = exports$1.isMsgSendEncodeObject = exports$1.isMsgEditValidatorEncodeObject = exports$1.isMsgDepositEncodeObject = exports$1.isMsgDelegateEncodeObject = exports$1.isMsgCreateValidatorEncodeObject = exports$1.isMsgCancelUnbondingDelegationEncodeObject = exports$1.isMsgBeginRedelegateEncodeObject = exports$1.isAminoMsgWithdrawValidatorCommission = exports$1.isAminoMsgWithdrawDelegatorReward = exports$1.isAminoMsgVoteWeighted = exports$1.isAminoMsgVote = exports$1.isAminoMsgVerifyInvariant = exports$1.isAminoMsgUnjail = exports$1.isAminoMsgUndelegate = exports$1.isAminoMsgTransfer = exports$1.isAminoMsgSubmitProposal = exports$1.isAminoMsgSubmitEvidence = exports$1.isAminoMsgSetWithdrawAddress = exports$1.isAminoMsgSend = exports$1.isAminoMsgMultiSend = exports$1.isAminoMsgFundCommunityPool = exports$1.isAminoMsgEditValidator = exports$1.isAminoMsgDeposit = exports$1.isAminoMsgDelegate = exports$1.isAminoMsgCreateVestingAccount = exports$1.isAminoMsgCreateValidator = exports$1.isAminoMsgBeginRedelegate = exports$1.createVestingAminoConverters = exports$1.createStakingAminoConverters = exports$1.createSlashingAminoConverters = exports$1.createIbcAminoConverters = exports$1.createGroupAminoConverters = exports$1.createGovAminoConverters = exports$1.createFeegrantAminoConverters = exports$1.createEvidenceAminoConverters = exports$1.createDistributionAminoConverters = exports$1.createCrysisAminoConverters = exports$1.createBankAminoConverters = exports$1.createAuthzAminoConverters = exports$1.logs = exports$1.GasPrice = exports$1.calculateFee = exports$1.fromTendermintEvent = exports$1.AminoTypes = exports$1.accountFromAny = void 0;
    exports$1.parseCoins = exports$1.makeCosmoshubPath = exports$1.coins = exports$1.coin = exports$1.TimeoutError = exports$1.StargateClient = exports$1.isDeliverTxSuccess = exports$1.isDeliverTxFailure = exports$1.BroadcastTxError = exports$1.assertIsDeliverTxSuccess = exports$1.assertIsDeliverTxFailure = exports$1.SigningStargateClient = exports$1.defaultRegistryTypes = exports$1.createDefaultAminoConverters = exports$1.isSearchTxQueryArray = exports$1.QueryClient = exports$1.decodeCosmosSdkDecFromProto = exports$1.createProtobufRpcClient = exports$1.createPagination = exports$1.makeMultisignedTxBytes = exports$1.makeMultisignedTx = exports$1.setupTxExtension = exports$1.setupStakingExtension = exports$1.setupSlashingExtension = exports$1.setupMintExtension = exports$1.setupIbcExtension = exports$1.setupGovExtension = exports$1.setupFeegrantExtension = exports$1.setupDistributionExtension = exports$1.setupBankExtension = exports$1.setupAuthzExtension = exports$1.setupAuthExtension = exports$1.isMsgWithdrawDelegatorRewardEncodeObject = void 0;
    var accounts_1 = require_accounts();
    Object.defineProperty(exports$1, "accountFromAny", { enumerable: true, get: function() {
      return accounts_1.accountFromAny;
    } });
    var aminotypes_1 = require_aminotypes();
    Object.defineProperty(exports$1, "AminoTypes", { enumerable: true, get: function() {
      return aminotypes_1.AminoTypes;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports$1, "fromTendermintEvent", { enumerable: true, get: function() {
      return events_1.fromTendermintEvent;
    } });
    var fee_1 = require_fee();
    Object.defineProperty(exports$1, "calculateFee", { enumerable: true, get: function() {
      return fee_1.calculateFee;
    } });
    Object.defineProperty(exports$1, "GasPrice", { enumerable: true, get: function() {
      return fee_1.GasPrice;
    } });
    exports$1.logs = __importStar(require_logs());
    var modules_1 = require_modules();
    Object.defineProperty(exports$1, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return modules_1.createAuthzAminoConverters;
    } });
    Object.defineProperty(exports$1, "createBankAminoConverters", { enumerable: true, get: function() {
      return modules_1.createBankAminoConverters;
    } });
    Object.defineProperty(exports$1, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return modules_1.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports$1, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return modules_1.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports$1, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return modules_1.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports$1, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return modules_1.createFeegrantAminoConverters;
    } });
    Object.defineProperty(exports$1, "createGovAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGovAminoConverters;
    } });
    Object.defineProperty(exports$1, "createGroupAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGroupAminoConverters;
    } });
    Object.defineProperty(exports$1, "createIbcAminoConverters", { enumerable: true, get: function() {
      return modules_1.createIbcAminoConverters;
    } });
    Object.defineProperty(exports$1, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports$1, "createStakingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createStakingAminoConverters;
    } });
    Object.defineProperty(exports$1, "createVestingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createVestingAminoConverters;
    } });
    Object.defineProperty(exports$1, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports$1, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports$1, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateVestingAccount;
    } });
    Object.defineProperty(exports$1, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports$1, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports$1, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports$1, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return modules_1.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports$1, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports$1, "isAminoMsgSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSend;
    } });
    Object.defineProperty(exports$1, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports$1, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitEvidence;
    } });
    Object.defineProperty(exports$1, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports$1, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return modules_1.isAminoMsgTransfer;
    } });
    Object.defineProperty(exports$1, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUndelegate;
    } });
    Object.defineProperty(exports$1, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUnjail;
    } });
    Object.defineProperty(exports$1, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVerifyInvariant;
    } });
    Object.defineProperty(exports$1, "isAminoMsgVote", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVote;
    } });
    Object.defineProperty(exports$1, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVoteWeighted;
    } });
    Object.defineProperty(exports$1, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports$1, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawValidatorCommission;
    } });
    Object.defineProperty(exports$1, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSendEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgTransferEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteWeightedEncodeObject;
    } });
    Object.defineProperty(exports$1, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    Object.defineProperty(exports$1, "setupAuthExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthExtension;
    } });
    Object.defineProperty(exports$1, "setupAuthzExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthzExtension;
    } });
    Object.defineProperty(exports$1, "setupBankExtension", { enumerable: true, get: function() {
      return modules_1.setupBankExtension;
    } });
    Object.defineProperty(exports$1, "setupDistributionExtension", { enumerable: true, get: function() {
      return modules_1.setupDistributionExtension;
    } });
    Object.defineProperty(exports$1, "setupFeegrantExtension", { enumerable: true, get: function() {
      return modules_1.setupFeegrantExtension;
    } });
    Object.defineProperty(exports$1, "setupGovExtension", { enumerable: true, get: function() {
      return modules_1.setupGovExtension;
    } });
    Object.defineProperty(exports$1, "setupIbcExtension", { enumerable: true, get: function() {
      return modules_1.setupIbcExtension;
    } });
    Object.defineProperty(exports$1, "setupMintExtension", { enumerable: true, get: function() {
      return modules_1.setupMintExtension;
    } });
    Object.defineProperty(exports$1, "setupSlashingExtension", { enumerable: true, get: function() {
      return modules_1.setupSlashingExtension;
    } });
    Object.defineProperty(exports$1, "setupStakingExtension", { enumerable: true, get: function() {
      return modules_1.setupStakingExtension;
    } });
    Object.defineProperty(exports$1, "setupTxExtension", { enumerable: true, get: function() {
      return modules_1.setupTxExtension;
    } });
    var multisignature_1 = require_multisignature();
    Object.defineProperty(exports$1, "makeMultisignedTx", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTx;
    } });
    Object.defineProperty(exports$1, "makeMultisignedTxBytes", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTxBytes;
    } });
    var queryclient_1 = require_queryclient2();
    Object.defineProperty(exports$1, "createPagination", { enumerable: true, get: function() {
      return queryclient_1.createPagination;
    } });
    Object.defineProperty(exports$1, "createProtobufRpcClient", { enumerable: true, get: function() {
      return queryclient_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports$1, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return queryclient_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports$1, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var search_1 = require_search();
    Object.defineProperty(exports$1, "isSearchTxQueryArray", { enumerable: true, get: function() {
      return search_1.isSearchTxQueryArray;
    } });
    var signingstargateclient_1 = require_signingstargateclient();
    Object.defineProperty(exports$1, "createDefaultAminoConverters", { enumerable: true, get: function() {
      return signingstargateclient_1.createDefaultAminoConverters;
    } });
    Object.defineProperty(exports$1, "defaultRegistryTypes", { enumerable: true, get: function() {
      return signingstargateclient_1.defaultRegistryTypes;
    } });
    Object.defineProperty(exports$1, "SigningStargateClient", { enumerable: true, get: function() {
      return signingstargateclient_1.SigningStargateClient;
    } });
    var stargateclient_1 = require_stargateclient();
    Object.defineProperty(exports$1, "assertIsDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxFailure;
    } });
    Object.defineProperty(exports$1, "assertIsDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxSuccess;
    } });
    Object.defineProperty(exports$1, "BroadcastTxError", { enumerable: true, get: function() {
      return stargateclient_1.BroadcastTxError;
    } });
    Object.defineProperty(exports$1, "isDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxFailure;
    } });
    Object.defineProperty(exports$1, "isDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxSuccess;
    } });
    Object.defineProperty(exports$1, "StargateClient", { enumerable: true, get: function() {
      return stargateclient_1.StargateClient;
    } });
    Object.defineProperty(exports$1, "TimeoutError", { enumerable: true, get: function() {
      return stargateclient_1.TimeoutError;
    } });
    var proto_signing_1 = require_build6();
    Object.defineProperty(exports$1, "coin", { enumerable: true, get: function() {
      return proto_signing_1.coin;
    } });
    Object.defineProperty(exports$1, "coins", { enumerable: true, get: function() {
      return proto_signing_1.coins;
    } });
    Object.defineProperty(exports$1, "makeCosmoshubPath", { enumerable: true, get: function() {
      return proto_signing_1.makeCosmoshubPath;
    } });
    Object.defineProperty(exports$1, "parseCoins", { enumerable: true, get: function() {
      return proto_signing_1.parseCoins;
    } });
  }
});

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-B5XMI26Q.js
var service_akash_B5XMI26Q_exports = {};
__export(service_akash_B5XMI26Q_exports, {
  ClusterRPC: () => ClusterRPC,
  NodeRPC: () => NodeRPC
});
var NodeRPC, ClusterRPC;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-VMU3LNBA.js
var service_akash_VMU3LNBA_exports = {};
__export(service_akash_VMU3LNBA_exports, {
  LeaseRPC: () => LeaseRPC
});
var LeaseRPC;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/service_akash-CQVYVSHE.js
var service_akash_CQVYVSHE_exports = {};
__export(service_akash_CQVYVSHE_exports, {
  ProviderRPC: () => ProviderRPC
});
var ProviderRPC;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-RIIYZIXM.js
init_chunk_VRE72ZD5();
init_chunk_XIHNXIBW();
init_chunk_5YECXI3P();
init_chunk_5DCYIWCG();
init_chunk_JGBH2EPB();
init_chunk_35BIJBXD();

// ../../node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject3(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result2 = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result2 += string;
  }
  return result2;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject3;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString2(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result2 = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result2[String(alias)] = style;
      });
    });
  }
  return result2;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name2) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
      throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data2) {
    return data2;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema4, name2) {
  var result2 = [];
  schema4[name2].forEach(function(currentType) {
    var newIndex = result2.length;
    result2.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result2[newIndex] = currentType;
  });
  return result2;
}
function compileMap() {
  var result2 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result2.multi[type2.kind].push(type2);
      result2.multi["fallback"].push(type2);
    } else {
      result2[type2.kind][type2.tag] = result2["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result2;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result2 = Object.create(Schema$1.prototype);
  result2.implicit = (this.implicit || []).concat(implicit);
  result2.explicit = (this.explicit || []).concat(explicit);
  result2.compiledImplicit = compileList(result2, "implicit");
  result2.compiledExplicit = compileList(result2, "explicit");
  result2.compiledTypeMap = compileMap(result2.compiledImplicit, result2.compiledExplicit);
  return result2;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data2) {
    return data2 !== null ? data2 : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data2) {
    return data2 !== null ? data2 : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data2) {
    return data2 !== null ? data2 : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data2) {
  if (data2 === null) return true;
  var max = data2.length;
  return max === 1 && data2 === "~" || max === 4 && (data2 === "null" || data2 === "Null" || data2 === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data2) {
  if (data2 === null) return false;
  var max = data2.length;
  return max === 4 && (data2 === "true" || data2 === "True" || data2 === "TRUE") || max === 5 && (data2 === "false" || data2 === "False" || data2 === "FALSE");
}
function constructYamlBoolean(data2) {
  return data2 === "true" || data2 === "True" || data2 === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data2) {
  if (data2 === null) return false;
  var max = data2.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data2[index];
  if (ch === "-" || ch === "+") {
    ch = data2[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data2[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data2[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data2[index];
        if (ch === "_") continue;
        if (!isHexCode(data2.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data2[index];
        if (ch === "_") continue;
        if (!isOctCode(data2.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data2[index];
    if (ch === "_") continue;
    if (!isDecCode(data2.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data2) {
  var value = data2, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data2) {
  if (data2 === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data2) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data2[data2.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data2) {
  var value, sign;
  value = data2.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data2) {
  if (data2 === null) return false;
  if (YAML_DATE_REGEXP.exec(data2) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data2) !== null) return true;
  return false;
}
function constructYamlTimestamp(data2) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data2);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data2);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data2) {
  return data2 === "<<" || data2 === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data2) {
  if (data2 === null) return false;
  var code, idx, bitlen = 0, max = data2.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data2.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data2) {
  var idx, tailbits, input = data2.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result2 = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result2.push(bits >> 16 & 255);
      result2.push(bits >> 8 & 255);
      result2.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result2.push(bits >> 16 & 255);
    result2.push(bits >> 8 & 255);
    result2.push(bits & 255);
  } else if (tailbits === 18) {
    result2.push(bits >> 10 & 255);
    result2.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result2.push(bits >> 4 & 255);
  }
  return new Uint8Array(result2);
}
function representYamlBinary(object) {
  var result2 = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result2 += map2[bits >> 18 & 63];
      result2 += map2[bits >> 12 & 63];
      result2 += map2[bits >> 6 & 63];
      result2 += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result2 += map2[bits >> 18 & 63];
    result2 += map2[bits >> 12 & 63];
    result2 += map2[bits >> 6 & 63];
    result2 += map2[bits & 63];
  } else if (tail === 2) {
    result2 += map2[bits >> 10 & 63];
    result2 += map2[bits >> 4 & 63];
    result2 += map2[bits << 2 & 63];
    result2 += map2[64];
  } else if (tail === 1) {
    result2 += map2[bits >> 2 & 63];
    result2 += map2[bits << 4 & 63];
    result2 += map2[64];
    result2 += map2[64];
  }
  return result2;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data2) {
  if (data2 === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data2;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data2) {
  return data2 !== null ? data2 : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data2) {
  if (data2 === null) return true;
  var index, length, pair, keys, result2, object = data2;
  result2 = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result2[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data2) {
  if (data2 === null) return [];
  var index, length, pair, keys, result2, object = data2;
  result2 = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result2[index] = [keys[0], pair[keys[0]]];
  }
  return result2;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data2) {
  if (data2 === null) return true;
  var key, object = data2;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data2) {
  return data2 !== null ? data2 : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-RIIYZIXM.js
__toESM(require_json_stable_stringify(), 1);
__toESM(require_json_stable_stringify(), 1);

// ../../node_modules/@connectrpc/connect/dist/esm/code.js
var Code;
(function(Code2) {
  Code2[Code2["Canceled"] = 1] = "Canceled";
  Code2[Code2["Unknown"] = 2] = "Unknown";
  Code2[Code2["InvalidArgument"] = 3] = "InvalidArgument";
  Code2[Code2["DeadlineExceeded"] = 4] = "DeadlineExceeded";
  Code2[Code2["NotFound"] = 5] = "NotFound";
  Code2[Code2["AlreadyExists"] = 6] = "AlreadyExists";
  Code2[Code2["PermissionDenied"] = 7] = "PermissionDenied";
  Code2[Code2["ResourceExhausted"] = 8] = "ResourceExhausted";
  Code2[Code2["FailedPrecondition"] = 9] = "FailedPrecondition";
  Code2[Code2["Aborted"] = 10] = "Aborted";
  Code2[Code2["OutOfRange"] = 11] = "OutOfRange";
  Code2[Code2["Unimplemented"] = 12] = "Unimplemented";
  Code2[Code2["Internal"] = 13] = "Internal";
  Code2[Code2["Unavailable"] = 14] = "Unavailable";
  Code2[Code2["DataLoss"] = 15] = "DataLoss";
  Code2[Code2["Unauthenticated"] = 16] = "Unauthenticated";
})(Code || (Code = {}));

// ../../node_modules/@bufbuild/protobuf/dist/esm/index.js
init_is_message();
init_create();
init_descriptors();
init_from_binary();
init_proto_int64();

// ../../node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js
function codeToString(value) {
  const name2 = Code[value];
  if (typeof name2 != "string") {
    return value.toString();
  }
  return name2[0].toLowerCase() + name2.substring(1).replace(/[A-Z]/g, (c) => "_" + c.toLowerCase());
}

// ../../node_modules/@connectrpc/connect/dist/esm/connect-error.js
var ConnectError = class _ConnectError extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(message, code = Code.Unknown, metadata, outgoingDetails, cause) {
    super(createMessage(message, code));
    this.name = "ConnectError";
    Object.setPrototypeOf(this, new.target.prototype);
    this.rawMessage = message;
    this.code = code;
    this.metadata = new Headers(metadata !== null && metadata !== void 0 ? metadata : {});
    this.details = outgoingDetails !== null && outgoingDetails !== void 0 ? outgoingDetails : [];
    this.cause = cause;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(reason, code = Code.Unknown) {
    if (reason instanceof _ConnectError) {
      return reason;
    }
    if (reason instanceof Error) {
      if (reason.name == "AbortError" || reason.name == "TimeoutError") {
        return new _ConnectError(reason.message, Code.Canceled);
      }
      return new _ConnectError(reason.message, code, void 0, void 0, reason);
    }
    return new _ConnectError(String(reason), code, void 0, void 0, reason);
  }
  static [Symbol.hasInstance](v) {
    if (!(v instanceof Error)) {
      return false;
    }
    if (Object.getPrototypeOf(v) === _ConnectError.prototype) {
      return true;
    }
    return v.name === "ConnectError" && "code" in v && typeof v.code === "number" && "metadata" in v && "details" in v && Array.isArray(v.details) && "rawMessage" in v && typeof v.rawMessage == "string" && "cause" in v;
  }
  findDetails(typeOrRegistry) {
    const registry = typeOrRegistry.kind === "message" ? {
      getMessage: (typeName) => typeName === typeOrRegistry.typeName ? typeOrRegistry : void 0
    } : typeOrRegistry;
    const details = [];
    for (const data2 of this.details) {
      if ("desc" in data2) {
        if (registry.getMessage(data2.desc.typeName)) {
          details.push(create(data2.desc, data2.value));
        }
        continue;
      }
      const desc = registry.getMessage(data2.type);
      if (desc) {
        try {
          details.push(fromBinary(desc, data2.value));
        } catch (_) {
        }
      }
    }
    return details;
  }
};
function createMessage(message, code) {
  return message.length ? `[${codeToString(code)}] ${message}` : `[${codeToString(code)}]`;
}

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-RIIYZIXM.js
var import_base64_js = __toESM(require_base64_js(), 1);
var import_json_stable_stringify3 = __toESM(require_json_stable_stringify(), 1);

// ../../node_modules/cockatiel/dist/esm/backoff/ConstantBackoff.js
var ConstantBackoff = class {
  /**
   * Backoff that returns a constant interval.
   */
  constructor(interval) {
    this.interval = interval;
  }
  /**
   * @inheritdoc
   */
  next() {
    return instance(this.interval);
  }
};
var instance = (interval) => ({
  duration: interval,
  next() {
    return this;
  }
});

// ../../node_modules/cockatiel/dist/esm/backoff/ExponentialBackoffGenerators.js
var pFactor = 4;
var rpScalingFactor = 1 / 1.4;
var decorrelatedJitterGenerator = (state, options) => {
  const [attempt, prev] = state || [0, 0];
  const t = attempt + Math.random();
  const next = Math.pow(options.exponent, t) * Math.tanh(Math.sqrt(pFactor * t));
  const formulaIntrinsicValue = isFinite(next) ? Math.max(0, next - prev) : Infinity;
  return [
    Math.min(formulaIntrinsicValue * rpScalingFactor * options.initialDelay, options.maxDelay),
    [attempt + 1, next]
  ];
};

// ../../node_modules/cockatiel/dist/esm/backoff/ExponentialBackoff.js
var defaultOptions = {
  generator: decorrelatedJitterGenerator,
  maxDelay: 3e4,
  exponent: 2,
  initialDelay: 128
};
var ExponentialBackoff = class {
  /**
   * An implementation of exponential backoff.
   */
  constructor(options) {
    this.options = options ? { ...defaultOptions, ...options } : defaultOptions;
  }
  next() {
    return instance2(this.options).next(void 0);
  }
};
var instance2 = (options, state, delay2 = 0, attempt = -1) => ({
  duration: delay2,
  next() {
    const [nextDelay, nextState] = options.generator(state, options);
    return instance2(options, nextState, nextDelay, attempt + 1);
  }
});

// ../../node_modules/cockatiel/dist/esm/errors/TaskCancelledError.js
var TaskCancelledError = class extends Error {
  /**
   * Error thrown when a task is cancelled.
   */
  constructor(message = "Operation cancelled") {
    super(message);
    this.message = message;
    this.isTaskCancelledError = true;
  }
};

// ../../node_modules/cockatiel/dist/esm/common/Event.js
var noopDisposable = { dispose: () => void 0 };
var Event;
(function(Event3) {
  Event3.once = (event, listener) => {
    let syncDispose = false;
    let disposable;
    disposable = event((value) => {
      listener(value);
      if (disposable) {
        disposable.dispose();
      } else {
        syncDispose = true;
      }
    });
    if (syncDispose) {
      disposable.dispose();
      return noopDisposable;
    }
    return disposable;
  };
  Event3.toPromise = (event, signal) => {
    if (!signal) {
      return new Promise((resolve) => Event3.once(event, resolve));
    }
    if (signal.aborted) {
      return Promise.reject(new TaskCancelledError());
    }
    const toDispose = [];
    return new Promise((resolve, reject) => {
      const abortEvt = onAbort(signal);
      toDispose.push(abortEvt);
      toDispose.push(abortEvt.event(() => {
        reject(new TaskCancelledError());
      }));
      toDispose.push(Event3.once(event, (data2) => {
        resolve(data2);
      }));
    }).finally(() => {
      for (const d of toDispose) {
        d.dispose();
      }
    });
  };
})(Event || (Event = {}));
var onAbort = (signal) => {
  const evt = new OneShotEvent();
  if (signal.aborted) {
    evt.emit();
    return { event: evt.addListener, dispose: () => {
    } };
  }
  const dispose = () => signal.removeEventListener("abort", l);
  const l = () => {
    evt.emit();
    dispose();
  };
  signal.addEventListener("abort", l);
  return { event: evt.addListener, dispose };
};
var EventEmitter = class {
  constructor() {
    this.addListener = (listener) => this.addListenerInner(listener);
  }
  /**
   * Gets the number of event listeners.
   */
  get size() {
    if (!this.listeners) {
      return 0;
    } else if (typeof this.listeners === "function") {
      return 1;
    } else {
      return this.listeners.length;
    }
  }
  /**
   * Emits event data.
   */
  emit(value) {
    if (!this.listeners) ; else if (typeof this.listeners === "function") {
      this.listeners(value);
    } else {
      for (const listener of this.listeners) {
        listener(value);
      }
    }
  }
  addListenerInner(listener) {
    if (!this.listeners) {
      this.listeners = listener;
    } else if (typeof this.listeners === "function") {
      this.listeners = [this.listeners, listener];
    } else {
      this.listeners.push(listener);
    }
    return { dispose: () => this.removeListener(listener) };
  }
  removeListener(listener) {
    if (!this.listeners) {
      return;
    }
    if (typeof this.listeners === "function") {
      if (this.listeners === listener) {
        this.listeners = void 0;
      }
      return;
    }
    const index = this.listeners.indexOf(listener);
    if (index === -1) {
      return;
    }
    if (this.listeners.length === 2) {
      this.listeners = index === 0 ? this.listeners[1] : this.listeners[0];
    } else {
      this.listeners = this.listeners.slice(0, index).concat(this.listeners.slice(index + 1));
    }
  }
};
var OneShotEvent = class extends EventEmitter {
  constructor() {
    super(...arguments);
    this.addListener = (listener) => {
      if (this.lastValue) {
        listener(this.lastValue.value);
        return noopDisposable;
      } else {
        return this.addListenerInner(listener);
      }
    };
  }
  /**
   * @inheritdoc
   */
  emit(value) {
    this.lastValue = { value };
    super.emit(value);
    this.listeners = void 0;
  }
};

// ../../node_modules/cockatiel/dist/esm/common/abort.js
var neverAbortedSignal = new AbortController().signal;
var cancelledSrc = new AbortController();
cancelledSrc.abort();
cancelledSrc.signal;

// ../../node_modules/cockatiel/dist/esm/common/Executor.js
var returnOrThrow = (failure) => {
  if ("error" in failure) {
    throw failure.error;
  }
  if ("success" in failure) {
    return failure.success;
  }
  return failure.value;
};
var makeStopwatch = () => {
  if (typeof performance !== "undefined") {
    const start = performance.now();
    return () => performance.now() - start;
  } else {
    const start = process.hrtime.bigint();
    return () => Number(process.hrtime.bigint() - start) / 1e6;
  }
};
var ExecuteWrapper = class _ExecuteWrapper {
  constructor(errorFilter = () => false, resultFilter = () => false) {
    this.errorFilter = errorFilter;
    this.resultFilter = resultFilter;
    this.successEmitter = new EventEmitter();
    this.failureEmitter = new EventEmitter();
    this.onSuccess = this.successEmitter.addListener;
    this.onFailure = this.failureEmitter.addListener;
  }
  clone() {
    return new _ExecuteWrapper(this.errorFilter, this.resultFilter);
  }
  async invoke(fn, ...args) {
    const stopwatch = this.successEmitter.size || this.failureEmitter.size ? makeStopwatch() : null;
    try {
      const value = await fn(...args);
      if (!this.resultFilter(value)) {
        if (stopwatch) {
          this.successEmitter.emit({ duration: stopwatch() });
        }
        return { success: value };
      }
      if (stopwatch) {
        this.failureEmitter.emit({ duration: stopwatch(), handled: true, reason: { value } });
      }
      return { value };
    } catch (rawError) {
      const error = rawError;
      const handled = this.errorFilter(error);
      if (stopwatch) {
        this.failureEmitter.emit({ duration: stopwatch(), handled, reason: { error } });
      }
      if (!handled) {
        throw error;
      }
      return { error };
    }
  }
};

// ../../node_modules/cockatiel/dist/esm/NoopPolicy.js
var NoopPolicy = class {
  constructor() {
    this.executor = new ExecuteWrapper();
    this.onSuccess = this.executor.onSuccess;
    this.onFailure = this.executor.onFailure;
  }
  async execute(fn, signal = neverAbortedSignal) {
    return returnOrThrow(await this.executor.invoke(fn, { signal }));
  }
};

// ../../node_modules/cockatiel/dist/esm/RetryPolicy.js
var delay = (duration, unref) => new Promise((resolve) => {
  const timer = setTimeout(resolve, duration);
  if (unref) {
    timer.unref();
  }
});
var RetryPolicy = class _RetryPolicy {
  constructor(options, executor) {
    this.options = options;
    this.executor = executor;
    this.onGiveUpEmitter = new EventEmitter();
    this.onRetryEmitter = new EventEmitter();
    this.onSuccess = this.executor.onSuccess;
    this.onFailure = this.executor.onFailure;
    this.onRetry = this.onRetryEmitter.addListener;
    this.onGiveUp = this.onGiveUpEmitter.addListener;
  }
  /**
   * When retrying, a referenced timer is created. This means the Node.js event
   * loop is kept active while we're delaying a retried call. Calling this
   * method on the retry builder will unreference the timer, allowing the
   * process to exit even if a retry might still be pending.
   */
  dangerouslyUnref() {
    return new _RetryPolicy({ ...this.options, unref: true }, this.executor.clone());
  }
  /**
   * Executes the given function with retries.
   * @param fn Function to run
   * @returns a Promise that resolves or rejects with the function results.
   */
  async execute(fn, signal = neverAbortedSignal) {
    const factory = this.options.backoff || new ConstantBackoff(0);
    let backoff;
    for (let retries = 0; ; retries++) {
      const result2 = await this.executor.invoke(fn, { attempt: retries, signal });
      if ("success" in result2) {
        return result2.success;
      }
      if (!signal.aborted && retries < this.options.maxAttempts) {
        const context = { attempt: retries + 1, signal, result: result2 };
        backoff = backoff ? backoff.next(context) : factory.next(context);
        const delayDuration = backoff.duration;
        const delayPromise = delay(delayDuration, !!this.options.unref);
        this.onRetryEmitter.emit({ ...result2, delay: delayDuration, attempt: retries + 1 });
        await delayPromise;
        continue;
      }
      this.onGiveUpEmitter.emit(result2);
      if ("error" in result2) {
        throw result2.error;
      }
      return result2.value;
    }
  }
};

// ../../node_modules/cockatiel/dist/esm/Policy.js
var typeFilter = (cls, predicate) => predicate ? (v) => v instanceof cls && predicate(v) : (v) => v instanceof cls;
var never = () => false;
var Policy = class _Policy {
  /**
   * Factory that builds a base set of filters that can be used in circuit
   * breakers, retries, etc.
   */
  constructor(options) {
    this.options = options;
  }
  /**
   * Allows the policy to additionally handles errors of the given type.
   *
   * @param cls Class constructor to check that the error is an instance of.
   * @param predicate If provided, a function to be called with the error
   * which should return "true" if we want to handle this error.
   * @example
   * ```js
   * // retry both network errors and response errors with a 503 status code
   * new Policy()
   *  .orType(NetworkError)
   *  .orType(ResponseError, err => err.statusCode === 503)
   *  .retry()
   *  .attempts(3)
   *  .execute(() => getJsonFrom('https://example.com'));
   * ```
   */
  orType(cls, predicate) {
    const filter = typeFilter(cls, predicate);
    return new _Policy({
      ...this.options,
      errorFilter: (e) => this.options.errorFilter(e) || filter(e)
    });
  }
  /**
   * Allows the policy to additionally handles errors that pass the given
   * predicate function.
   *
   * @param predicate Takes any thrown error, and returns true if it should
   * be retried by this policy.
   * @example
   * ```js
   * // only retry if the error has a "shouldBeRetried" property set
   * new Policy()
   *  .orWhen(err => err.shouldBeRetried === true)
   *  .retry()
   *  .attempts(3)
   *  .execute(() => getJsonFrom('https://example.com'));
   * ```
   */
  orWhen(predicate) {
    return new _Policy({
      ...this.options,
      errorFilter: (e) => this.options.errorFilter(e) || predicate(e)
    });
  }
  /**
   * Adds handling for return values. The predicate will be called with
   * the return value of the executed function,
   *
   * @param predicate Takes the returned value, and returns true if it
   * should be retried by this policy.
   * @example
   * ```js
   * // retry when the response status code is a 5xx
   * new Policy()
   *  .orResultWhen(res => res.statusCode >= 500)
   *  .retry()
   *  .attempts(3)
   *  .execute(() => getJsonFrom('https://example.com'));
   * ```
   */
  orWhenResult(predicate) {
    return new _Policy({
      ...this.options,
      resultFilter: (r) => this.options.resultFilter(r) || predicate(r)
    });
  }
  /**
   * Adds handling for return values. The predicate will be called with
   * the return value of the executed function,
   *
   * @param predicate Takes the returned value, and returns true if it
   * should be retried by this policy.
   * @example
   * ```js
   * // retry when the response status code is a 5xx
   * new Policy()
   *  .orResultType(res => res.statusCode >= 500)
   *  .retry()
   *  .attempts(3)
   *  .execute(() => getJsonFrom('https://example.com'));
   * ```
   */
  orResultType(cls, predicate) {
    const filter = typeFilter(cls, predicate);
    return new _Policy({
      ...this.options,
      resultFilter: (r) => this.options.resultFilter(r) || filter(r)
    });
  }
};
new NoopPolicy();
function handleWhenResult(predicate) {
  return new Policy({ errorFilter: never, resultFilter: predicate });
}
function retry(policy, opts) {
  return new RetryPolicy({ backoff: opts.backoff || new ConstantBackoff(0), maxAttempts: opts.maxAttempts ?? Infinity }, new ExecuteWrapper(policy.options.errorFilter, policy.options.resultFilter));
}
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_ucs2length = __commonJS2({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    function ucs2length(str2) {
      const len = str2.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str2.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str2.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports$1.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});
require_ucs2length().default;
function humanizeErrors(errors, schema32, errorMessages) {
  if (!errors) return [];
  const messages = /* @__PURE__ */ new Map();
  errors.forEach((error) => {
    let getErrorMessage = getDefaultErrorMessage;
    const message = getErrorMessage(error, schema32);
    if (message) messages.set(message, { ...error, message });
  });
  return Array.from(messages.values());
}
function getDefaultErrorMessage(error, schema32) {
  if (error.keyword === "anyOf" || error.keyword === "oneOf") {
    return;
  }
  if (error.keyword === "required") {
    return `Missing required field: "${error.params.missingProperty}"${getErrorLocation(error.instancePath)}.`;
  }
  if (error.keyword === "pattern") {
    return `Invalid format: "${getFieldName(error.instancePath)}"${getErrorLocation(dirname(error.instancePath))} does not match pattern "${error.params.pattern}"`;
  }
  if (error.keyword === "additionalProperties") {
    const patternProperties = getSchemaFieldByPath(`${dirname(error.schemaPath)}/patternProperties`, schema32);
    if (patternProperties) {
      return `Field "${error.params.additionalProperty}"${getErrorLocation(error.instancePath)} doesn't satisfy any of the allowed patterns: ${Object.keys(patternProperties).join(", ")}.`;
    }
    return `Additional property "${error.params.additionalProperty}" is not allowed${getErrorLocation(error.instancePath)}.`;
  }
  if (error.keyword === "type") {
    return `"${getFieldName(error.instancePath)}"${getErrorLocation(dirname(error.instancePath))} should be ${getSchemaFieldByPath(error.schemaPath, schema32)}.`;
  }
  if (error.keyword === "enum") {
    return `"${getFieldName(error.instancePath)}"${getErrorLocation(dirname(error.instancePath))} should be one of: ${error.params.allowedValues.join(", ")}.`;
  }
  if (error.keyword === "minLength") {
    return `"${getFieldName(error.instancePath)}" at "${dirname(error.instancePath)}" must be at least ${getSchemaFieldByPath(error.schemaPath, schema32)} characters long.`;
  }
  if (error.keyword === "maxLength") {
    return `"${getFieldName(error.instancePath)}" at "${dirname(error.instancePath)}" must be at most ${getSchemaFieldByPath(error.schemaPath, schema32)} characters long.`;
  }
  if (error.keyword === "minItems") {
    return `"${getFieldName(error.instancePath)}" at "${dirname(error.instancePath)}" must have at least ${getSchemaFieldByPath(error.schemaPath, schema32)} items.`;
  }
  if (error.keyword === "maxItems") {
    return `"${getFieldName(error.instancePath)}" at "${dirname(error.instancePath)}" must have at most ${getSchemaFieldByPath(error.schemaPath, schema32)} items.`;
  }
  if (error.keyword === "minimum") {
    return `"${getFieldName(error.instancePath)}" at "${dirname(error.instancePath)}" must be at least ${getSchemaFieldByPath(error.schemaPath, schema32)}.`;
  }
  if (error.keyword === "exclusiveMinimum") {
    return `"${getFieldName(error.instancePath)}" at "${dirname(error.instancePath)}" must be greater than ${getSchemaFieldByPath(error.schemaPath, schema32)}.`;
  }
  if (error.keyword === "exclusiveMaximum") {
    return `"${getFieldName(error.instancePath)}" at "${dirname(error.instancePath)}" must be less than ${getSchemaFieldByPath(error.schemaPath, schema32)}.`;
  }
  if (error.keyword === "maximum") {
    return `"${getFieldName(error.instancePath)}" at "${dirname(error.instancePath)}" must be at most ${getSchemaFieldByPath(error.schemaPath, schema32)}.`;
  }
  if (error.keyword === "minProperties") {
    const suffix = error.params.limit === 1 ? "property" : "properties";
    return `"${getFieldName(error.instancePath)}"${getErrorLocation(dirname(error.instancePath))} must have at least ${error.params.limit} ${suffix}.`;
  }
  if (error.keyword === "const") {
    return `"${getFieldName(error.instancePath)}"${getErrorLocation(dirname(error.instancePath))} must be ${error.params.allowedValue}.`;
  }
  return `"${getFieldName(error.instancePath)}"${getErrorLocation(dirname(error.instancePath))} ${error.message}.`;
}
function getFieldName(instanceLocation) {
  return basename(instanceLocation);
}
function basename(path) {
  const lastPartIndex = path.lastIndexOf("/");
  if (lastPartIndex === -1) return path;
  return path.slice(lastPartIndex + 1);
}
function dirname(path) {
  const lastPartIndex = path.lastIndexOf("/");
  if (lastPartIndex === -1) return path;
  return path.slice(0, lastPartIndex);
}
function getSchemaFieldByPath(keywordLocation, schema32) {
  return keywordLocation.split("/").slice(1).reduce((schema4, key) => schema4[key], schema32);
}
function getErrorLocation(path) {
  return path ? ` at "${path}"` : "";
}
new TextEncoder();
new TextDecoder();
new TextEncoder();
var MANIFEST_VERSION_FIELD_MAPPING = { quantity: "size", sequenceNumber: "sequence_number" };
new RegExp(`"(${Object.keys(MANIFEST_VERSION_FIELD_MAPPING).join("|")})":`, "g");
var htmlEscapes = {
  "<": "\\u003c",
  ">": "\\u003e",
  "&": "\\u0026"
};
new RegExp(`[${Object.keys(htmlEscapes).join("")}]`, "g");
var TransportErrorCode = /* @__PURE__ */ ((TransportErrorCode2) => {
  TransportErrorCode2[TransportErrorCode2["Canceled"] = 1] = "Canceled";
  TransportErrorCode2[TransportErrorCode2["Unknown"] = 2] = "Unknown";
  TransportErrorCode2[TransportErrorCode2["InvalidArgument"] = 3] = "InvalidArgument";
  TransportErrorCode2[TransportErrorCode2["DeadlineExceeded"] = 4] = "DeadlineExceeded";
  TransportErrorCode2[TransportErrorCode2["NotFound"] = 5] = "NotFound";
  TransportErrorCode2[TransportErrorCode2["AlreadyExists"] = 6] = "AlreadyExists";
  TransportErrorCode2[TransportErrorCode2["PermissionDenied"] = 7] = "PermissionDenied";
  TransportErrorCode2[TransportErrorCode2["ResourceExhausted"] = 8] = "ResourceExhausted";
  TransportErrorCode2[TransportErrorCode2["FailedPrecondition"] = 9] = "FailedPrecondition";
  TransportErrorCode2[TransportErrorCode2["Aborted"] = 10] = "Aborted";
  TransportErrorCode2[TransportErrorCode2["OutOfRange"] = 11] = "OutOfRange";
  TransportErrorCode2[TransportErrorCode2["Unimplemented"] = 12] = "Unimplemented";
  TransportErrorCode2[TransportErrorCode2["Internal"] = 13] = "Internal";
  TransportErrorCode2[TransportErrorCode2["Unavailable"] = 14] = "Unavailable";
  TransportErrorCode2[TransportErrorCode2["DataLoss"] = 15] = "DataLoss";
  TransportErrorCode2[TransportErrorCode2["Unauthenticated"] = 16] = "Unauthenticated";
  return TransportErrorCode2;
})(TransportErrorCode || {});
var _TransportError = class _TransportError2 extends Error {
  /**
   * Create a new TransportError.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with error.
   */
  constructor(message, code = _TransportError2.Code.Unknown, options) {
    super(`[${stringifyCode(code)}] ${message}`, { cause: options?.cause });
    __publicField(this, "code");
    __publicField(this, "metadata");
    __publicField(this, "cause");
    this.name = "TransportError";
    Object.setPrototypeOf(this, new.target.prototype);
    this.code = code;
    this.metadata = new Headers(options?.metadata ?? {});
    this.cause ?? (this.cause = options?.cause);
  }
  /**
   * Convert any value - typically a caught error into a TransportError,
   * following these rules:
   * - If the value is already a TransportError, return it as is.
   * - If the value is an AbortError from the fetch API, return the message
   *   of the AbortError with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * TransportError.
   */
  static from(cause, code = _TransportError2.Code.Unknown) {
    if (cause instanceof this) return cause;
    if (cause instanceof ConnectError) {
      const key = Code[cause.code];
      const code2 = Object.hasOwn(TransportErrorCode, key) ? TransportErrorCode[key] : 2;
      return new _TransportError2(cause.message, code2, { cause, metadata: cause.metadata });
    }
    if (cause instanceof Error) {
      if (cause.name == "AbortError") {
        return new _TransportError2(
          cause.message,
          1
          /* Canceled */
        );
      }
      return new _TransportError2(cause.message, code, { cause });
    }
    return new _TransportError2(String(cause), code, { cause });
  }
};
__publicField(_TransportError, "Code", TransportErrorCode);
var TransportError = _TransportError;
function stringifyCode(value) {
  const name2 = TransportErrorCode[value];
  if (typeof name2 !== "string") return value.toString();
  return name2[0].toLowerCase() + name2.slice(1).replace(/[A-Z]/g, (char) => `_${char.toLowerCase()}`);
}
function base64UrlEncode(value) {
  return toBase64Url(base64Encode(value));
}
function toBase64Url(base64Encoded) {
  return base64Encoded.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
var textDecoder = new TextDecoder();
function base64UrlDecode(value) {
  let str2 = value;
  str2 = str2.replace(/-/g, "+").replace(/_/g, "/");
  str2 = str2.padEnd(str2.length + (4 - str2.length % 4) % 4, "=");
  return textDecoder.decode(Uint8Array.from(atob(str2), (c) => c.charCodeAt(0)));
}
function base64Decode(base64String) {
  const decoded = atob(base64String);
  return JSON.parse(decoded);
}
var textEncoder = new TextEncoder();
function base64Encode(value) {
  const data2 = typeof value === "string" ? textEncoder.encode(value) : value;
  return (0, import_base64_js.fromByteArray)(data2);
}
var __getOwnPropNames22 = Object.getOwnPropertyNames;
var __commonJS22 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames22(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_ucs2length2 = __commonJS22({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    function ucs2length(str2) {
      const len = str2.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str2.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str2.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports$1.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});
var validate2 = validate10;
var schema11 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://raw.githubusercontent.com/akash-network/chain-sdk/refs/heads/main/specs/jwt-schema.json", "title": "Akash JWT Schema", "description": "JSON Schema for JWT used in the Akash Provider API.", "type": "object", "additionalProperties": false, "required": ["iss", "iat", "exp", "nbf", "version", "leases"], "properties": { "iss": { "type": "string", "pattern": "^akash1[a-z0-9]{38}$", "description": "Akash address of the lease(s) owner, e.g., akash1abcd... (44 characters)" }, "iat": { "type": "integer", "minimum": 0, "description": "Token issuance timestamp as Unix time (seconds since 1970-01-01T00:00:00Z). Should be <= exp and >= nbf." }, "nbf": { "type": "integer", "minimum": 0, "description": "Not valid before timestamp as Unix time (seconds since 1970-01-01T00:00:00Z). Should be <= iat." }, "exp": { "type": "integer", "minimum": 0, "description": "Expiration timestamp as Unix time (seconds since 1970-01-01T00:00:00Z). Should be >= iat." }, "jti": { "type": "string", "minLength": 1, "description": "Unique identifier for the JWT, used to prevent token reuse." }, "version": { "type": "string", "enum": ["v1"], "description": "Version of the JWT specification (currently fixed at v1)." }, "leases": { "type": "object", "additionalProperties": false, "required": ["access"], "properties": { "access": { "type": "string", "enum": ["full", "granular", "scoped"], "description": "Access level for the lease: 'full' for unrestricted access to all actions, 'scoped' for specific actions across all provider leases,'granular' for provider-specific permissions." }, "scope": { "type": "array", "minItems": 1, "uniqueItems": true, "items": { "type": "string", "enum": ["send-manifest", "get-manifest", "logs", "shell", "events", "status", "restart", "hostname-migrate", "ip-migrate"] }, "description": "Global list of permitted actions across all owned leases (no duplicates). Required when access is 'scoped'." }, "permissions": { "type": "array", "description": "Required if leases.access is 'granular'; defines provider-specific permissions. The provider address must be unique across all permissions entries.", "minItems": 1, "items": { "type": "object", "additionalProperties": false, "required": ["provider", "access"], "properties": { "provider": { "type": "string", "pattern": "^akash1[a-z0-9]{38}$", "description": "Provider address, e.g., akash1xyz... (44 characters)." }, "access": { "type": "string", "enum": ["full", "scoped", "granular"], "description": "Provider-level access: 'full' for all actions, 'scoped' for specific actions across all provider leases, 'granular' for deployment-specific actions." }, "scope": { "type": "array", "minItems": 1, "uniqueItems": true, "items": { "type": "string", "enum": ["send-manifest", "get-manifest", "logs", "shell", "events", "status", "restart", "hostname-migrate", "ip-migrate"] }, "description": "Provider-level list of permitted actions for 'scoped' access (no duplicates)." }, "deployments": { "type": "array", "minItems": 1, "items": { "type": "object", "additionalProperties": false, "required": ["dseq", "scope", "services"], "properties": { "dseq": { "type": "integer", "minimum": 1, "description": "Deployment sequence number." }, "scope": { "type": "array", "minItems": 1, "uniqueItems": true, "items": { "type": "string", "enum": ["send-manifest", "get-manifest", "logs", "shell", "events", "status", "restart", "hostname-migrate", "ip-migrate"] }, "description": "Deployment-level list of permitted actions (no duplicates)." }, "gseq": { "type": "integer", "minimum": 0, "description": "Group sequence number (requires dseq)." }, "oseq": { "type": "integer", "minimum": 0, "description": "Order sequence number (requires dseq and gseq)." }, "services": { "type": "array", "minItems": 1, "uniqueItems": true, "items": { "type": "string", "minLength": 1 }, "description": "List of service names (requires dseq)." } }, "dependencies": { "gseq": ["dseq"], "oseq": ["dseq", "gseq"], "services": ["dseq"] } } } }, "allOf": [{ "if": { "properties": { "access": { "const": "scoped" } } }, "then": { "required": ["scope"], "properties": { "scope": { "minItems": 1 }, "deployments": false } } }, { "if": { "properties": { "access": { "const": "granular" } } }, "then": { "required": ["deployments"], "properties": { "scope": false } } }, { "if": { "properties": { "access": { "const": "full" } } }, "then": { "properties": { "scope": false, "deployments": false } } }] } } }, "allOf": [{ "if": { "properties": { "access": { "const": "full" } } }, "then": { "properties": { "permissions": false, "scope": false } } }, { "if": { "properties": { "access": { "const": "scoped" } } }, "then": { "required": ["scope"], "properties": { "scope": { "minItems": 1 }, "permissions": false } } }, { "if": { "properties": { "access": { "const": "granular" } }, "required": ["access"] }, "then": { "required": ["permissions"], "properties": { "scope": false } } }] } }, "allOf": [{ "if": { "properties": { "leases": { "properties": { "access": { "const": "granular" } }, "required": ["access"] } }, "required": ["leases"] }, "then": { "properties": { "leases": { "required": ["permissions"], "properties": { "scope": false } } } } }, { "if": { "properties": { "leases": { "properties": { "permissions": { "type": "array", "minItems": 1 } }, "required": ["permissions"] } }, "required": ["leases"] }, "then": { "properties": { "leases": { "properties": { "access": { "const": "granular" } }, "required": ["access"] } } } }] };
var pattern0 = new RegExp("^akash1[a-z0-9]{38}$", "u");
var func22 = require_ucs2length2().default;
function validate10(data2, { instancePath = "", parentData, parentDataProperty, rootData = data2 } = {}) {
  let vErrors = null;
  let errors = 0;
  const _errs2 = errors;
  let valid1 = true;
  const _errs3 = errors;
  if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
    if (data2.leases === void 0 && ("leases")) {
      const err0 = {};
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    } else {
      if (data2.leases !== void 0) {
        let data0 = data2.leases;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.access === void 0 && ("access")) {
            const err1 = {};
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
          } else {
            if (data0.access !== void 0) {
              if ("granular" !== data0.access) {
                const err2 = {};
                if (vErrors === null) {
                  vErrors = [err2];
                } else {
                  vErrors.push(err2);
                }
                errors++;
              }
            }
          }
        }
      }
    }
  }
  var _valid0 = _errs3 === errors;
  errors = _errs2;
  if (vErrors !== null) {
    if (_errs2) {
      vErrors.length = _errs2;
    } else {
      vErrors = null;
    }
  }
  if (_valid0) {
    const _errs6 = errors;
    if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
      if (data2.leases !== void 0) {
        let data22 = data2.leases;
        if (data22 && typeof data22 == "object" && !Array.isArray(data22)) {
          if (data22.permissions === void 0) {
            const err3 = { instancePath: instancePath + "/leases", schemaPath: "#/allOf/0/then/properties/leases/required", keyword: "required", params: { missingProperty: "permissions" }, message: "must have required property 'permissions'" };
            if (vErrors === null) {
              vErrors = [err3];
            } else {
              vErrors.push(err3);
            }
            errors++;
          }
          if (data22.scope !== void 0) {
            const err4 = { instancePath: instancePath + "/leases/scope", schemaPath: "#/allOf/0/then/properties/leases/properties/scope/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" };
            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }
            errors++;
          }
        }
      }
    }
    var _valid0 = _errs6 === errors;
    valid1 = _valid0;
  }
  if (!valid1) {
    const err5 = { instancePath, schemaPath: "#/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
    if (vErrors === null) {
      vErrors = [err5];
    } else {
      vErrors.push(err5);
    }
    errors++;
  }
  const _errs9 = errors;
  let valid6 = true;
  const _errs10 = errors;
  if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
    if (data2.leases === void 0 && ("leases")) {
      const err6 = {};
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    } else {
      if (data2.leases !== void 0) {
        let data4 = data2.leases;
        if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
          if (data4.permissions === void 0 && ("permissions")) {
            const err7 = {};
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          } else {
            if (data4.permissions !== void 0) {
              let data5 = data4.permissions;
              const _errs12 = errors;
              if (errors === _errs12) {
                if (Array.isArray(data5)) {
                  if (data5.length < 1) {
                    const err8 = {};
                    if (vErrors === null) {
                      vErrors = [err8];
                    } else {
                      vErrors.push(err8);
                    }
                    errors++;
                  }
                } else {
                  const err9 = {};
                  if (vErrors === null) {
                    vErrors = [err9];
                  } else {
                    vErrors.push(err9);
                  }
                  errors++;
                }
              }
            }
          }
        }
      }
    }
  }
  var _valid1 = _errs10 === errors;
  errors = _errs9;
  if (vErrors !== null) {
    if (_errs9) {
      vErrors.length = _errs9;
    } else {
      vErrors = null;
    }
  }
  if (_valid1) {
    const _errs14 = errors;
    if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
      if (data2.leases !== void 0) {
        let data6 = data2.leases;
        if (data6 && typeof data6 == "object" && !Array.isArray(data6)) {
          if (data6.access === void 0) {
            const err10 = { instancePath: instancePath + "/leases", schemaPath: "#/allOf/1/then/properties/leases/required", keyword: "required", params: { missingProperty: "access" }, message: "must have required property 'access'" };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors++;
          }
          if (data6.access !== void 0) {
            if ("granular" !== data6.access) {
              const err11 = { instancePath: instancePath + "/leases/access", schemaPath: "#/allOf/1/then/properties/leases/properties/access/const", keyword: "const", params: { allowedValue: "granular" }, message: "must be equal to constant" };
              if (vErrors === null) {
                vErrors = [err11];
              } else {
                vErrors.push(err11);
              }
              errors++;
            }
          }
        }
      }
    }
    var _valid1 = _errs14 === errors;
    valid6 = _valid1;
  }
  if (!valid6) {
    const err12 = { instancePath, schemaPath: "#/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
    if (vErrors === null) {
      vErrors = [err12];
    } else {
      vErrors.push(err12);
    }
    errors++;
  }
  if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
    if (data2.iss === void 0) {
      const err13 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "iss" }, message: "must have required property 'iss'" };
      if (vErrors === null) {
        vErrors = [err13];
      } else {
        vErrors.push(err13);
      }
      errors++;
    }
    if (data2.iat === void 0) {
      const err14 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "iat" }, message: "must have required property 'iat'" };
      if (vErrors === null) {
        vErrors = [err14];
      } else {
        vErrors.push(err14);
      }
      errors++;
    }
    if (data2.exp === void 0) {
      const err15 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "exp" }, message: "must have required property 'exp'" };
      if (vErrors === null) {
        vErrors = [err15];
      } else {
        vErrors.push(err15);
      }
      errors++;
    }
    if (data2.nbf === void 0) {
      const err16 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "nbf" }, message: "must have required property 'nbf'" };
      if (vErrors === null) {
        vErrors = [err16];
      } else {
        vErrors.push(err16);
      }
      errors++;
    }
    if (data2.version === void 0) {
      const err17 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "version" }, message: "must have required property 'version'" };
      if (vErrors === null) {
        vErrors = [err17];
      } else {
        vErrors.push(err17);
      }
      errors++;
    }
    if (data2.leases === void 0) {
      const err18 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "leases" }, message: "must have required property 'leases'" };
      if (vErrors === null) {
        vErrors = [err18];
      } else {
        vErrors.push(err18);
      }
      errors++;
    }
    for (const key0 in data2) {
      if (!(key0 === "iss" || key0 === "iat" || key0 === "nbf" || key0 === "exp" || key0 === "jti" || key0 === "version" || key0 === "leases")) {
        const err19 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" };
        if (vErrors === null) {
          vErrors = [err19];
        } else {
          vErrors.push(err19);
        }
        errors++;
      }
    }
    if (data2.iss !== void 0) {
      let data8 = data2.iss;
      if (typeof data8 === "string") {
        if (!pattern0.test(data8)) {
          const err20 = { instancePath: instancePath + "/iss", schemaPath: "#/properties/iss/pattern", keyword: "pattern", params: { pattern: "^akash1[a-z0-9]{38}$" }, message: 'must match pattern "^akash1[a-z0-9]{38}$"' };
          if (vErrors === null) {
            vErrors = [err20];
          } else {
            vErrors.push(err20);
          }
          errors++;
        }
      } else {
        const err21 = { instancePath: instancePath + "/iss", schemaPath: "#/properties/iss/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        if (vErrors === null) {
          vErrors = [err21];
        } else {
          vErrors.push(err21);
        }
        errors++;
      }
    }
    if (data2.iat !== void 0) {
      let data9 = data2.iat;
      if (!(typeof data9 == "number" && (!(data9 % 1) && !isNaN(data9)))) {
        const err22 = { instancePath: instancePath + "/iat", schemaPath: "#/properties/iat/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
        if (vErrors === null) {
          vErrors = [err22];
        } else {
          vErrors.push(err22);
        }
        errors++;
      }
      if (typeof data9 == "number") {
        if (data9 < 0 || isNaN(data9)) {
          const err23 = { instancePath: instancePath + "/iat", schemaPath: "#/properties/iat/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
          if (vErrors === null) {
            vErrors = [err23];
          } else {
            vErrors.push(err23);
          }
          errors++;
        }
      }
    }
    if (data2.nbf !== void 0) {
      let data10 = data2.nbf;
      if (!(typeof data10 == "number" && (!(data10 % 1) && !isNaN(data10)))) {
        const err24 = { instancePath: instancePath + "/nbf", schemaPath: "#/properties/nbf/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
        if (vErrors === null) {
          vErrors = [err24];
        } else {
          vErrors.push(err24);
        }
        errors++;
      }
      if (typeof data10 == "number") {
        if (data10 < 0 || isNaN(data10)) {
          const err25 = { instancePath: instancePath + "/nbf", schemaPath: "#/properties/nbf/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
          if (vErrors === null) {
            vErrors = [err25];
          } else {
            vErrors.push(err25);
          }
          errors++;
        }
      }
    }
    if (data2.exp !== void 0) {
      let data11 = data2.exp;
      if (!(typeof data11 == "number" && (!(data11 % 1) && !isNaN(data11)))) {
        const err26 = { instancePath: instancePath + "/exp", schemaPath: "#/properties/exp/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
        if (vErrors === null) {
          vErrors = [err26];
        } else {
          vErrors.push(err26);
        }
        errors++;
      }
      if (typeof data11 == "number") {
        if (data11 < 0 || isNaN(data11)) {
          const err27 = { instancePath: instancePath + "/exp", schemaPath: "#/properties/exp/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
          if (vErrors === null) {
            vErrors = [err27];
          } else {
            vErrors.push(err27);
          }
          errors++;
        }
      }
    }
    if (data2.jti !== void 0) {
      let data12 = data2.jti;
      if (typeof data12 === "string") {
        if (func22(data12) < 1) {
          const err28 = { instancePath: instancePath + "/jti", schemaPath: "#/properties/jti/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
          if (vErrors === null) {
            vErrors = [err28];
          } else {
            vErrors.push(err28);
          }
          errors++;
        }
      } else {
        const err29 = { instancePath: instancePath + "/jti", schemaPath: "#/properties/jti/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        if (vErrors === null) {
          vErrors = [err29];
        } else {
          vErrors.push(err29);
        }
        errors++;
      }
    }
    if (data2.version !== void 0) {
      let data13 = data2.version;
      if (typeof data13 !== "string") {
        const err30 = { instancePath: instancePath + "/version", schemaPath: "#/properties/version/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        if (vErrors === null) {
          vErrors = [err30];
        } else {
          vErrors.push(err30);
        }
        errors++;
      }
      if (!(data13 === "v1")) {
        const err31 = { instancePath: instancePath + "/version", schemaPath: "#/properties/version/enum", keyword: "enum", params: { allowedValues: schema11.properties.version.enum }, message: "must be equal to one of the allowed values" };
        if (vErrors === null) {
          vErrors = [err31];
        } else {
          vErrors.push(err31);
        }
        errors++;
      }
    }
    if (data2.leases !== void 0) {
      let data14 = data2.leases;
      const _errs33 = errors;
      let valid13 = true;
      const _errs34 = errors;
      if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
        if (data14.access !== void 0) {
          if ("full" !== data14.access) {
            const err32 = {};
            if (vErrors === null) {
              vErrors = [err32];
            } else {
              vErrors.push(err32);
            }
            errors++;
          }
        }
      }
      var _valid2 = _errs34 === errors;
      errors = _errs33;
      if (vErrors !== null) {
        if (_errs33) {
          vErrors.length = _errs33;
        } else {
          vErrors = null;
        }
      }
      if (_valid2) {
        const _errs36 = errors;
        if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
          if (data14.permissions !== void 0) {
            const err33 = { instancePath: instancePath + "/leases/permissions", schemaPath: "#/properties/leases/allOf/0/then/properties/permissions/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" };
            if (vErrors === null) {
              vErrors = [err33];
            } else {
              vErrors.push(err33);
            }
            errors++;
          }
          if (data14.scope !== void 0) {
            const err34 = { instancePath: instancePath + "/leases/scope", schemaPath: "#/properties/leases/allOf/0/then/properties/scope/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" };
            if (vErrors === null) {
              vErrors = [err34];
            } else {
              vErrors.push(err34);
            }
            errors++;
          }
        }
        var _valid2 = _errs36 === errors;
        valid13 = _valid2;
      }
      if (!valid13) {
        const err35 = { instancePath: instancePath + "/leases", schemaPath: "#/properties/leases/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
        if (vErrors === null) {
          vErrors = [err35];
        } else {
          vErrors.push(err35);
        }
        errors++;
      }
      const _errs38 = errors;
      let valid16 = true;
      const _errs39 = errors;
      if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
        if (data14.access !== void 0) {
          if ("scoped" !== data14.access) {
            const err36 = {};
            if (vErrors === null) {
              vErrors = [err36];
            } else {
              vErrors.push(err36);
            }
            errors++;
          }
        }
      }
      var _valid3 = _errs39 === errors;
      errors = _errs38;
      if (vErrors !== null) {
        if (_errs38) {
          vErrors.length = _errs38;
        } else {
          vErrors = null;
        }
      }
      if (_valid3) {
        const _errs41 = errors;
        if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
          if (data14.scope === void 0) {
            const err37 = { instancePath: instancePath + "/leases", schemaPath: "#/properties/leases/allOf/1/then/required", keyword: "required", params: { missingProperty: "scope" }, message: "must have required property 'scope'" };
            if (vErrors === null) {
              vErrors = [err37];
            } else {
              vErrors.push(err37);
            }
            errors++;
          }
          if (data14.scope !== void 0) {
            let data19 = data14.scope;
            if (Array.isArray(data19)) {
              if (data19.length < 1) {
                const err38 = { instancePath: instancePath + "/leases/scope", schemaPath: "#/properties/leases/allOf/1/then/properties/scope/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                if (vErrors === null) {
                  vErrors = [err38];
                } else {
                  vErrors.push(err38);
                }
                errors++;
              }
            }
          }
          if (data14.permissions !== void 0) {
            const err39 = { instancePath: instancePath + "/leases/permissions", schemaPath: "#/properties/leases/allOf/1/then/properties/permissions/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" };
            if (vErrors === null) {
              vErrors = [err39];
            } else {
              vErrors.push(err39);
            }
            errors++;
          }
        }
        var _valid3 = _errs41 === errors;
        valid16 = _valid3;
      }
      if (!valid16) {
        const err40 = { instancePath: instancePath + "/leases", schemaPath: "#/properties/leases/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
        if (vErrors === null) {
          vErrors = [err40];
        } else {
          vErrors.push(err40);
        }
        errors++;
      }
      const _errs44 = errors;
      let valid19 = true;
      const _errs45 = errors;
      if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
        if (data14.access === void 0 && ("access")) {
          const err41 = {};
          if (vErrors === null) {
            vErrors = [err41];
          } else {
            vErrors.push(err41);
          }
          errors++;
        } else {
          if (data14.access !== void 0) {
            if ("granular" !== data14.access) {
              const err42 = {};
              if (vErrors === null) {
                vErrors = [err42];
              } else {
                vErrors.push(err42);
              }
              errors++;
            }
          }
        }
      }
      var _valid4 = _errs45 === errors;
      errors = _errs44;
      if (vErrors !== null) {
        if (_errs44) {
          vErrors.length = _errs44;
        } else {
          vErrors = null;
        }
      }
      if (_valid4) {
        const _errs47 = errors;
        if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
          if (data14.permissions === void 0) {
            const err43 = { instancePath: instancePath + "/leases", schemaPath: "#/properties/leases/allOf/2/then/required", keyword: "required", params: { missingProperty: "permissions" }, message: "must have required property 'permissions'" };
            if (vErrors === null) {
              vErrors = [err43];
            } else {
              vErrors.push(err43);
            }
            errors++;
          }
          if (data14.scope !== void 0) {
            const err44 = { instancePath: instancePath + "/leases/scope", schemaPath: "#/properties/leases/allOf/2/then/properties/scope/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" };
            if (vErrors === null) {
              vErrors = [err44];
            } else {
              vErrors.push(err44);
            }
            errors++;
          }
        }
        var _valid4 = _errs47 === errors;
        valid19 = _valid4;
      }
      if (!valid19) {
        const err45 = { instancePath: instancePath + "/leases", schemaPath: "#/properties/leases/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
        if (vErrors === null) {
          vErrors = [err45];
        } else {
          vErrors.push(err45);
        }
        errors++;
      }
      if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
        if (data14.access === void 0) {
          const err46 = { instancePath: instancePath + "/leases", schemaPath: "#/properties/leases/required", keyword: "required", params: { missingProperty: "access" }, message: "must have required property 'access'" };
          if (vErrors === null) {
            vErrors = [err46];
          } else {
            vErrors.push(err46);
          }
          errors++;
        }
        for (const key1 in data14) {
          if (!(key1 === "access" || key1 === "scope" || key1 === "permissions")) {
            const err47 = { instancePath: instancePath + "/leases", schemaPath: "#/properties/leases/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" };
            if (vErrors === null) {
              vErrors = [err47];
            } else {
              vErrors.push(err47);
            }
            errors++;
          }
        }
        if (data14.access !== void 0) {
          let data23 = data14.access;
          if (typeof data23 !== "string") {
            const err48 = { instancePath: instancePath + "/leases/access", schemaPath: "#/properties/leases/properties/access/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err48];
            } else {
              vErrors.push(err48);
            }
            errors++;
          }
          if (!(data23 === "full" || data23 === "granular" || data23 === "scoped")) {
            const err49 = { instancePath: instancePath + "/leases/access", schemaPath: "#/properties/leases/properties/access/enum", keyword: "enum", params: { allowedValues: schema11.properties.leases.properties.access.enum }, message: "must be equal to one of the allowed values" };
            if (vErrors === null) {
              vErrors = [err49];
            } else {
              vErrors.push(err49);
            }
            errors++;
          }
        }
        if (data14.scope !== void 0) {
          let data24 = data14.scope;
          if (Array.isArray(data24)) {
            if (data24.length < 1) {
              const err50 = { instancePath: instancePath + "/leases/scope", schemaPath: "#/properties/leases/properties/scope/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
              if (vErrors === null) {
                vErrors = [err50];
              } else {
                vErrors.push(err50);
              }
              errors++;
            }
            const len0 = data24.length;
            for (let i0 = 0; i0 < len0; i0++) {
              let data25 = data24[i0];
              if (typeof data25 !== "string") {
                const err51 = { instancePath: instancePath + "/leases/scope/" + i0, schemaPath: "#/properties/leases/properties/scope/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err51];
                } else {
                  vErrors.push(err51);
                }
                errors++;
              }
              if (!(data25 === "send-manifest" || data25 === "get-manifest" || data25 === "logs" || data25 === "shell" || data25 === "events" || data25 === "status" || data25 === "restart" || data25 === "hostname-migrate" || data25 === "ip-migrate")) {
                const err52 = { instancePath: instancePath + "/leases/scope/" + i0, schemaPath: "#/properties/leases/properties/scope/items/enum", keyword: "enum", params: { allowedValues: schema11.properties.leases.properties.scope.items.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err52];
                } else {
                  vErrors.push(err52);
                }
                errors++;
              }
            }
            let i1 = data24.length;
            let j0;
            if (i1 > 1) {
              const indices0 = {};
              for (; i1--; ) {
                let item0 = data24[i1];
                if (typeof item0 !== "string") {
                  continue;
                }
                if (typeof indices0[item0] == "number") {
                  j0 = indices0[item0];
                  const err53 = { instancePath: instancePath + "/leases/scope", schemaPath: "#/properties/leases/properties/scope/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)" };
                  if (vErrors === null) {
                    vErrors = [err53];
                  } else {
                    vErrors.push(err53);
                  }
                  errors++;
                  break;
                }
                indices0[item0] = i1;
              }
            }
          } else {
            const err54 = { instancePath: instancePath + "/leases/scope", schemaPath: "#/properties/leases/properties/scope/type", keyword: "type", params: { type: "array" }, message: "must be array" };
            if (vErrors === null) {
              vErrors = [err54];
            } else {
              vErrors.push(err54);
            }
            errors++;
          }
        }
        if (data14.permissions !== void 0) {
          let data26 = data14.permissions;
          if (Array.isArray(data26)) {
            if (data26.length < 1) {
              const err55 = { instancePath: instancePath + "/leases/permissions", schemaPath: "#/properties/leases/properties/permissions/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
              if (vErrors === null) {
                vErrors = [err55];
              } else {
                vErrors.push(err55);
              }
              errors++;
            }
            const len1 = data26.length;
            for (let i2 = 0; i2 < len1; i2++) {
              let data27 = data26[i2];
              const _errs60 = errors;
              let valid29 = true;
              const _errs61 = errors;
              if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                if (data27.access !== void 0) {
                  if ("scoped" !== data27.access) {
                    const err56 = {};
                    if (vErrors === null) {
                      vErrors = [err56];
                    } else {
                      vErrors.push(err56);
                    }
                    errors++;
                  }
                }
              }
              var _valid5 = _errs61 === errors;
              errors = _errs60;
              if (vErrors !== null) {
                if (_errs60) {
                  vErrors.length = _errs60;
                } else {
                  vErrors = null;
                }
              }
              if (_valid5) {
                const _errs63 = errors;
                if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                  if (data27.scope === void 0) {
                    const err57 = { instancePath: instancePath + "/leases/permissions/" + i2, schemaPath: "#/properties/leases/properties/permissions/items/allOf/0/then/required", keyword: "required", params: { missingProperty: "scope" }, message: "must have required property 'scope'" };
                    if (vErrors === null) {
                      vErrors = [err57];
                    } else {
                      vErrors.push(err57);
                    }
                    errors++;
                  }
                  if (data27.scope !== void 0) {
                    let data29 = data27.scope;
                    if (Array.isArray(data29)) {
                      if (data29.length < 1) {
                        const err58 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/scope", schemaPath: "#/properties/leases/properties/permissions/items/allOf/0/then/properties/scope/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                        if (vErrors === null) {
                          vErrors = [err58];
                        } else {
                          vErrors.push(err58);
                        }
                        errors++;
                      }
                    }
                  }
                  if (data27.deployments !== void 0) {
                    const err59 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments", schemaPath: "#/properties/leases/properties/permissions/items/allOf/0/then/properties/deployments/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" };
                    if (vErrors === null) {
                      vErrors = [err59];
                    } else {
                      vErrors.push(err59);
                    }
                    errors++;
                  }
                }
                var _valid5 = _errs63 === errors;
                valid29 = _valid5;
              }
              if (!valid29) {
                const err60 = { instancePath: instancePath + "/leases/permissions/" + i2, schemaPath: "#/properties/leases/properties/permissions/items/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err60];
                } else {
                  vErrors.push(err60);
                }
                errors++;
              }
              const _errs66 = errors;
              let valid32 = true;
              const _errs67 = errors;
              if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                if (data27.access !== void 0) {
                  if ("granular" !== data27.access) {
                    const err61 = {};
                    if (vErrors === null) {
                      vErrors = [err61];
                    } else {
                      vErrors.push(err61);
                    }
                    errors++;
                  }
                }
              }
              var _valid6 = _errs67 === errors;
              errors = _errs66;
              if (vErrors !== null) {
                if (_errs66) {
                  vErrors.length = _errs66;
                } else {
                  vErrors = null;
                }
              }
              if (_valid6) {
                const _errs69 = errors;
                if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                  if (data27.deployments === void 0) {
                    const err62 = { instancePath: instancePath + "/leases/permissions/" + i2, schemaPath: "#/properties/leases/properties/permissions/items/allOf/1/then/required", keyword: "required", params: { missingProperty: "deployments" }, message: "must have required property 'deployments'" };
                    if (vErrors === null) {
                      vErrors = [err62];
                    } else {
                      vErrors.push(err62);
                    }
                    errors++;
                  }
                  if (data27.scope !== void 0) {
                    const err63 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/scope", schemaPath: "#/properties/leases/properties/permissions/items/allOf/1/then/properties/scope/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" };
                    if (vErrors === null) {
                      vErrors = [err63];
                    } else {
                      vErrors.push(err63);
                    }
                    errors++;
                  }
                }
                var _valid6 = _errs69 === errors;
                valid32 = _valid6;
              }
              if (!valid32) {
                const err64 = { instancePath: instancePath + "/leases/permissions/" + i2, schemaPath: "#/properties/leases/properties/permissions/items/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err64];
                } else {
                  vErrors.push(err64);
                }
                errors++;
              }
              const _errs71 = errors;
              let valid35 = true;
              const _errs72 = errors;
              if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                if (data27.access !== void 0) {
                  if ("full" !== data27.access) {
                    const err65 = {};
                    if (vErrors === null) {
                      vErrors = [err65];
                    } else {
                      vErrors.push(err65);
                    }
                    errors++;
                  }
                }
              }
              var _valid7 = _errs72 === errors;
              errors = _errs71;
              if (vErrors !== null) {
                if (_errs71) {
                  vErrors.length = _errs71;
                } else {
                  vErrors = null;
                }
              }
              if (_valid7) {
                const _errs74 = errors;
                if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                  if (data27.scope !== void 0) {
                    const err66 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/scope", schemaPath: "#/properties/leases/properties/permissions/items/allOf/2/then/properties/scope/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" };
                    if (vErrors === null) {
                      vErrors = [err66];
                    } else {
                      vErrors.push(err66);
                    }
                    errors++;
                  }
                  if (data27.deployments !== void 0) {
                    const err67 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments", schemaPath: "#/properties/leases/properties/permissions/items/allOf/2/then/properties/deployments/false schema", keyword: "false schema", params: {}, message: "boolean schema is false" };
                    if (vErrors === null) {
                      vErrors = [err67];
                    } else {
                      vErrors.push(err67);
                    }
                    errors++;
                  }
                }
                var _valid7 = _errs74 === errors;
                valid35 = _valid7;
              }
              if (!valid35) {
                const err68 = { instancePath: instancePath + "/leases/permissions/" + i2, schemaPath: "#/properties/leases/properties/permissions/items/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err68];
                } else {
                  vErrors.push(err68);
                }
                errors++;
              }
              if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                if (data27.provider === void 0) {
                  const err69 = { instancePath: instancePath + "/leases/permissions/" + i2, schemaPath: "#/properties/leases/properties/permissions/items/required", keyword: "required", params: { missingProperty: "provider" }, message: "must have required property 'provider'" };
                  if (vErrors === null) {
                    vErrors = [err69];
                  } else {
                    vErrors.push(err69);
                  }
                  errors++;
                }
                if (data27.access === void 0) {
                  const err70 = { instancePath: instancePath + "/leases/permissions/" + i2, schemaPath: "#/properties/leases/properties/permissions/items/required", keyword: "required", params: { missingProperty: "access" }, message: "must have required property 'access'" };
                  if (vErrors === null) {
                    vErrors = [err70];
                  } else {
                    vErrors.push(err70);
                  }
                  errors++;
                }
                for (const key2 in data27) {
                  if (!(key2 === "provider" || key2 === "access" || key2 === "scope" || key2 === "deployments")) {
                    const err71 = { instancePath: instancePath + "/leases/permissions/" + i2, schemaPath: "#/properties/leases/properties/permissions/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                      vErrors = [err71];
                    } else {
                      vErrors.push(err71);
                    }
                    errors++;
                  }
                }
                if (data27.provider !== void 0) {
                  let data36 = data27.provider;
                  if (typeof data36 === "string") {
                    if (!pattern0.test(data36)) {
                      const err72 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/provider", schemaPath: "#/properties/leases/properties/permissions/items/properties/provider/pattern", keyword: "pattern", params: { pattern: "^akash1[a-z0-9]{38}$" }, message: 'must match pattern "^akash1[a-z0-9]{38}$"' };
                      if (vErrors === null) {
                        vErrors = [err72];
                      } else {
                        vErrors.push(err72);
                      }
                      errors++;
                    }
                  } else {
                    const err73 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/provider", schemaPath: "#/properties/leases/properties/permissions/items/properties/provider/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err73];
                    } else {
                      vErrors.push(err73);
                    }
                    errors++;
                  }
                }
                if (data27.access !== void 0) {
                  let data37 = data27.access;
                  if (typeof data37 !== "string") {
                    const err74 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/access", schemaPath: "#/properties/leases/properties/permissions/items/properties/access/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err74];
                    } else {
                      vErrors.push(err74);
                    }
                    errors++;
                  }
                  if (!(data37 === "full" || data37 === "scoped" || data37 === "granular")) {
                    const err75 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/access", schemaPath: "#/properties/leases/properties/permissions/items/properties/access/enum", keyword: "enum", params: { allowedValues: schema11.properties.leases.properties.permissions.items.properties.access.enum }, message: "must be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err75];
                    } else {
                      vErrors.push(err75);
                    }
                    errors++;
                  }
                }
                if (data27.scope !== void 0) {
                  let data38 = data27.scope;
                  if (Array.isArray(data38)) {
                    if (data38.length < 1) {
                      const err76 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/scope", schemaPath: "#/properties/leases/properties/permissions/items/properties/scope/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                      if (vErrors === null) {
                        vErrors = [err76];
                      } else {
                        vErrors.push(err76);
                      }
                      errors++;
                    }
                    const len2 = data38.length;
                    for (let i3 = 0; i3 < len2; i3++) {
                      let data39 = data38[i3];
                      if (typeof data39 !== "string") {
                        const err77 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/scope/" + i3, schemaPath: "#/properties/leases/properties/permissions/items/properties/scope/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err77];
                        } else {
                          vErrors.push(err77);
                        }
                        errors++;
                      }
                      if (!(data39 === "send-manifest" || data39 === "get-manifest" || data39 === "logs" || data39 === "shell" || data39 === "events" || data39 === "status" || data39 === "restart" || data39 === "hostname-migrate" || data39 === "ip-migrate")) {
                        const err78 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/scope/" + i3, schemaPath: "#/properties/leases/properties/permissions/items/properties/scope/items/enum", keyword: "enum", params: { allowedValues: schema11.properties.leases.properties.permissions.items.properties.scope.items.enum }, message: "must be equal to one of the allowed values" };
                        if (vErrors === null) {
                          vErrors = [err78];
                        } else {
                          vErrors.push(err78);
                        }
                        errors++;
                      }
                    }
                    let i4 = data38.length;
                    let j1;
                    if (i4 > 1) {
                      const indices1 = {};
                      for (; i4--; ) {
                        let item1 = data38[i4];
                        if (typeof item1 !== "string") {
                          continue;
                        }
                        if (typeof indices1[item1] == "number") {
                          j1 = indices1[item1];
                          const err79 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/scope", schemaPath: "#/properties/leases/properties/permissions/items/properties/scope/uniqueItems", keyword: "uniqueItems", params: { i: i4, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i4 + " are identical)" };
                          if (vErrors === null) {
                            vErrors = [err79];
                          } else {
                            vErrors.push(err79);
                          }
                          errors++;
                          break;
                        }
                        indices1[item1] = i4;
                      }
                    }
                  } else {
                    const err80 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/scope", schemaPath: "#/properties/leases/properties/permissions/items/properties/scope/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                    if (vErrors === null) {
                      vErrors = [err80];
                    } else {
                      vErrors.push(err80);
                    }
                    errors++;
                  }
                }
                if (data27.deployments !== void 0) {
                  let data40 = data27.deployments;
                  if (Array.isArray(data40)) {
                    if (data40.length < 1) {
                      const err81 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                      if (vErrors === null) {
                        vErrors = [err81];
                      } else {
                        vErrors.push(err81);
                      }
                      errors++;
                    }
                    const len3 = data40.length;
                    for (let i5 = 0; i5 < len3; i5++) {
                      let data41 = data40[i5];
                      if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                        if (data41.dseq === void 0) {
                          const err82 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/required", keyword: "required", params: { missingProperty: "dseq" }, message: "must have required property 'dseq'" };
                          if (vErrors === null) {
                            vErrors = [err82];
                          } else {
                            vErrors.push(err82);
                          }
                          errors++;
                        }
                        if (data41.scope === void 0) {
                          const err83 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/required", keyword: "required", params: { missingProperty: "scope" }, message: "must have required property 'scope'" };
                          if (vErrors === null) {
                            vErrors = [err83];
                          } else {
                            vErrors.push(err83);
                          }
                          errors++;
                        }
                        if (data41.services === void 0) {
                          const err84 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/required", keyword: "required", params: { missingProperty: "services" }, message: "must have required property 'services'" };
                          if (vErrors === null) {
                            vErrors = [err84];
                          } else {
                            vErrors.push(err84);
                          }
                          errors++;
                        }
                        for (const key3 in data41) {
                          if (!(key3 === "dseq" || key3 === "scope" || key3 === "gseq" || key3 === "oseq" || key3 === "services")) {
                            const err85 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" };
                            if (vErrors === null) {
                              vErrors = [err85];
                            } else {
                              vErrors.push(err85);
                            }
                            errors++;
                          }
                        }
                        if (data41.gseq !== void 0) {
                          if (data41.dseq === void 0) {
                            const err86 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/dependencies", keyword: "dependencies", params: {
                              property: "gseq",
                              missingProperty: "dseq",
                              depsCount: 1,
                              deps: "dseq"
                            }, message: "must have property dseq when property gseq is present" };
                            if (vErrors === null) {
                              vErrors = [err86];
                            } else {
                              vErrors.push(err86);
                            }
                            errors++;
                          }
                        }
                        if (data41.oseq !== void 0) {
                          if (data41.dseq === void 0) {
                            const err87 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/dependencies", keyword: "dependencies", params: {
                              property: "oseq",
                              missingProperty: "dseq",
                              depsCount: 2,
                              deps: "dseq, gseq"
                            }, message: "must have properties dseq, gseq when property oseq is present" };
                            if (vErrors === null) {
                              vErrors = [err87];
                            } else {
                              vErrors.push(err87);
                            }
                            errors++;
                          }
                          if (data41.gseq === void 0) {
                            const err88 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/dependencies", keyword: "dependencies", params: {
                              property: "oseq",
                              missingProperty: "gseq",
                              depsCount: 2,
                              deps: "dseq, gseq"
                            }, message: "must have properties dseq, gseq when property oseq is present" };
                            if (vErrors === null) {
                              vErrors = [err88];
                            } else {
                              vErrors.push(err88);
                            }
                            errors++;
                          }
                        }
                        if (data41.services !== void 0) {
                          if (data41.dseq === void 0) {
                            const err89 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/dependencies", keyword: "dependencies", params: {
                              property: "services",
                              missingProperty: "dseq",
                              depsCount: 1,
                              deps: "dseq"
                            }, message: "must have property dseq when property services is present" };
                            if (vErrors === null) {
                              vErrors = [err89];
                            } else {
                              vErrors.push(err89);
                            }
                            errors++;
                          }
                        }
                        if (data41.dseq !== void 0) {
                          let data42 = data41.dseq;
                          if (!(typeof data42 == "number" && (!(data42 % 1) && !isNaN(data42)))) {
                            const err90 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/dseq", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/dseq/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                            if (vErrors === null) {
                              vErrors = [err90];
                            } else {
                              vErrors.push(err90);
                            }
                            errors++;
                          }
                          if (typeof data42 == "number") {
                            if (data42 < 1 || isNaN(data42)) {
                              const err91 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/dseq", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/dseq/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" };
                              if (vErrors === null) {
                                vErrors = [err91];
                              } else {
                                vErrors.push(err91);
                              }
                              errors++;
                            }
                          }
                        }
                        if (data41.scope !== void 0) {
                          let data43 = data41.scope;
                          if (Array.isArray(data43)) {
                            if (data43.length < 1) {
                              const err92 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/scope", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                              if (vErrors === null) {
                                vErrors = [err92];
                              } else {
                                vErrors.push(err92);
                              }
                              errors++;
                            }
                            const len4 = data43.length;
                            for (let i6 = 0; i6 < len4; i6++) {
                              let data44 = data43[i6];
                              if (typeof data44 !== "string") {
                                const err93 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/scope/" + i6, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                if (vErrors === null) {
                                  vErrors = [err93];
                                } else {
                                  vErrors.push(err93);
                                }
                                errors++;
                              }
                              if (!(data44 === "send-manifest" || data44 === "get-manifest" || data44 === "logs" || data44 === "shell" || data44 === "events" || data44 === "status" || data44 === "restart" || data44 === "hostname-migrate" || data44 === "ip-migrate")) {
                                const err94 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/scope/" + i6, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/items/enum", keyword: "enum", params: { allowedValues: schema11.properties.leases.properties.permissions.items.properties.deployments.items.properties.scope.items.enum }, message: "must be equal to one of the allowed values" };
                                if (vErrors === null) {
                                  vErrors = [err94];
                                } else {
                                  vErrors.push(err94);
                                }
                                errors++;
                              }
                            }
                            let i7 = data43.length;
                            let j2;
                            if (i7 > 1) {
                              const indices2 = {};
                              for (; i7--; ) {
                                let item2 = data43[i7];
                                if (typeof item2 !== "string") {
                                  continue;
                                }
                                if (typeof indices2[item2] == "number") {
                                  j2 = indices2[item2];
                                  const err95 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/scope", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/uniqueItems", keyword: "uniqueItems", params: { i: i7, j: j2 }, message: "must NOT have duplicate items (items ## " + j2 + " and " + i7 + " are identical)" };
                                  if (vErrors === null) {
                                    vErrors = [err95];
                                  } else {
                                    vErrors.push(err95);
                                  }
                                  errors++;
                                  break;
                                }
                                indices2[item2] = i7;
                              }
                            }
                          } else {
                            const err96 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/scope", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                            if (vErrors === null) {
                              vErrors = [err96];
                            } else {
                              vErrors.push(err96);
                            }
                            errors++;
                          }
                        }
                        if (data41.gseq !== void 0) {
                          let data45 = data41.gseq;
                          if (!(typeof data45 == "number" && (!(data45 % 1) && !isNaN(data45)))) {
                            const err97 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/gseq", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/gseq/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                            if (vErrors === null) {
                              vErrors = [err97];
                            } else {
                              vErrors.push(err97);
                            }
                            errors++;
                          }
                          if (typeof data45 == "number") {
                            if (data45 < 0 || isNaN(data45)) {
                              const err98 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/gseq", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/gseq/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
                              if (vErrors === null) {
                                vErrors = [err98];
                              } else {
                                vErrors.push(err98);
                              }
                              errors++;
                            }
                          }
                        }
                        if (data41.oseq !== void 0) {
                          let data46 = data41.oseq;
                          if (!(typeof data46 == "number" && (!(data46 % 1) && !isNaN(data46)))) {
                            const err99 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/oseq", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/oseq/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
                            if (vErrors === null) {
                              vErrors = [err99];
                            } else {
                              vErrors.push(err99);
                            }
                            errors++;
                          }
                          if (typeof data46 == "number") {
                            if (data46 < 0 || isNaN(data46)) {
                              const err100 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/oseq", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/oseq/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
                              if (vErrors === null) {
                                vErrors = [err100];
                              } else {
                                vErrors.push(err100);
                              }
                              errors++;
                            }
                          }
                        }
                        if (data41.services !== void 0) {
                          let data47 = data41.services;
                          if (Array.isArray(data47)) {
                            if (data47.length < 1) {
                              const err101 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/services", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                              if (vErrors === null) {
                                vErrors = [err101];
                              } else {
                                vErrors.push(err101);
                              }
                              errors++;
                            }
                            const len5 = data47.length;
                            for (let i8 = 0; i8 < len5; i8++) {
                              let data48 = data47[i8];
                              if (typeof data48 === "string") {
                                if (func22(data48) < 1) {
                                  const err102 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/services/" + i8, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/items/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                                  if (vErrors === null) {
                                    vErrors = [err102];
                                  } else {
                                    vErrors.push(err102);
                                  }
                                  errors++;
                                }
                              } else {
                                const err103 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/services/" + i8, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                if (vErrors === null) {
                                  vErrors = [err103];
                                } else {
                                  vErrors.push(err103);
                                }
                                errors++;
                              }
                            }
                            let i9 = data47.length;
                            let j3;
                            if (i9 > 1) {
                              const indices3 = {};
                              for (; i9--; ) {
                                let item3 = data47[i9];
                                if (typeof item3 !== "string") {
                                  continue;
                                }
                                if (typeof indices3[item3] == "number") {
                                  j3 = indices3[item3];
                                  const err104 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/services", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/uniqueItems", keyword: "uniqueItems", params: { i: i9, j: j3 }, message: "must NOT have duplicate items (items ## " + j3 + " and " + i9 + " are identical)" };
                                  if (vErrors === null) {
                                    vErrors = [err104];
                                  } else {
                                    vErrors.push(err104);
                                  }
                                  errors++;
                                  break;
                                }
                                indices3[item3] = i9;
                              }
                            }
                          } else {
                            const err105 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5 + "/services", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                            if (vErrors === null) {
                              vErrors = [err105];
                            } else {
                              vErrors.push(err105);
                            }
                            errors++;
                          }
                        }
                      } else {
                        const err106 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments/" + i5, schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                        if (vErrors === null) {
                          vErrors = [err106];
                        } else {
                          vErrors.push(err106);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err107 = { instancePath: instancePath + "/leases/permissions/" + i2 + "/deployments", schemaPath: "#/properties/leases/properties/permissions/items/properties/deployments/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                    if (vErrors === null) {
                      vErrors = [err107];
                    } else {
                      vErrors.push(err107);
                    }
                    errors++;
                  }
                }
              } else {
                const err108 = { instancePath: instancePath + "/leases/permissions/" + i2, schemaPath: "#/properties/leases/properties/permissions/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err108];
                } else {
                  vErrors.push(err108);
                }
                errors++;
              }
            }
          } else {
            const err109 = { instancePath: instancePath + "/leases/permissions", schemaPath: "#/properties/leases/properties/permissions/type", keyword: "type", params: { type: "array" }, message: "must be array" };
            if (vErrors === null) {
              vErrors = [err109];
            } else {
              vErrors.push(err109);
            }
            errors++;
          }
        }
      } else {
        const err110 = { instancePath: instancePath + "/leases", schemaPath: "#/properties/leases/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        if (vErrors === null) {
          vErrors = [err110];
        } else {
          vErrors.push(err110);
        }
        errors++;
      }
    }
  } else {
    const err111 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
    if (vErrors === null) {
      vErrors = [err111];
    } else {
      vErrors.push(err111);
    }
    errors++;
  }
  validate10.errors = vErrors;
  return errors === 0;
}
var schema2 = schema11;
var JwtValidator = class {
  /**
   * Validate a JWT token against the Akash JWT schema
   * @param token The JWT token to validate
   * @returns Validation result with errors if any
   */
  validateToken(token) {
    const result2 = {
      isValid: false,
      errors: []
    };
    try {
      if (typeof token === "string" && !token.trim()) {
        result2.errors.push("Error validating token: Empty token provided");
        return result2;
      } else if (typeof token !== "string" && (!token || Object.keys(token).length === 0)) {
        result2.errors.push("Error validating token: Empty payload provided");
        return result2;
      }
      let payload;
      if (typeof token === "string") {
        const parts = token.split(".", 3);
        if (parts.length !== 3) {
          result2.errors.push("Error validating token: Invalid token format");
          return result2;
        }
        const [headerB64, payloadB64, signature] = parts;
        const header = base64Decode(headerB64);
        payload = base64Decode(payloadB64);
        result2.decodedToken = {
          header,
          payload,
          signature
        };
        if (!header.alg) {
          result2.errors.push("Missing required field in header: alg");
          return result2;
        }
      } else {
        payload = token;
      }
      let valid = validate2(payload);
      if (!valid) {
        result2.errors = humanizeErrors(validate2.errors, schema2).map((error) => error.message);
      }
      if (payload.leases?.access === "granular") {
        if (!payload.leases?.permissions) {
          result2.errors.push("Missing required field: permissions");
          valid = false;
        } else {
          const providers = /* @__PURE__ */ new Set();
          for (const perm of payload.leases.permissions) {
            if (providers.has(perm.provider)) {
              result2.errors.push("Duplicate provider in permissions");
              valid = false;
              break;
            }
            providers.add(perm.provider);
          }
          for (const perm of payload.leases.permissions) {
            if (perm.access === "scoped") {
              if (!perm.scope) {
                result2.errors.push("Missing required field: scope for scoped access");
                valid = false;
              } else if (perm.deployments) {
                result2.errors.push("Deployments not allowed for scoped access");
                valid = false;
              }
            } else if (perm.access === "granular") {
              if (!perm.deployments) {
                result2.errors.push("Missing required field: deployments for granular access");
                valid = false;
              } else if (perm.scope) {
                result2.errors.push("Scope not allowed for granular access");
                valid = false;
              }
            }
            if (perm.deployments) {
              for (const deployment of perm.deployments) {
                if (!this.validateDeployment(deployment, result2)) {
                  valid = false;
                }
              }
            }
          }
        }
      } else if (payload.leases?.access === "full" && payload.leases?.permissions) {
        result2.errors.push("Permissions not allowed for full access");
        valid = false;
      }
      result2.isValid = result2.errors.length === 0;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      result2.errors.push(`Error during JWT validation: ${errorMessage}`);
    }
    return result2;
  }
  /**
   * Validates deployment structure and dependencies
   * @param deployment The deployment to validate
   * @param result The validation result to update
   * @returns Whether the validation passed
   */
  validateDeployment(deployment, result2) {
    let valid = true;
    if (deployment.gseq && !deployment.dseq) {
      result2.errors.push("gseq requires dseq");
      valid = false;
    }
    if (deployment.oseq && (!deployment.dseq || !deployment.gseq)) {
      result2.errors.push("oseq requires dseq and gseq");
      valid = false;
    }
    if (deployment.dseq && !deployment.services) {
      result2.errors.push("services required when dseq is present");
      valid = false;
    }
    if (deployment.services && !deployment.dseq) {
      result2.errors.push("services requires dseq");
      valid = false;
    }
    return valid;
  }
};
function createOfflineDataSigner(wallet) {
  return {
    algorithm: "ES256KADR36",
    async signArbitrary(signer, data2) {
      const { signature } = await wallet.signAmino(signer, {
        chain_id: "",
        account_number: "0",
        sequence: "0",
        fee: {
          gas: "0",
          amount: []
        },
        msgs: [
          {
            type: "sign/MsgSignData",
            value: {
              signer,
              data: base64Encode(data2)
            }
          }
        ],
        memo: ""
      });
      return signature;
    }
  };
}
var JwtTokenManager = class {
  constructor(signer) {
    __publicField(this, "validator");
    __publicField(this, "signer");
    this.validator = new JwtValidator();
    this.signer = "signAmino" in signer ? createOfflineDataSigner(signer) : signer;
  }
  /**
   * Creates a new JWT token with ES256K signature using a custom signArbitrary method with the current wallet
   * @param options - JWT token options
   * @returns The signed JWT token
   * @example
   * const wallet = await Secp256k1HdWallet.fromMnemonic(jwtMnemonic, {
   *   prefix: "akash"
   * });
   * const jwtToken = new JwtTokenManager(wallet);
   * // OR ON FRONTEND
   * const wallet = useSelectedChain();
   * const jwt = new JwtTokenManager(wallet);
   * const token = await jwtToken.generateToken({
   *   version: "v1",
   *   iss: wallet.address, // akash1...
   *   exp: Math.floor(Date.now() / 1000) + 3600, // 1 hour from now
   *   iat: Math.floor(Date.now() / 1000), // current timestamp
   * });
   * console.log(token);
   */
  async generateToken(options) {
    const now = Math.floor(Date.now() / 1e3);
    const inputPayload = {
      iss: options.iss,
      exp: options.exp ? options.exp : now + 3600,
      // Default to 1 hour expiration
      nbf: options.nbf || now,
      iat: options.iat || now,
      version: options.version,
      leases: options.leases || { access: "full" }
    };
    if (options.jti) inputPayload.jti = options.jti;
    const validationResult = this.validatePayload(inputPayload);
    if (!validationResult.isValid) {
      throw new Error(`Invalid payload: ${validationResult.errors?.join(", ")}`);
    }
    const header = base64UrlEncode((0, import_json_stable_stringify3.default)({ alg: this.signer.algorithm || "ES256KADR36", typ: "JWT" }));
    const stringPayload = base64UrlEncode((0, import_json_stable_stringify3.default)(inputPayload));
    const { signature } = await this.signer.signArbitrary(options.iss, `${header}.${stringPayload}`);
    const token = `${header}.${stringPayload}.${toBase64Url(signature)}`;
    return token;
  }
  /**
   * Decodes a JWT token
   * @param token - The JWT token to decode
   * @returns The decoded JWT payload
   * @throws Error if the token is malformed
   */
  decodeToken(token) {
    const parts = token.split(".");
    if (parts.length !== 3) {
      throw new Error("Invalid JWT format");
    }
    try {
      const [, payload] = parts;
      const json2 = base64UrlDecode(payload);
      return JSON.parse(json2);
    } catch (error) {
      throw new Error("Failed to decode JWT token", { cause: error });
    }
  }
  /**
   * Validates a JWT payload against the schema and time-based constraints
   * @param payload - The JWT payload to validate
   * @returns A boolean indicating whether the payload is valid
   */
  validatePayload(payload) {
    const result2 = this.validator.validateToken(payload);
    if (!result2.isValid) {
      return { isValid: false, errors: result2.errors };
    }
    const now = Math.floor(Date.now() / 1e3);
    const errors = [];
    if (payload.exp <= now) {
      errors.push("Token has expired");
    }
    if (payload.nbf > now) {
      errors.push("Token is not yet valid (nbf check failed)");
    }
    return {
      isValid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
};
function createMessageType({ $type, ...schema32 }) {
  return {
    typeUrl: `/${$type}`,
    ...schema32
  };
}
createMessageType(TxRaw);
/* @__PURE__ */ new Set([
  TransportError.Code.Unavailable,
  TransportError.Code.DeadlineExceeded,
  TransportError.Code.Internal,
  TransportError.Code.Unknown
]);

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/index.js
init_chunk_VRE72ZD5();
init_chunk_XIHNXIBW();
init_chunk_2NTJ26VF();

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/chunk-Z5KZUB7X.js
init_chunk_ZG2HL3EK();
init_chunk_JISXXX24();
init_chunk_CVQBDXFP();
init_chunk_OHAEKHAC();
init_chunk_35BIJBXD();

// ../../node_modules/@akashnetwork/chain-sdk/dist/esm/index.js
init_chunk_JVVKYOWN();
init_chunk_FDDF54PA();
init_chunk_ZG2HL3EK();
init_chunk_JISXXX24();
init_chunk_XFCN5LRY();
init_chunk_CVQBDXFP();
init_chunk_OHAEKHAC();
init_chunk_5YECXI3P();
init_chunk_5DCYIWCG();
init_chunk_CT7AHZAH();
init_chunk_HAJWJBJS();
init_chunk_NX2OO5DC();
init_chunk_GEEFQK3U();
init_chunk_JGBH2EPB();
init_chunk_HA6PREOG();
init_chunk_ESEV5MX6();
init_chunk_VTTNPU3L();
init_chunk_WEZWIYX4();
init_chunk_35BIJBXD();
__toESM(require_build6(), 1);
__toESM(require_build11(), 1);

// src/provider.ts
var import_amino = __toESM(require_build5());
var HANDLE_WHEN = handleWhenResult((response) => {
  if (!response || !(response instanceof Response)) return false;
  return response.status >= 500;
}).orWhen((error) => isNetworkError(error) || !!error.cause && isNetworkError(error.cause));
var RETRY_POLICY = retry(HANDLE_WHEN, {
  backoff: new ExponentialBackoff({
    initialDelay: 1e3,
    maxDelay: 1e4
  }),
  maxAttempts: 5
});
async function sendManifest(input) {
  const fetch2 = input.fetch || globalThis.fetch;
  const response = await RETRY_POLICY.execute(async () => {
    return await fetch2(`${input.providerHostUri}/deployment/${input.dseq}/manifest`, {
      method: "PUT",
      body: input.manifest,
      signal: AbortSignal.timeout(6e4),
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${input.token}`
      }
    });
  });
  if (response.status > 300) {
    throw new Error(`Failed to send manifest: ${response.status} ${await response.text()}`);
  }
  return response;
}
function isNetworkError(error) {
  const code = error.code;
  return code === "ECONNREFUSED" || code === "ECONNRESET" || code === "ETIMEDOUT" || code === "ESOCKETTIMEDOUT" || code === "UND_ERR_SOCKET" || error.name === "AbortError";
}
async function generateToken(wallet, genPermissions) {
  const aminoWallet = await import_amino.Secp256k1HdWallet.fromMnemonic(wallet.mnemonic, { prefix: "akash" });
  const [account] = await wallet.getAccounts();
  const providerTokenManager = new JwtTokenManager(aminoWallet);
  const token = await providerTokenManager.generateToken({
    version: "v1",
    iss: account.address,
    exp: Math.floor(Date.now() / 1e3 + 5 * 60),
    leases: genPermissions()
  });
  return token;
}
async function getLeaseStatus(input) {
  const fetch2 = input.fetch || globalThis.fetch;
  const response = await RETRY_POLICY.execute(async () => {
    return await fetch2(`${input.providerHostUri}/lease/${input.dseq}/1/1/status`, {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${input.token}`
      }
    });
  });
  if (response.status > 300) {
    throw new Error(`Failed to get lease status: ${response.status} ${await response.text()}`);
  }
  return await response.json();
}
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)

jsrsasign/lib/jsrsasign.js:
  (*! CryptoJS v3.1.2 core-fix.js
   * code.google.com/p/crypto-js
   * (c) 2009-2013 by Jeff Mott. All rights reserved.
   * code.google.com/p/crypto-js/wiki/License
   * THIS IS FIX of 'core.js' to fix Hmac issue.
   * https://code.google.com/p/crypto-js/issues/detail?id=84
   * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
   *)
  (*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
   *)
  (*! (c) Tom Wu, Kenji Urushima | http://www-cs-students.stanford.edu/~tjw/jsbn/
   *)
  (*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
   *)
  (*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/_shortw_utils.js:
@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

hash-wasm/dist/index.esm.js:
  (*!
   * hash-wasm (https://www.npmjs.com/package/hash-wasm)
   * (c) Dani Biro
   * @license MIT
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT *)
*/

exports.generateToken = generateToken;
exports.getLeaseStatus = getLeaseStatus;
exports.sendManifest = sendManifest;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map